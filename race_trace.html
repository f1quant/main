<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Race Visualization v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <link rel="stylesheet" href="common.css">
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>
  <style>
    /* Page-specific overrides */
    :root { --bg:#0f1115; --fg:#e8e8e8; --muted:#8b8b8b; --panel:#1a1d24; --border:#232833; }
    body { font-size:14px; background:var(--bg); color:var(--fg); }

    /* Simpler select styling for this page */
    select {
      background:#11141a;
      color:var(--fg);
      border:1px solid #2a2f3a;
      padding:6px 8px;
      border-radius:8px;
      min-width: 160px;
      width: auto;
      background-image: none;
      transform: none !important;
    }
    select:hover:not(:disabled) {
      transform: none;
      box-shadow: none;
    }

    input[type="number"] { width:90px; }

    header { padding:10px 14px; background:var(--panel); display:flex; gap:12px; align-items:center; flex-wrap:wrap; border-bottom:1px solid var(--border); }
    .title { font-weight:600; margin-right:auto; }
    .small { color:var(--muted); font-size:12px; }
    .layout { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 56px - 45px); }
    #sidebar { background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; }
    #sidebar .section { padding:12px; border-bottom:1px solid var(--border); }
    #driverList { padding:10px; overflow:auto; }
    .driver { display:flex; align-items:center; gap:8px; padding:4px 2px; border-radius:6px; }
    .driver:hover { background:#141820; }
    #chart { width:100%; height:100%; }
    .buttons { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
    .credit { position:fixed; left:12px; bottom:10px; z-index:9999; font-size:12px; color:var(--muted); text-decoration:none; opacity:0.9; }
    .credit:hover { text-decoration:underline; opacity:1; }

    .debug-info {
      padding: 20px;
      color: var(--fg);
      font-size: 14px;
    }

    .driver label { cursor:pointer; user-select:none; }
  </style>
</head>
<body>
  <header>
    <label class="small" for="seasonSel">Season</label>
    <select id="seasonSel" title="Season">
      <option value=""></option>
    </select>
    <label class="small" for="gpSel">GP</label>
    <select id="gpSel" title="Grand Prix" disabled>
      <option value=""></option>
    </select>
    <label class="small" for="sessionSel">Session</label>
    <select id="sessionSel" title="Session type" disabled>
      <option value=""></option>
    </select>
    <label class="small" for="lapMin">Lap min</label>
    <input id="lapMin" type="number" min="1" step="1" value="1" title="Min lap" />
    <label class="small" for="lapMax">Lap max</label>
    <input id="lapMax" type="number" min="1" step="1" value="1" title="Max lap" />
    <span class="status-message" id="statusMessage">Loading...</span>
  </header>

  <div class="layout">
    <aside id="sidebar">
      <div class="section">
        <div class="buttons">
          <button id="btnAll"  type="button">Select all</button>
          <button id="btnNone" type="button">Clear all</button>
        </div>
      </div>
      <div id="driverList" aria-label="Driver list"></div>
    </aside>
    <main id="chart">
      <div class="debug-info" id="debugInfo">
        Waiting for data...
      </div>
    </main>
  </div>

  <!-- Papa Parse from CDN -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const seasonSel = document.getElementById("seasonSel");
    const gpSel = document.getElementById("gpSel");
    const sessionSel = document.getElementById("sessionSel");
    const lapMin = document.getElementById("lapMin");
    const lapMax = document.getElementById("lapMax");
    const statusMessage = document.getElementById("statusMessage");
    const debugInfo = document.getElementById("debugInfo");
    const driverList = document.getElementById("driverList");
    const btnAll = document.getElementById("btnAll");
    const btnNone = document.getElementById("btnNone");

    let allRows = [];
    let sessionsByKey = new Map();
    let currentSessionRows = []; // Store current session rows for rainfall detection
    let driverLines = {}; // {driver: {laps: [lap#], gaps: [gap in seconds]}}
    let selectedDrivers = new Set();
    let myChart = null;

    init();

    function init() {
      DriverInfo.load(loadCSV);
      setupEventListeners();
    }

    function setupEventListeners() {
      btnAll.addEventListener("click", () => {
        selectedDrivers = new Set(Object.keys(driverLines));
        updateDriverCheckboxes();
        renderChart();
      });

      btnNone.addEventListener("click", () => {
        selectedDrivers.clear();
        updateDriverCheckboxes();
        renderChart();
      });

      lapMin.addEventListener("change", renderChart);
      lapMax.addEventListener("change", renderChart);
    }

    function getDriverInfo(driver) {
      // Get driver info for current session
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) {
        return { fullName: driver, color: '#888888', teamName: '', headshotUrl: '' };
      }

      const [round] = selectedGP.split('||');
      return DriverInfo.getDriverInfo(driver, selectedSeason, round, selectedSession);
    }

    function loadCSV() {
      ParsedDataCache.loadCSV("all_df.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRows = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.session_type !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRows.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          indexSessions(allRows);
          buildSeasonDropdown();
          statusMessage.textContent = `${allRows.length} laps loaded`;
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      seasonSel.addEventListener("change", onSeasonChange);
      gpSel.addEventListener("change", onGPChange);
      sessionSel.addEventListener("change", onSessionChange);
    }

    function indexSessions(rows) {
      sessionsByKey.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const session = String(r.session_type || "").trim();

        if (!year || !round || !meeting || !session) return;

        const key = `${year}||${round}||${meeting}||${session}`;
        if (!sessionsByKey.has(key)) {
          sessionsByKey.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            session_type: session
          });
        }
      });
    }

    function buildSeasonDropdown() {
      UIHelpers.populateSeasons(seasonSel, sessionsByKey, {
        onChange: onSeasonChange
      });
    }

    function onSeasonChange() {
      const selectedSeason = seasonSel.value;
      sessionSel.innerHTML = '';
      sessionSel.disabled = true;
      debugInfo.textContent = "Select a GP";

      UIHelpers.populateGPs(gpSel, sessionsByKey, selectedSeason, {
        onChange: onGPChange
      });
    }

    function onGPChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      debugInfo.textContent = "Select a session";

      UIHelpers.populateSessions(sessionSel, sessionsByKey, selectedSeason, selectedGP, {
        onChange: onSessionChange
      });
    }

    function onSessionChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) {
        debugInfo.textContent = "Select season, GP, and session";
        return;
      }

      const [round, meeting] = selectedGP.split('||');

      // Filter rows for this session
      const sessionRows = allRows.filter(r => {
        return String(r.year || "").trim() === selectedSeason &&
               String(r.round_no || "").trim() === round &&
               String(r.meeting_name || "").trim() === meeting &&
               String(r.session_type || "").trim() === selectedSession;
      });

      if (sessionRows.length === 0) {
        debugInfo.textContent = "No data for this session";
        return;
      }

      // Store session rows globally for rainfall detection
      currentSessionRows = sessionRows;

      // Update lap min/max based on data
      const lapNumbers = sessionRows.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n));
      const minLapNum = Math.min(...lapNumbers);
      const maxLapNum = Math.max(...lapNumbers);

      lapMin.value = minLapNum;
      lapMax.value = maxLapNum;
      lapMin.min = minLapNum;
      lapMax.max = maxLapNum;

      // Clear selected drivers for new session
      selectedDrivers.clear();

      // Calculate gaps
      calculateGaps(sessionRows);

      // Build driver list
      buildDriverList();

      // Render chart
      renderChart();

      statusMessage.textContent = `${sessionRows.length} rows loaded`;
    }

    function calculateGaps(rows) {
      // Group rows by lap number
      const lapData = new Map(); // lap# -> array of {driver, position, time}

      rows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        const driver = String(r.lap_Driver || "").trim();
        const position = parseInt(r.lap_Position);
        const lapTime = parseFloat(r.lap_Time);

        if (isNaN(lapNum) || !driver || isNaN(lapTime) || isNaN(position)) return;

        if (!lapData.has(lapNum)) {
          lapData.set(lapNum, []);
        }

        lapData.get(lapNum).push({
          driver,
          position,
          lapTime
        });
      });

      // For each lap, calculate gaps
      driverLines = {};

      lapData.forEach((driversInLap, lapNum) => {
        // Sort by position (lower is better)
        driversInLap.sort((a, b) => a.position - b.position);

        // Find minimum lap time (P1 driver)
        const minTime = Math.min(...driversInLap.map(d => d.lapTime));

        // Calculate gap for each driver (minTime - driverTime, so gaps are negative)
        driversInLap.forEach(d => {
          const gap = minTime - d.lapTime;

          if (!driverLines[d.driver]) {
            driverLines[d.driver] = {
              laps: [],
              gaps: [],
              positions: []
            };
          }

          driverLines[d.driver].laps.push(lapNum);
          driverLines[d.driver].gaps.push(gap);
          driverLines[d.driver].positions.push(d.position);
        });
      });

      // Don't auto-select here - will be done in buildDriverList based on finishing position
    }

    function buildDriverList() {
      driverList.innerHTML = '';

      // Sort drivers by finishing position
      const drivers = Object.keys(driverLines);

      // Calculate finishing position for each driver
      const driverFinishInfo = drivers.map(driver => {
        const data = driverLines[driver];
        const maxLapNum = Math.max(...data.laps);
        const lastLapIndex = data.laps.indexOf(maxLapNum);
        const lastPosition = data.positions[lastLapIndex];

        return {
          driver: driver,
          maxLapNum: maxLapNum,
          lastPosition: lastPosition
        };
      });

      // Sort by finishing position:
      // 1. More laps completed = better (descending)
      // 2. If same laps, use lap_Position (lower is better)
      driverFinishInfo.sort((a, b) => {
        if (a.maxLapNum !== b.maxLapNum) {
          return b.maxLapNum - a.maxLapNum; // More laps = finished higher
        }
        return a.lastPosition - b.lastPosition; // Lower position number = better
      });

      // Auto-select top 5 drivers if this is a new session (selectedDrivers is empty)
      const isNewSession = selectedDrivers.size === 0;
      if (isNewSession) {
        selectedDrivers.clear();
        driverFinishInfo.slice(0, 5).forEach(({ driver }) => {
          selectedDrivers.add(driver);
        });
      }

      // Build the list in finishing order
      driverFinishInfo.forEach(({ driver }) => {
        const div = document.createElement('div');
        div.className = 'driver';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `driver-${driver}`;
        checkbox.checked = selectedDrivers.has(driver);
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedDrivers.add(driver);
          } else {
            selectedDrivers.delete(driver);
          }
          renderChart();
        });

        const label = document.createElement('label');
        label.htmlFor = `driver-${driver}`;

        // Format: "Full Name (ABB)"
        const info = getDriverInfo(driver);
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        label.textContent = displayName;

        // Set label color
        label.style.color = info.color;

        div.appendChild(checkbox);
        div.appendChild(label);
        driverList.appendChild(div);
      });
    }

    function updateDriverCheckboxes() {
      Object.keys(driverLines).forEach(driver => {
        const checkbox = document.getElementById(`driver-${driver}`);
        if (checkbox) {
          checkbox.checked = selectedDrivers.has(driver);
        }
      });
    }

    function detectRainfallLaps(minLap, maxLap) {
      // Returns an array of lap ranges with rainfall: [{start: lap, end: lap}, ...]
      if (currentSessionRows.length === 0) return [];

      // Group by lap number and count drivers with rainfall
      const lapRainfall = new Map(); // lap# -> {total: count, rainfall: count}

      currentSessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRainfall.has(lapNum)) {
          lapRainfall.set(lapNum, { total: 0, rainfall: 0 });
        }

        const lapData = lapRainfall.get(lapNum);
        lapData.total++;

        // Check if this row has rainfall
        const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
        if (rainfall === 'true' || rainfall === '1') {
          lapData.rainfall++;
        }
      });

      // Find laps where >= 50% of drivers have rainfall
      const rainfallLaps = [];
      lapRainfall.forEach((data, lapNum) => {
        const rainfallPercent = data.rainfall / data.total;
        if (rainfallPercent >= 0.5) {
          rainfallLaps.push(lapNum);
        }
      });

      // Merge consecutive laps into ranges
      if (rainfallLaps.length === 0) return [];

      rainfallLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = rainfallLaps[0];
      let end = rainfallLaps[0];

      for (let i = 1; i < rainfallLaps.length; i++) {
        if (rainfallLaps[i] === end + 1) {
          // Consecutive lap
          end = rainfallLaps[i];
        } else {
          // Gap found, save current range and start new one
          ranges.push({ start, end });
          start = rainfallLaps[i];
          end = rainfallLaps[i];
        }
      }
      // Don't forget the last range
      ranges.push({ start, end });

      return ranges;
    }

    function detectSafetyCarLaps(minLap, maxLap) {
      // Returns an array of lap ranges with safety car: [{start: lap, end: lap}, ...]
      if (currentSessionRows.length === 0) return [];

      // Group by lap number and count drivers with safety car
      const lapSafetyCar = new Map(); // lap# -> {total: count, safetyCar: count}

      currentSessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapSafetyCar.has(lapNum)) {
          lapSafetyCar.set(lapNum, { total: 0, safetyCar: 0 });
        }

        const lapData = lapSafetyCar.get(lapNum);
        lapData.total++;

        // Check if this row has safety car (TrackStatus 4, 6, or 7, but NOT 5)
        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('4') || trackStatus.includes('6') || trackStatus.includes('7')) {
          // Make sure it's not "5" - check if it's exactly 4, 6, or 7
          if (!trackStatus.includes('5')) {
            lapData.safetyCar++;
          }
        }
      });

      // Find laps where >= 50% of drivers have safety car
      const safetyCarLaps = [];
      lapSafetyCar.forEach((data, lapNum) => {
        const safetyCarPercent = data.safetyCar / data.total;
        if (safetyCarPercent >= 0.5) {
          safetyCarLaps.push(lapNum);
        }
      });

      // Merge consecutive laps into ranges
      if (safetyCarLaps.length === 0) return [];

      safetyCarLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = safetyCarLaps[0];
      let end = safetyCarLaps[0];

      for (let i = 1; i < safetyCarLaps.length; i++) {
        if (safetyCarLaps[i] === end + 1) {
          // Consecutive lap
          end = safetyCarLaps[i];
        } else {
          // Gap found, save current range and start new one
          ranges.push({ start, end });
          start = safetyCarLaps[i];
          end = safetyCarLaps[i];
        }
      }
      // Don't forget the last range
      ranges.push({ start, end });

      return ranges;
    }

    function detectRedFlagLaps(minLap, maxLap) {
      // Returns an array of laps with red flags (TrackStatus contains "5")
      if (currentSessionRows.length === 0) return [];

      // Group by lap number and count drivers with red flag
      const lapRedFlag = new Map(); // lap# -> {total: count, redFlag: count}

      currentSessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRedFlag.has(lapNum)) {
          lapRedFlag.set(lapNum, { total: 0, redFlag: 0 });
        }

        const lapData = lapRedFlag.get(lapNum);
        lapData.total++;

        // Check if this row has red flag (TrackStatus contains "5")
        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('5')) {
          lapData.redFlag++;
        }
      });

      // Find laps where >= 50% of drivers have red flag
      const redFlagLaps = [];
      lapRedFlag.forEach((data, lapNum) => {
        const redFlagPercent = data.redFlag / data.total;
        if (redFlagPercent >= 0.5) {
          redFlagLaps.push(lapNum);
        }
      });

      return redFlagLaps.sort((a, b) => a - b);
    }

    function renderChart() {
      if (Object.keys(driverLines).length === 0) return;

      const chartContainer = document.getElementById('chart');

      // Remove debug info if it exists
      const debugDiv = document.getElementById('debugInfo');
      if (debugDiv) {
        debugDiv.remove();
      }

      // Initialize chart if needed
      if (!myChart) {
        myChart = echarts.init(chartContainer);
      }

      const minLap = parseInt(lapMin.value);
      const maxLap = parseInt(lapMax.value);

      // Detect rainfall, safety car, and red flag laps
      const rainfallRanges = detectRainfallLaps(minLap, maxLap);
      const safetyCarRanges = detectSafetyCarLaps(minLap, maxLap);
      const redFlagLaps = detectRedFlagLaps(minLap, maxLap);

      // Calculate rightX for anchor point (similar to gaps.html)
      const lapCount = Object.keys(driverLines).length > 0
        ? Math.max(...Object.values(driverLines).map(d => Math.max(...d.laps)))
        : maxLap;
      const rightX = (maxLap === lapCount) ? (maxLap + 0.5) : (maxLap + 0.1);

      // First pass: collect all raw gaps for selected drivers by lap
      const gapsByLap = new Map(); // lap# -> array of gaps from selected drivers

      selectedDrivers.forEach(driver => {
        const data = driverLines[driver];
        if (!data) return;

        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            if (!gapsByLap.has(lap)) {
              gapsByLap.set(lap, []);
            }
            gapsByLap.get(lap).push(data.gaps[i]);
          }
        }
      });

      // Calculate max gap for each lap (among selected drivers only)
      const maxGapByLap = new Map();
      gapsByLap.forEach((gaps, lap) => {
        maxGapByLap.set(lap, Math.max(...gaps));
      });

      // Prepare series data
      const series = [];

      selectedDrivers.forEach(driver => {
        const data = driverLines[driver];
        if (!data) return;

        // Filter by lap range and adjust gaps
        const points = [];
        let lastGap = null;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            const rawGap = data.gaps[i];
            const maxGap = maxGapByLap.get(lap) || 0;
            const adjustedGap = rawGap - maxGap;
            points.push([lap, adjustedGap]);
            lastGap = adjustedGap;
          }
        }

        if (points.length > 0) {
          const info = getDriverInfo(driver);

          // Check if driver completed all laps in range
          const completedAllLaps = data.laps.some(lap => lap === maxLap);

          // Add anchor point for label positioning (like gaps.html)
          if (completedAllLaps && lastGap !== null) {
            points.push({
              value: [rightX, lastGap],
              tooltip: { show: false },
              emphasis: { disabled: true }
            });
          }

          series.push({
            name: driver,
            type: 'line',
            data: points,
            step: 'end',
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: {
              width: 2,
              color: info.color
            },
            itemStyle: {
              color: info.color,
              borderWidth: 0
            },
            emphasis: {
              focus: 'series',
              blurScope: 'global',
              lineStyle: { width: 3.5 }
            },
            blur: {
              lineStyle: { opacity: 0.15 }
            },
            endLabel: {
              show: completedAllLaps,
              formatter: '{a}',
              position: 'right',
              offset: [6, 0],
              color: info.color
            },
            animation: false
          });
        }
      });

      // Add rainfall shading as a markArea series
      if (rainfallRanges.length > 0) {
        const markAreaData = rainfallRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end
              ? `Rainfall (Lap ${range.start})`
              : `Rainfall (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Rainfall',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: {
              color: 'rgba(30, 144, 255, 0.1)' // Blue with transparency
            },
            data: markAreaData,
            label: {
              show: false
            },
            tooltip: {
              formatter: (params) => {
                return params.name;
              }
            }
          },
          animation: false
        });
      }

      // Add safety car shading as a markArea series
      if (safetyCarRanges.length > 0) {
        const markAreaData = safetyCarRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end
              ? `Safety Car (Lap ${range.start})`
              : `Safety Car (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Safety Car',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: {
              color: 'rgba(150, 150, 7, 0.15)'
            },
            data: markAreaData,
            label: {
              show: false
            },
            tooltip: {
              formatter: (params) => {
                return params.name;
              }
            }
          },
          animation: false
        });
      }

      // Add red flag vertical lines as a markLine series
      if (redFlagLaps.length > 0) {
        const markLineData = redFlagLaps.map(lap => ({
          xAxis: lap,
          name: `Red Flag (Lap ${lap})`,
          label: {
            show: false
          }
        }));

        series.push({
          name: 'Red Flag',
          type: 'line',
          data: [],
          markLine: {
            silent: false,
            symbol: 'none',
            lineStyle: {
              color: 'rgba(255, 0, 0, 0.5)',
              width: 2,
              type: 'dotted'
            },
            data: markLineData,
            label: {
              show: false
            },
            tooltip: {
              formatter: (params) => {
                return params.name;
              }
            }
          },
          animation: false
        });
      }

      const option = {
        backgroundColor: 'transparent',
        grid: {
          left: 60,
          right: 120,
          top: 20,
          bottom: 60
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          appendToBody: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const v = Array.isArray(p.value) ? p.value : p.data?.value || p.data;
            const lap = Array.isArray(v) ? v[0] : v?.[0];
            const gap = Array.isArray(v) ? v[1] : v?.[1];
            const code = p.seriesName;
            const info = getDriverInfo(code);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || code;
              const teamName = info.teamName || '';
              const gapLine = (typeof lap === 'number' && typeof gap === 'number')
                ? `<div style="margin-top:4px">Lap ${lap}: ${gap.toFixed(3)} s</div>`
                : '';
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${code})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${gapLine}
                  </div>
                </div>
              `;
            }

            if (typeof lap === 'number' && typeof gap === 'number') {
              return `${p.marker}<b>${code}</b><br/>Lap ${lap}: ${gap.toFixed(3)} s`;
            }
            return `${p.marker}<b>${code}</b>`;
          }
        },
        legend: {
          show: false
        },
        xAxis: {
          type: 'value',
          name: 'Lap',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#8b8b8b', fontSize: 12 },
          axisLine: { lineStyle: { color: '#2a2f3a' } },
          axisLabel: { color: '#8b8b8b' },
          splitLine: { lineStyle: { color: '#232833' } },
          min: minLap,
          max: rightX
        },
        yAxis: {
          type: 'value',
          name: 'Gap (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#8b8b8b', fontSize: 12 },
          axisLine: { lineStyle: { color: '#2a2f3a' } },
          axisLabel: { color: '#8b8b8b' },
          splitLine: { lineStyle: { color: '#232833' } }
        },
        series: series
      };

      myChart.setOption(option, true);
    }
  </script>
</body>
</html>
