<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lap Grouping Analysis</title>
  <link rel="stylesheet" href="common.css">
  <style>
    /* Page-specific styles */
    .page-content {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 16px 16px;
    }

    .container {
      max-width: 1400px;
    }

    .header {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 16px;
      margin-bottom: 8px;
      padding: 0;
    }

    .circuit-selector {
      min-width: 200px;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field.horizontal {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }

    .filters-section {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .filter-panel {
      padding: 16px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .filters-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .filters-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .filter-item {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .filter-item.vertical {
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
    }

    .filter-label {
      font-size: 10px;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    input[type="number"] {
      width: 100px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .checkbox-group label {
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
    }

    .exclude-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .groups-table {
      margin-top: 20px;
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .groups-table th {
      background: rgba(0, 224, 255, 0.1);
      color: var(--accent-color);
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 10px;
      border: 1px solid var(--border-color);
    }

    .groups-table td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    .groups-table tr:hover {
      background: rgba(0, 224, 255, 0.05);
    }

    .groups-table td:last-child {
      max-width: 600px;
      word-wrap: break-word;
      white-space: normal;
    }


    @media (max-width: 640px) {
      .container {
        padding: 18px 14px 14px;
      }
      .controls {
        grid-template-columns: 1fr;
      }
      .title {
        font-size: 18px;
      }
      .subtitle {
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <div class="page-content">
  <div class="container">
    <div class="header">
      <div class="field horizontal circuit-selector">
        <div class="label">Circuit</div>
        <select id="circuitSelect">
          <option value="">—</option>
        </select>
      </div>
      <div class="field horizontal circuit-selector">
        <div class="label">Event</div>
        <select id="eventSelect">
          <option value="">—</option>
        </select>
      </div>
      <div class="status-message" id="statusMessage">Loading...</div>
    </div>

    <div style="display: flex; justify-content: center; margin-bottom: 16px;">
      <div style="width: 60%;">
        <div id="chartContainer" style="width: 100%; height: 400px; display: none;"></div>
        <div id="coefficientsContainer" style="display: none; padding: 12px 16px; background: rgba(0, 224, 255, 0.03); border-radius: 8px; border: 1px solid var(--border-color); margin-top: 8px;">
          <div style="font-size: 11px; font-weight: 600; color: var(--accent-color); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Linear Fit Coefficients (y = mx)</div>
          <div id="coefficientsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;"></div>
        </div>
      </div>
    </div>

    <div class="filters-section">
      <div class="filter-panel">
        <div class="filters-title">Adjustments</div>
        <div class="filters-grid">
          <div class="filter-item">
            <div class="filter-label">Hard Deg (sec/lap)</div>
            <input type="number" id="degHard" value="0.05" min="0" step="0.01">
          </div>
          <div class="filter-item">
            <div class="filter-label">Medium Deg (sec/lap)</div>
            <input type="number" id="degMedium" value="0.08" min="0" step="0.01">
          </div>
          <div class="filter-item">
            <div class="filter-label">Soft Deg (sec/lap)</div>
            <input type="number" id="degSoft" value="0.12" min="0" step="0.01">
          </div>
          <div class="filter-item">
            <div class="filter-label">Fuel Effect (sec/lap)</div>
            <input type="number" id="fuelEffect" value="0.03" min="0" step="0.01">
          </div>
        </div>
      </div>

      <div class="filter-panel">
        <div class="filters-title">Lap Filters</div>
        <div class="filters-grid">
          <div class="filter-item">
            <div class="filter-label">Laps to Discard at Start</div>
            <input type="number" id="filterMinLap" value="1" min="0">
          </div>
          <div class="filter-item">
            <div class="filter-label">Laps to Discard at End</div>
            <input type="number" id="filterEndLaps" value="1" min="0">
          </div>
          <div class="filter-item">
            <div class="filter-label">Min Distance to Car Ahead</div>
            <input type="number" id="filterMinDist" value="3" min="0" step="0.1">
          </div>
        </div>
      </div>

      <div class="filter-panel">
        <div class="filters-title">Include</div>
        <div class="exclude-checkboxes">
          <div class="checkbox-group">
            <input type="checkbox" id="filterIncludeLapped" checked>
            <label for="filterIncludeLapped">Lapped</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterIncludeRetired" checked>
            <label for="filterIncludeRetired">Retired</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterRainfall">
            <label for="filterRainfall">Rainfall</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterSafetyCar">
            <label for="filterSafetyCar">Safety Car</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterPitLaps">
            <label for="filterPitLaps">Pit Laps</label>
          </div>
        </div>
      </div>
    </div>

    <div id="groupsTableContainer"></div>
  </div>
  </div>

  <!-- Papa Parse from CDN -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- ECharts for charts -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>

  <script>
    const circuitSelect = document.getElementById("circuitSelect");
    const eventSelect = document.getElementById("eventSelect");
    const statusMessage = document.getElementById("statusMessage");
    const groupsTableContainer = document.getElementById("groupsTableContainer");
    const chartContainer = document.getElementById("chartContainer");
    const coefficientsContainer = document.getElementById("coefficientsContainer");
    const coefficientsGrid = document.getElementById("coefficientsGrid");

    let allRows = [];
    let eventsByKey = new Map(); // key -> {year, round_no, meeting_name, circuit_name}
    let tyreChoices = new Map(); // key (year||round_no) -> {hard, medium, soft}
    let chart = null; // ECharts instance

    init();

    // Handle window resize for chart
    window.addEventListener('resize', () => {
      if (chart) {
        chart.resize();
      }
    });

    function init() {
      // Load tyre_choices.csv first
      Papa.parse(DataCache.getCSVUrl("tyre_choices.csv"), {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.data) {
            results.data.forEach(row => {
              const year = String(row.year || "").trim();
              const round = String(row.round_no || "").trim();
              if (year && round) {
                const key = `${year}||${round}`;
                tyreChoices.set(key, {
                  hard: String(row.hard || "").trim(),
                  medium: String(row.medium || "").trim(),
                  soft: String(row.soft || "").trim()
                });
              }
            });
          }
          // Now load all_df.csv
          loadMainCSV();
        },
        error: function (err) {
          console.error("Error loading tyre_choices.csv:", err);
          loadMainCSV();
        }
      });
    }

    function loadMainCSV() {
      ParsedDataCache.loadCSV("all_df.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRows = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.circuit_name !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRows.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          buildCircuitDropdown(allRows);
          indexEvents(allRows);
          setupFilterListeners();
          statusMessage.textContent = `${allRows.length} laps loaded`;

          // Set default circuit
          circuitSelect.value = "Las Vegas";
          onCircuitChange();
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      circuitSelect.addEventListener("change", onCircuitChange);
      eventSelect.addEventListener("change", onEventSelectionChange);
    }

    function buildCircuitDropdown(rows) {
      const circuits = new Set();

      rows.forEach(r => {
        const name = (r.circuit_name || "").trim();
        if (name) circuits.add(name);
      });

      const sortedCircuits = Array.from(circuits).sort((a, b) =>
        a.localeCompare(b, undefined, { sensitivity: "base" })
      );

      sortedCircuits.forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        circuitSelect.appendChild(opt);
      });
    }

    function indexEvents(rows) {
      eventsByKey.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const circuit = String(r.circuit_name || "").trim();
        if (!year || !round || !meeting || !circuit) return;

        const key = makeEventKey(year, round, meeting, circuit);
        if (!eventsByKey.has(key)) {
          eventsByKey.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            circuit_name: circuit
          });
        }
      });
    }

    function makeEventKey(year, round, meeting, circuit) {
      return `${year}||${round}||${meeting}||${circuit}`;
    }

    function setupFilterListeners() {
      document.getElementById("filterMinLap").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterEndLaps").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterMinDist").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterRainfall").addEventListener("change", onEventSelectionChange);
      document.getElementById("filterSafetyCar").addEventListener("change", onEventSelectionChange);
      document.getElementById("filterPitLaps").addEventListener("change", onEventSelectionChange);
      document.getElementById('filterIncludeLapped').addEventListener('change', onEventSelectionChange);
      document.getElementById('filterIncludeRetired').addEventListener('change', onEventSelectionChange);
      document.getElementById('degHard').addEventListener('input', onEventSelectionChange);
      document.getElementById('degMedium').addEventListener('input', onEventSelectionChange);
      document.getElementById('degSoft').addEventListener('input', onEventSelectionChange);
      document.getElementById('fuelEffect').addEventListener('input', onEventSelectionChange);
    }

    function applyFilters(rows) {
      const lapsToDiscard = parseInt(document.getElementById("filterMinLap").value) || 0;
      const minLap = lapsToDiscard + 1;
      const endLaps = parseInt(document.getElementById("filterEndLaps").value) || 0;
      const minDist = parseFloat(document.getElementById("filterMinDist").value) || 0;
      const includeRainfall = document.getElementById("filterRainfall").checked;
      const includeSafetyCar = document.getElementById("filterSafetyCar").checked;
      const includePitLaps = document.getElementById("filterPitLaps").checked;
      const includeLapped = document.getElementById('filterIncludeLapped').checked;
      const includeRetired = document.getElementById('filterIncludeRetired').checked;

      return rows.filter(r => {
        // Session type filter - only 'R' (Race)
        const sessionType = String(r.session_type || "").trim();
        if (sessionType !== 'R') return false;

        // Min lap number
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap) return false;

        // Max lap number (sched_laps - endLaps)
        const schedLaps = parseInt(r.sched_laps);
        if (!isNaN(schedLaps)) {
          const maxLap = schedLaps - endLaps;
          if (lapNum > maxLap) return false;
        }

        // Finish status filters
        const status = String(r.finish_status ?? "").trim();
        const plusLapsMatch = status.match(/^\+(\d+)\sLaps$/);
        const lapsBehind = plusLapsMatch ? Number(plusLapsMatch[1]) : 0;
        if (lapsBehind > 1) return false; // Always exclude "+2 Laps", "+3 Laps", etc.

        const isLapped = status === "Lapped" || status === "+1 Lap";
        if (!includeLapped && isLapped) return false;

        const isFinished = status === "Finished" || isLapped;
        const isRetired = !isFinished;
        if (!includeRetired && isRetired) return false;

        // Rainfall filter
        if (!includeRainfall) {
          const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
          if (rainfall === "true" || rainfall === "1") return false;
        }

        // Safety car filter
        if (!includeSafetyCar) {
          const trackStatus = String(r.lap_TrackStatus || "").trim();
          if (trackStatus.includes("4") || trackStatus.includes("5") ||
              trackStatus.includes("6") || trackStatus.includes("7")) {
            return false;
          }
        }

        // Pit laps filter
        if (!includePitLaps) {
          const pitIn = String(r.lap_PitInTime || "").trim();
          const pitOut = String(r.lap_PitOutTime || "").trim();
          if ((pitIn && pitIn.toLowerCase() !== "na" && pitIn !== "") ||
              (pitOut && pitOut.toLowerCase() !== "na" && pitOut !== "")) {
            return false;
          }
        }

        // Min distance filter
        const dist = parseFloat(r.min_dist);
        if (!isNaN(dist) && dist < minDist) return false;

        return true;
      });
    }

    function onCircuitChange() {
      const selectedCircuit = circuitSelect.value;

      // Clear event dropdown
      eventSelect.innerHTML = '<option value="">—</option>';

      // Clear table and chart
      groupsTableContainer.innerHTML = "";
      chartContainer.style.display = 'none';
      coefficientsContainer.style.display = 'none';

      if (!selectedCircuit) {
        return;
      }

      const events = [];
      eventsByKey.forEach((val, key) => {
        if (val.circuit_name === selectedCircuit) {
          const label = `${val.year} - ${val.round_no}. ${val.meeting_name}`;
          events.push({
            key,
            label,
            year: val.year,
            round_no: val.round_no
          });
        }
      });

      events.sort((a, b) => {
        const ya = parseInt(a.year, 10) || 0;
        const yb = parseInt(b.year, 10) || 0;
        if (ya !== yb) return ya - yb;
        const ra = parseInt(a.round_no, 10) || 0;
        const rb = parseInt(b.round_no, 10) || 0;
        return ra - rb;
      });

      if (!events.length) {
        return;
      }

      // Populate event dropdown
      events.forEach((ev, index) => {
        const tyreKey = `${ev.year}||${ev.round_no}`;
        const tyres = tyreChoices.get(tyreKey);
        let tyreInfo = "";
        if (tyres && tyres.hard && tyres.medium && tyres.soft) {
          tyreInfo = ` (${tyres.hard}-${tyres.medium}-${tyres.soft})`;
        }

        const option = document.createElement("option");
        option.value = ev.key;
        option.textContent = ev.label + tyreInfo;
        eventSelect.appendChild(option);
      });

      // Select the last event by default
      if (events.length > 0) {
        eventSelect.value = events[events.length - 1].key;
        onEventSelectionChange();
      }
    }

    function onEventSelectionChange() {
      const selectedEventKey = eventSelect.value;

      if (!selectedEventKey) {
        groupsTableContainer.innerHTML = "";
        chartContainer.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        return;
      }

      const selectedEvent = eventsByKey.get(selectedEventKey);
      if (!selectedEvent) {
        groupsTableContainer.innerHTML = "";
        chartContainer.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        return;
      }

      const matchingRows = allRows.filter(r => {
        const rYear = String(r.year || "").trim();
        const rRound = String(r.round_no || "").trim();
        const rMeeting = String(r.meeting_name || "").trim();
        const rCircuit = String(r.circuit_name || "").trim();

        return (
          rYear === selectedEvent.year &&
          rRound === selectedEvent.round_no &&
          rMeeting === selectedEvent.meeting_name &&
          rCircuit === selectedEvent.circuit_name
        );
      });

      const filteredRows = applyFilters(matchingRows);
      displayGroupsTable(filteredRows);
    }

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();

      // F1 tire colors
      const colorMap = {
        'soft': '#FF0000',      // Red
        'medium': '#FFF200',    // Yellow
        'hard': '#FFFFFF',      // White
        'intermediate': '#00FF00', // Green
        'wet': '#0000FF'        // Blue
      };

      return colorMap[compoundLower] || '#999999'; // Default gray for unknown
    }

    function renderScatterPlot(groups) {
      if (groups.length === 0) {
        chartContainer.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        if (chart) {
          chart.dispose();
          chart = null;
        }
        return;
      }

      // Show chart container
      chartContainer.style.display = 'block';
      coefficientsContainer.style.display = 'block';

      // Initialize chart if needed
      if (!chart) {
        chart = echarts.init(chartContainer);
      }

      // Prepare data by compound
      const dataByCompound = new Map();

      groups.forEach(([key, group]) => {
        const compound = group.compound;
        if (!dataByCompound.has(compound)) {
          dataByCompound.set(compound, []);
        }

        // Calculate incremental differences
        for (let i = 1; i < group.laps.length; i++) {
          const lapNumDiff = group.laps[i].lapNumber - group.laps[i - 1].lapNumber;
          const lapTimeDiff = group.laps[i].lapTime - group.laps[i - 1].lapTime;

          dataByCompound.get(compound).push({
            value: [lapNumDiff, lapTimeDiff],
            driver: group.driver,
            tyreLife: group.tyreLife,
            lap1Number: group.laps[i - 1].lapNumber,
            lap1Time: group.laps[i - 1].lapTime,
            lap2Number: group.laps[i].lapNumber,
            lap2Time: group.laps[i].lapTime
          });
        }
      });

      // Calculate linear regression (zero intercept) and create series
      const series = [];
      const coefficients = new Map();

      dataByCompound.forEach((data, compound) => {
        const color = getF1TireColor(compound);

        // Add scatter series
        series.push({
          name: compound,
          type: 'scatter',
          data: data,
          symbolSize: 6,
          itemStyle: {
            color: color,
            borderColor: color,
            borderWidth: 0
          },
          emphasis: {
            focus: 'series',
            itemStyle: {
              borderWidth: 2,
              shadowBlur: 10,
              shadowColor: color
            }
          }
        });

        // Calculate linear regression with zero intercept: y = mx
        // m = Σ(xy) / Σ(x²)
        let sumXY = 0;
        let sumX2 = 0;

        data.forEach(point => {
          const x = point.value[0];
          const y = point.value[1];
          sumXY += x * y;
          sumX2 += x * x;
        });

        const slope = sumX2 !== 0 ? sumXY / sumX2 : 0;
        coefficients.set(compound, slope);

        // Find min and max x values for the line
        const xValues = data.map(point => point.value[0]);
        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);

        // Create line data
        const lineData = [
          [minX, slope * minX],
          [maxX, slope * maxX]
        ];

        // Add line series
        series.push({
          name: `${compound} fit`,
          type: 'line',
          data: lineData,
          showSymbol: false,
          lineStyle: {
            color: color,
            width: 2,
            type: 'dashed'
          },
          emphasis: { disabled: true },
          silent: true,
          zlevel: -1
        });
      });

      // Set chart options
      chart.setOption({
        backgroundColor: 'transparent',
        grid: { left: 60, right: 20, top: 50, bottom: 60 },
        legend: {
          show: true,
          top: 5,
          textStyle: { color: '#f5f5f5', fontSize: 11 },
          itemWidth: 12,
          itemHeight: 12,
          data: Array.from(dataByCompound.keys()) // Only show compounds, not fit lines
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const data = p.data;
            return `
              <strong>${p.seriesName} - ${data.driver}</strong><br/>
              Tyre Life: ${data.tyreLife}<br/>
              <br/>
              Lap ${data.lap1Number}: ${data.lap1Time.toFixed(3)}s<br/>
              Lap ${data.lap2Number}: ${data.lap2Time.toFixed(3)}s<br/>
              <br/>
              Lap # Diff: ${data.value[0]}<br/>
              Lap Time Diff: ${data.value[1].toFixed(3)}s
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Lap Number Difference',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time Difference (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        series: series
      }, true);

      // Resize chart
      chart.resize();

      // Display coefficients
      coefficientsGrid.innerHTML = '';
      coefficients.forEach((slope, compound) => {
        const color = getF1TireColor(compound);
        const coeffDiv = document.createElement('div');
        coeffDiv.style.cssText = `
          font-size: 11px;
          color: var(--text-color);
          font-family: 'Courier New', monospace;
          padding: 6px 10px;
          background: rgba(0, 0, 0, 0.3);
          border-radius: 6px;
          border-left: 3px solid ${color};
        `;
        coeffDiv.innerHTML = `<strong>${compound}:</strong> m = ${slope.toFixed(6)}`;
        coefficientsGrid.appendChild(coeffDiv);
      });
    }

    function displayGroupsTable(rows) {
      if (!rows.length) {
        groupsTableContainer.innerHTML = "";
        chartContainer.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        if (chart) {
          chart.dispose();
          chart = null;
        }
        return;
      }

      // Get degradation and fuel effect values
      const degHard = parseFloat(document.getElementById('degHard').value) || 0;
      const degMedium = parseFloat(document.getElementById('degMedium').value) || 0;
      const degSoft = parseFloat(document.getElementById('degSoft').value) || 0;
      const fuelEffect = parseFloat(document.getElementById('fuelEffect').value) || 0;

      const degradationMap = {
        'HARD': degHard,
        'MEDIUM': degMedium,
        'SOFT': degSoft
      };

      // Group by driver, compound, and tyre life
      const groups = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const compound = String(r.lap_Compound || "").trim();
        const tyreLife = String(r.lap_TyreLife || "").trim();
        const lapNumber = String(r.lap_LapNumber || "").trim();
        const schedLaps = parseInt(r.sched_laps);
        let lapTime = parseFloat(r.lap_LapTime);

        if (!driver || !compound || !tyreLife || !lapNumber || isNaN(lapTime)) {
          return; // Skip invalid rows
        }

        // Apply tyre degradation adjustment: subtract (tyre life * degradation)
        const tyreDeg = degradationMap[compound.toUpperCase()] || 0;
        const tyreLifeNum = parseInt(tyreLife);
        if (!isNaN(tyreLifeNum)) {
          lapTime -= (tyreLifeNum * tyreDeg);
        }

        // Apply fuel effect adjustment: subtract ((scheduled laps - lap number) * fuel effect)
        const lapNum = parseInt(lapNumber);
        if (!isNaN(schedLaps) && !isNaN(lapNum)) {
          lapTime -= ((schedLaps - lapNum) * fuelEffect);
        }

        const key = `${driver}||${compound}||${tyreLife}`;

        if (!groups.has(key)) {
          groups.set(key, {
            driver: driver,
            compound: compound,
            tyreLife: parseInt(tyreLife),
            laps: []
          });
        }

        groups.get(key).laps.push({
          lapNumber: parseInt(lapNumber),
          lapTime: lapTime
        });
      });

      // Filter out groups with only one lap
      const filteredGroups = Array.from(groups.entries()).filter(([key, group]) => {
        return group.laps.length > 1;
      });

      // Sort groups by compound, driver, tyre life
      const sortedGroups = filteredGroups.sort((a, b) => {
        const [keyA, groupA] = a;
        const [keyB, groupB] = b;

        if (groupA.compound !== groupB.compound) {
          return groupA.compound.localeCompare(groupB.compound);
        }

        if (groupA.driver !== groupB.driver) {
          return groupA.driver.localeCompare(groupB.driver);
        }

        return groupA.tyreLife - groupB.tyreLife;
      });

      // Render scatter plot
      renderScatterPlot(sortedGroups);

      // Build table
      let html = `
        <table class="groups-table">
          <thead>
            <tr>
              <th>Driver</th>
              <th>Compound</th>
              <th>Tyre Life</th>
              <th>Laps (Lap Number: Lap Time)</th>
            </tr>
          </thead>
          <tbody>
      `;

      sortedGroups.forEach(([key, group]) => {
        // Sort laps by lap number
        group.laps.sort((a, b) => a.lapNumber - b.lapNumber);

        // Format laps as "lapNum: lapTime, lapNum: lapTime, ..."
        const lapsText = group.laps.map(lap =>
          `${lap.lapNumber}: ${lap.lapTime.toFixed(3)}s`
        ).join(', ');

        html += `
          <tr>
            <td>${escapeHtml(group.driver)}</td>
            <td>${escapeHtml(group.compound)}</td>
            <td>${group.tyreLife}</td>
            <td>${escapeHtml(lapsText)}</td>
          </tr>
        `;
      });

      html += `
          </tbody>
        </table>
      `;

      groupsTableContainer.innerHTML = html;
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>
