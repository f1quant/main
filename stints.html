<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Race Selector</title>
  <style>
    :root {
      --bg-color: #02040a;
      --panel-color: #101320;
      --accent-color: #00e0ff;
      --accent-soft: #00e0ff33;
      --text-color: #f5f5f5;
      --muted-color: #9ca3af;
      --border-color: #27272f;
      --radius-lg: 16px;
      --transition-fast: 0.18s ease-out;
      --font: system-ui, -apple-system, BlinkMacSystemFont, -system-ui, sans-serif;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      min-height: 100vh;
      font-family: var(--font);
      background: radial-gradient(circle at top, #050816 0, #000 55%, #000 100%);
      color: var(--text-color);
    }

    .top-nav {
      background: #0a0c14;
      border-bottom: 1px solid var(--border-color);
      padding: 0;
      display: flex;
      justify-content: flex-start;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .top-nav a {
      color: var(--muted-color);
      text-decoration: none;
      padding: 12px 24px;
      font-size: 13px;
      font-weight: 500;
      transition: all var(--transition-fast);
      border-bottom: 2px solid transparent;
    }

    .top-nav a:hover {
      color: var(--text-color);
      background: rgba(0, 224, 255, 0.05);
    }

    .top-nav a.active {
      color: var(--accent-color);
      border-bottom-color: var(--accent-color);
    }

    .page-content {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 16px 16px;
    }

    .container {
      width: 100%;
      max-width: 1400px;
      background: linear-gradient(to bottom right, #050816ee, #020308f0);
      border-radius: 24px;
      padding: 12px 20px 20px;
      border: 1px solid rgba(148, 163, 253, 0.08);
      box-shadow:
        0 18px 60px rgba(0, 0, 0, 0.85),
        0 0 40px rgba(0, 224, 255, 0.05);
      backdrop-filter: blur(14px);
    }

    .header {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 16px;
      margin-bottom: 8px;
      padding: 0;
    }

    .circuit-selector {
      min-width: 200px;
    }

    .status-message {
      font-size: 11px;
      color: var(--muted-color);
      white-space: nowrap;
      margin-left: auto;
    }

    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .field.horizontal {
      flex-direction: row;
      align-items: center;
      gap: 8px;
    }

    .label {
      font-size: 11px;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 0.14em;
    }

    select {
      width: 100%;
      padding: 9px 10px;
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      background-color: #020308;
      color: var(--text-color);
      font-size: 13px;
      outline: none;
      appearance: none;
      transition:
        border-color var(--transition-fast),
        box-shadow var(--transition-fast),
        background-color var(--transition-fast),
        transform var(--transition-fast);
      box-shadow: 0 0 0 1px transparent;
      background-image:
        linear-gradient(45deg, transparent 50%, var(--accent-color) 50%),
        linear-gradient(135deg, var(--accent-color) 50%, transparent 50%);
      background-position:
        calc(100% - 16px) 11px,
        calc(100% - 11px) 11px;
      background-size: 5px 5px, 5px 5px;
      background-repeat: no-repeat;
    }

    select:disabled {
      cursor: not-allowed;
      opacity: 0.35;
      background-image: none;
    }

    select:hover:not(:disabled) {
      border-color: var(--accent-color);
      box-shadow: 0 0 12px var(--accent-soft);
      transform: translateY(-1px);
    }

    select:focus-visible {
      border-color: var(--accent-color);
      box-shadow: 0 0 14px var(--accent-soft);
    }

    .filters-section {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .filter-panel {
      padding: 16px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .filters-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .filters-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .filter-item {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .filter-item.vertical {
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
    }

    .filter-label {
      font-size: 10px;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    input[type="number"] {
      width: 100px;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background-color: #020308;
      color: var(--text-color);
      font-size: 12px;
      outline: none;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }

    input[type="number"]:focus {
      border-color: var(--accent-color);
      box-shadow: 0 0 8px var(--accent-soft);
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .checkbox-group label {
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
    }

    .exclude-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .events-list {
      max-height: 300px;
      overflow-y: auto;
      display: flex;
      flex-direction: column;
      gap: 6px;
    }

    .event-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 4px;
      border-radius: 8px;
      cursor: pointer;
      transition: background-color var(--transition-fast);
    }

    .event-item:hover {
      background-color: rgba(15, 23, 42, 0.6);
    }

    .event-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .event-label-text {
      color: var(--text-color);
      font-size: 11px;
      line-height: 1.4;
      user-select: none;
    }

    .events-placeholder {
      color: var(--muted-color);
      font-size: 10px;
      padding: 4px 0;
    }


    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-value {
      font-size: 11px;
      color: var(--accent-color);
      font-weight: 600;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--border-color);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      box-shadow: 0 0 8px var(--accent-soft);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px var(--accent-soft);
    }

    .dropdown-container {
      position: relative;
    }

    .dropdown-trigger {
      width: 100%;
      padding: 6px 8px;
      border-radius: 8px;
      border: 1px solid var(--border-color);
      background-color: #020308;
      color: var(--text-color);
      font-size: 12px;
      cursor: pointer;
      display: flex;
      justify-content: space-between;
      align-items: center;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast);
    }

    .dropdown-trigger:hover {
      border-color: var(--accent-color);
      box-shadow: 0 0 8px var(--accent-soft);
    }

    .dropdown-content {
      display: none;
      position: absolute;
      top: 100%;
      left: 0;
      right: 0;
      margin-top: 4px;
      padding: 8px;
      background-color: #020308;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      max-height: 200px;
      overflow-y: auto;
      z-index: 100;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .dropdown-content.show {
      display: block;
    }

    .dropdown-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px;
    }

    .dropdown-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .dropdown-item label {
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
      flex: 1;
    }

    .groups-table {
      margin-top: 20px;
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .groups-table th {
      background: rgba(0, 224, 255, 0.1);
      color: var(--accent-color);
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 10px;
      border: 1px solid var(--border-color);
    }

    .groups-table td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    .groups-table tr:hover {
      background: rgba(0, 224, 255, 0.05);
    }

    .error-cell {
      color: #ff4444;
      font-weight: 600;
    }

    .charts-wrapper {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .chart-container {
      padding: 20px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .chart-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #scatterChart, #lapTimeChart {
      max-height: 500px;
    }

    .chart-controls {
      margin-top: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .toggle-button {
      padding: 4px 12px;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .toggle-button.active {
      background: var(--accent-color);
      color: #000;
      border-color: var(--accent-color);
    }

    .toggle-button:hover {
      border-color: var(--accent-color);
    }

    .equations-section {
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(0, 224, 255, 0.05);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 253, 0.15);
    }

    .equations-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .equations-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 8px;
    }

    .equation-item {
      font-size: 11px;
      color: var(--text-color);
      font-family: 'Courier New', monospace;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      border-left: 3px solid;
    }

    .stint-checkbox {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .clickable-header {
      cursor: pointer;
      user-select: none;
      position: relative;
      transition: color var(--transition-fast);
    }

    .clickable-header:hover {
      color: var(--accent-color);
    }

    .clickable-header::after {
      content: " ▾";
      font-size: 10px;
      opacity: 0.6;
    }

    .header-dropdown {
      position: absolute;
      background: #0a0c14;
      border: 1px solid var(--accent-color);
      border-radius: 8px;
      padding: 8px;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8), 0 0 16px var(--accent-soft);
      z-index: 1000;
      display: none;
      margin-top: 2px;
    }

    .groups-table {
      position: relative;
    }

    .header-dropdown.show {
      display: block;
    }

    .dropdown-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      font-size: 11px;
      color: var(--text-color);
      border-bottom: 1px solid rgba(148, 163, 253, 0.1);
    }

    .dropdown-option:last-child {
      border-bottom: none;
    }

    .dropdown-option-label {
      flex: 1;
    }

    .dropdown-option-buttons {
      display: flex;
      gap: 4px;
    }

    .dropdown-btn {
      padding: 2px 8px;
      font-size: 9px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .dropdown-btn:hover {
      border-color: var(--accent-color);
      background: rgba(0, 224, 255, 0.15);
    }

    @media (max-width: 640px) {
      .container {
        padding: 18px 14px 14px;
      }
      .controls {
        grid-template-columns: 1fr;
      }
      .title {
        font-size: 18px;
      }
      .subtitle {
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <nav class="top-nav">
    <a href="index.html">Gaps</a>
    <a href="strat_calc.html">Strategy Calculator</a>
    <a href="stints.html" class="active">Stints</a>
  </nav>
  <div class="page-content">
  <div class="container">
    <div class="header">
      <div class="field horizontal circuit-selector">
        <div class="label">Circuit</div>
        <select id="circuitSelect">
          <option value="">—</option>
        </select>
      </div>
      <div class="status-message" id="statusMessage">Loading...</div>
    </div>

    <div id="chartsWrapper" class="charts-wrapper" style="display: none;">
      <div id="scatterChartContainer" class="chart-container">
        <div class="chart-title">Tire Degradation Analysis: Deg vs Pace</div>
        <div id="scatterChart" style="width: 100%; height: 400px;"></div>
        <div id="equationsSection" class="equations-section" style="display: none;">
          <div class="equations-title">Best Fit Equations (Deg = m × Pace + b)</div>
          <div id="equationsGrid" class="equations-grid"></div>
        </div>
      </div>

      <div id="lapTimeChartContainer" class="chart-container">
        <div class="chart-title">Lap Time vs Tyre Age</div>
        <div class="chart-controls">
          <button id="fuelAdjustToggle" class="toggle-button active">Fuel Adjusted</button>
          <span style="font-size: 10px; color: var(--muted-color);" id="selectedStintCount">No stints selected</span>
        </div>
        <div id="lapTimeChart" style="width: 100%; height: 400px;"></div>
      </div>
    </div>

    <div class="filters-section">
      <div class="filter-panel">
        <div class="filters-title">Events</div>
        <div id="eventsList" class="events-list">
          <div class="events-placeholder">Select a circuit to view events</div>
        </div>
      </div>

      <div class="filter-panel">
        <div class="filters-grid">
          <div class="filter-item vertical">
            <div class="filter-label">Fuel Effect (s/lap)</div>
            <div class="slider-container">
              <input type="range" id="fuelEffectSlider" min="0" max="0.1" step="0.001" value="0.025">
              <div class="slider-value" id="fuelEffectValue">0.025</div>
            </div>
          </div>
          <div class="filter-item">
            <div class="filter-label">Laps to Discard at Start</div>
            <input type="number" id="filterMinLap" value="1" min="0">
          </div>
          <div class="filter-item">
            <div class="filter-label">Laps to Discard at End</div>
            <input type="number" id="filterEndLaps" value="5" min="0">
          </div>
          <div class="filter-item">
            <div class="filter-label">Min Distance to Car Ahead</div>
            <input type="number" id="filterMinDist" value="10" min="0" step="0.1">
          </div>
          <div class="filter-item">
            <div class="filter-label">Min Rows Per Stint</div>
            <input type="number" id="filterMinRows" value="7" min="1">
          </div>
          <div class="filter-item">
            <div class="filter-label">Min Correlation</div>
            <input type="number" id="filterMinCorr" value="0.5" min="-1" max="1" step="0.1">
          </div>
        </div>
      </div>

      <div class="filter-panel">
        <div class="filters-title">Exclude</div>
        <div class="exclude-checkboxes">
          <div class="checkbox-group">
            <input type="checkbox" id="filterIncludeLapped" checked>
            <label for="filterIncludeLapped">Lapped</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterRainfall" checked>
            <label for="filterRainfall">Rainfall</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterSafetyCar" checked>
            <label for="filterSafetyCar">Safety Car</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterPitLaps" checked>
            <label for="filterPitLaps">Pit Laps</label>
          </div>
        </div>
      </div>
    </div>

    <div id="groupsTableContainer"></div>
  </div>
  </div>

  <!-- Papa Parse from CDN -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- Simple Statistics for linear regression -->
  <script src="https://unpkg.com/simple-statistics@7.8.3/dist/simple-statistics.min.js"></script>

  <!-- ECharts for charts -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>

  <script>
    const circuitSelect = document.getElementById("circuitSelect");
    const eventsList = document.getElementById("eventsList");
    const statusMessage = document.getElementById("statusMessage");
    const groupsTableContainer = document.getElementById("groupsTableContainer");
    const chartsWrapper = document.getElementById("chartsWrapper");
    const scatterChartContainer = document.getElementById("scatterChart");
    const lapTimeChartContainer = document.getElementById("lapTimeChart");
    const equationsSection = document.getElementById("equationsSection");
    const equationsGrid = document.getElementById("equationsGrid");
    const fuelAdjustToggle = document.getElementById("fuelAdjustToggle");
    const selectedStintCount = document.getElementById("selectedStintCount");

    let allRows = [];
    let eventsByKey = new Map(); // key -> {year, round_no, meeting_name, circuit_name}
    let tyreChoices = new Map(); // key (year||round_no) -> {hard, medium, soft}
    let scatterChart = null; // ECharts instance
    let lapTimeChart = null; // ECharts instance for lap times
    let selectedStints = new Set(); // Set of selected stint keys
    let activeDropdown = null; // Active header dropdown
    let activeDropdownColumn = null; // Track which column's dropdown is open

    init();

    // Handle window resize for ECharts
    window.addEventListener('resize', () => {
      if (lapTimeChart) {
        lapTimeChart.resize();
      }
      if (scatterChart) {
        scatterChart.resize();
      }
    });

    function init() {
      // Load tyre_choices.csv first
      Papa.parse("tyre_choices.csv?t=" + Date.now(), {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.data) {
            results.data.forEach(row => {
              const year = String(row.year || "").trim();
              const round = String(row.round_no || "").trim();
              if (year && round) {
                const key = `${year}||${round}`;
                tyreChoices.set(key, {
                  hard: String(row.hard || "").trim(),
                  medium: String(row.medium || "").trim(),
                  soft: String(row.soft || "").trim()
                });
              }
            });
          }
          // Now load all_df.csv
          loadMainCSV();
        },
        error: function (err) {
          console.error("Error loading tyre_choices.csv:", err);
          loadMainCSV();
        }
      });
    }

    function loadMainCSV() {
      Papa.parse("all_df.csv?t=" + Date.now(), {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRows = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.circuit_name !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRows.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          buildCircuitDropdown(allRows);
          indexEvents(allRows);
          setupFilterListeners();
          statusMessage.textContent = `${allRows.length} rows loaded`;

          // Set default circuit to Interlagos
          circuitSelect.value = "Interlagos";
          onCircuitChange();
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      circuitSelect.addEventListener("change", onCircuitChange);
    }

    function buildCircuitDropdown(rows) {
      const circuits = new Set();

      rows.forEach(r => {
        const name = (r.circuit_name || "").trim();
        if (name) circuits.add(name);
      });

      const sortedCircuits = Array.from(circuits).sort((a, b) =>
        a.localeCompare(b, undefined, { sensitivity: "base" })
      );

      sortedCircuits.forEach(name => {
        const opt = document.createElement("option");
        opt.value = name;
        opt.textContent = name;
        circuitSelect.appendChild(opt);
      });
    }

    function indexEvents(rows) {
      eventsByKey.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const circuit = String(r.circuit_name || "").trim();
        if (!year || !round || !meeting || !circuit) return;

        const key = makeEventKey(year, round, meeting, circuit);
        if (!eventsByKey.has(key)) {
          eventsByKey.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            circuit_name: circuit
          });
        }
      });
    }

    function makeEventKey(year, round, meeting, circuit) {
      return `${year}||${round}||${meeting}||${circuit}`;
    }

    function setupFilterListeners() {
      document.getElementById("filterMinLap").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterEndLaps").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterMinDist").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterMinRows").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterMinCorr").addEventListener("input", onEventSelectionChange);
      document.getElementById("filterRainfall").addEventListener("change", onEventSelectionChange);
      document.getElementById("filterSafetyCar").addEventListener("change", onEventSelectionChange);
      document.getElementById("filterPitLaps").addEventListener("change", onEventSelectionChange);
      document.getElementById('filterIncludeLapped').addEventListener('change', onEventSelectionChange);

      // Fuel effect slider
      const fuelEffectSlider = document.getElementById("fuelEffectSlider");
      const fuelEffectValue = document.getElementById("fuelEffectValue");
      fuelEffectSlider.addEventListener("input", function() {
        fuelEffectValue.textContent = parseFloat(this.value).toFixed(3);
        onEventSelectionChange();
      });

      // Fuel adjust toggle for lap time chart
      fuelAdjustToggle.addEventListener("click", function() {
        this.classList.toggle("active");
        // Get current filtered groups from the displayed table
        const currentFilteredGroups = getCurrentFilteredGroups();
        updateLapTimeChart(currentFilteredGroups);
      });
    }

    function getCurrentFilteredGroups() {
      // This is a helper to get the current filtered groups
      // We'll store it globally when we build the table
      return window.currentFilteredGroups || new Map();
    }

    function applyFilters(rows) {
      const lapsToDiscard = parseInt(document.getElementById("filterMinLap").value) || 1;
      const minLap = lapsToDiscard + 1;
      const endLaps = parseInt(document.getElementById("filterEndLaps").value) || 5;
      const minDist = parseFloat(document.getElementById("filterMinDist").value) || 10;
      const excludeRainfall = document.getElementById("filterRainfall").checked;
      const excludeSafetyCar = document.getElementById("filterSafetyCar").checked;
      const excludePitLaps = document.getElementById("filterPitLaps").checked;
      const excludeLapped = document.getElementById('filterIncludeLapped').checked;
      
      return rows.filter(r => {
        // Min lap number
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap) return false;
        
        // Max lap number (sched_laps - endLaps)
        const schedLaps = parseInt(r.sched_laps);
        if (!isNaN(schedLaps)) {
          const maxLap = schedLaps - endLaps;
          if (lapNum > maxLap) return false;
        }
        
        // Finish status: always include 'Finished'. Optionally include lapped drivers
        const status = String(r.finish_status || "").trim();
        if (status !== 'Finished' && (excludeLapped || !(status === 'Lapped' || status === '+1 Lap'))) {
          console.log(`Excluding ${status} for ${r.lap_Driver} and ${r.year} ${r.round_no}`);
          return false;
        }
        
        // Rainfall
        if (excludeRainfall) {
          const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
          if (rainfall === "true" || rainfall === "1") return false;
        }
        
        // Safety car
        if (excludeSafetyCar) {
          const trackStatus = String(r.lap_TrackStatus || "");
          if (trackStatus.includes("4") || trackStatus.includes("5") || 
              trackStatus.includes("6") || trackStatus.includes("7")) {
            return false;
          }
        }
        
        // Pit laps
        if (excludePitLaps) {
          const pitIn = String(r.lap_PitInTime || "").trim();
          const pitOut = String(r.lap_PitOutTime || "").trim();
          if ((pitIn && pitIn.toLowerCase() !== "na" && pitIn !== "") ||
              (pitOut && pitOut.toLowerCase() !== "na" && pitOut !== "")) {
            return false;
          }
        }
        
        // Min distance
        const dist = parseFloat(r.min_dist);
        if (!isNaN(dist) && dist < minDist) return false;
        
        return true;
      });
    }

    function onCircuitChange() {
      const selectedCircuit = circuitSelect.value;
      eventsList.innerHTML = "";

      if (!selectedCircuit) {
        const placeholder = document.createElement("div");
        placeholder.className = "events-placeholder";
        placeholder.textContent = "Select a circuit to view events";
        eventsList.appendChild(placeholder);
        return;
      }

      const events = [];
      eventsByKey.forEach((val, key) => {
        if (val.circuit_name === selectedCircuit) {
          const label = `${val.year} - ${val.round_no}. ${val.meeting_name}`;
          events.push({
            key,
            label,
            year: val.year,
            round_no: val.round_no
          });
        }
      });

      events.sort((a, b) => {
        const ya = parseInt(a.year, 10) || 0;
        const yb = parseInt(b.year, 10) || 0;
        if (ya !== yb) return ya - yb;
        const ra = parseInt(a.round_no, 10) || 0;
        const rb = parseInt(b.round_no, 10) || 0;
        return ra - rb;
      });

      if (!events.length) {
        const placeholder = document.createElement("div");
        placeholder.className = "events-placeholder";
        placeholder.textContent = "No events found for this circuit";
        eventsList.appendChild(placeholder);
        return;
      }

      events.forEach(ev => {
        const wrapper = document.createElement("label");
        wrapper.className = "event-item";

        const checkbox = document.createElement("input");
        checkbox.type = "checkbox";
        checkbox.value = ev.key;
        checkbox.checked = true;
        checkbox.addEventListener("change", onEventSelectionChange);

        const tyreKey = `${ev.year}||${ev.round_no}`;
        const tyres = tyreChoices.get(tyreKey);
        let tyreInfo = "";
        if (tyres && tyres.hard && tyres.medium && tyres.soft) {
          tyreInfo = ` (${tyres.hard}-${tyres.medium}-${tyres.soft})`;
        }

        const text = document.createElement("span");
        text.className = "event-label-text";
        text.textContent = ev.label + tyreInfo;

        wrapper.appendChild(checkbox);
        wrapper.appendChild(text);
        eventsList.appendChild(wrapper);
      });

      onEventSelectionChange();
    }

    function onEventSelectionChange() {
      const checked = Array.from(
        eventsList.querySelectorAll("input[type='checkbox']:checked")
      ).map(cb => cb.value);

      if (!checked.length) {
        groupsTableContainer.innerHTML = "";
        return;
      }

      const selectedEvents = checked
        .map(key => eventsByKey.get(key))
        .filter(Boolean);

      const matchingRows = allRows.filter(r => {
        const rYear = String(r.year || "").trim();
        const rRound = String(r.round_no || "").trim();
        const rMeeting = String(r.meeting_name || "").trim();
        const rCircuit = String(r.circuit_name || "").trim();

        for (const ev of selectedEvents) {
          if (
            rYear === ev.year &&
            rRound === ev.round_no &&
            rMeeting === ev.meeting_name &&
            rCircuit === ev.circuit_name
          ) {
            return true;
          }
        }
        return false;
      });

      const filteredRows = applyFilters(matchingRows);
      displayGroupsTable(filteredRows);
    }

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();

      // F1 tire colors
      const colorMap = {
        'soft': '#FF0000',      // Red
        'medium': '#FFF200',    // Yellow
        'hard': '#FFFFFF',      // White
        'intermediate': '#00FF00', // Green
        'wet': '#0000FF'        // Blue
      };

      return colorMap[compoundLower] || '#999999'; // Default gray for unknown
    }

    function renderScatterPlot(filteredGroups, selectedStints) {
      // Get fuel effect value
      const fuelEffect = parseFloat(document.getElementById("fuelEffectSlider").value) || 0;

      // Prepare data for scatter plot
      const datasets = new Map(); // compound -> array of {x, y, label}

      // Use only selected stints if any are selected, otherwise use all
      const stintsToPlot = selectedStints && selectedStints.size > 0
        ? Array.from(selectedStints)
        : Array.from(filteredGroups.keys());

      stintsToPlot.forEach(key => {
        const group = filteredGroups.get(key);
        if (!group) return;
        const compound = getUniqueValue(group.rows, 'lap_Compound');
        // Use cached regression stats
        const stats = group.regressionStats;

        // Only include points with valid regression stats
        if (stats && stats.slope !== '-' && stats.slope !== 'error' &&
            stats.intercept !== '-' && stats.intercept !== 'error') {

          const deg = parseFloat(stats.slope);
          const pace = parseFloat(stats.intercept);

          // Apply fuel effect adjustments
          const minTyreLife = group.minTyreLife || 0;
          const lapsToGo = group.lapsToGo || 0;
          const degAdj = deg + fuelEffect;
          const paceAdj = pace - (minTyreLife + lapsToGo) * fuelEffect;

          if (!isNaN(paceAdj) && !isNaN(degAdj)) {
            if (!datasets.has(compound)) {
              datasets.set(compound, []);
            }

            datasets.get(compound).push({
              x: paceAdj,
              y: degAdj,
              label: `${group.lap_Driver} - ${group.event}`
            });
          }
        }
      });

      // Store regression equations for display
      const regressionEquations = new Map();

      // Convert to ECharts format
      const series = [];
      datasets.forEach((points, compound) => {
        const color = getF1TireColor(compound);

        // Convert points to ECharts format
        const scatterData = points.map(p => ({
          value: [p.x, p.y],
          label: p.label
        }));

        // Add scatter series
        series.push({
          name: compound,
          type: 'scatter',
          data: scatterData,
          symbolSize: 8,
          itemStyle: {
            color: color,
            borderColor: color,
            borderWidth: 0
          },
          emphasis: { focus: 'series', blurScope: 'global', itemStyle: { borderWidth: 2, shadowBlur: 10, shadowColor: color } },
          blur: { itemStyle: { opacity: 0.3 } }
        });

        // Calculate regression line for this compound (deg vs pace)
        const xValues = points.map(p => p.x);
        const yValues = points.map(p => p.y);

        if (points.length >= 2) {
          try {
            // Create data array for simple-statistics
            const regressionData = points.map(p => [p.x, p.y]);
            const regression = ss.linearRegression(regressionData);

            // Calculate R² for this regression
            const correlation = ss.sampleCorrelation(xValues, yValues);
            const rSquared = correlation * correlation;

            // Store equation for display
            regressionEquations.set(compound, {
              slope: regression.m,
              intercept: regression.b,
              rSquared: rSquared,
              n: points.length,
              color: color
            });

            // Calculate min and max x values for the line
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);

            // Create two points for the regression line
            const lineData = [
              [minX, regression.m * minX + regression.b],
              [maxX, regression.m * maxX + regression.b]
            ];

            // Add regression line series
            series.push({
              name: `${compound} trend`,
              type: 'line',
              data: lineData,
              showSymbol: false,
              lineStyle: {
                color: color,
                width: 2,
                type: 'dashed'
              },
              emphasis: { disabled: true },
              silent: true,
              zlevel: -1
            });
          } catch (error) {
            console.error(`Error calculating regression for ${compound}:`, error);
          }
        }
      });

      // Show chart container if we have data
      if (series.length > 0) {
        chartsWrapper.style.display = 'grid';

        // Initialize ECharts instance if not already created (after showing container)
        if (!scatterChart) {
          scatterChart = echarts.init(scatterChartContainer);
        }

        scatterChart.setOption({
          backgroundColor: 'transparent',
          grid: { left: 60, right: 20, top: 50, bottom: 60 },
          legend: {
            show: true,
            top: 5,
            textStyle: { color: '#f5f5f5', fontSize: 11 },
            itemWidth: 12,
            itemHeight: 12,
            selector: false,
            data: Array.from(datasets.keys()) // Only show compound names, not trend lines
          },
          tooltip: {
            show: true,
            trigger: 'item',
            confine: true,
            borderColor: '#2a2f3a',
            backgroundColor: 'rgba(26,29,36,0.96)',
            textStyle: { color: '#e8e8e8' },
            extraCssText: 'padding:10px 12px;border-radius:10px',
            formatter: (p) => {
              if (p.seriesType === 'scatter') {
                const data = p.data;
                return `
                  <strong>${data.label}</strong><br/>
                  Pace: ${data.value[0].toFixed(4)}<br/>
                  Deg: ${data.value[1].toFixed(4)}
                `;
              }
              return '';
            }
          },
          xAxis: {
            type: 'value',
            scale: true,
            name: 'Pace',
            nameLocation: 'middle',
            nameGap: 30,
            nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
            axisLine: { lineStyle: { color: '#9ca3af' } },
            axisLabel: { color: '#9ca3af' },
            splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
          },
          yAxis: {
            type: 'value',
            scale: true,
            name: 'Deg',
            nameLocation: 'middle',
            nameGap: 45,
            nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
            axisLine: { lineStyle: { color: '#9ca3af' } },
            axisLabel: { color: '#9ca3af' },
            splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
          },
          series: series
        }, true);

        // Resize chart to ensure it fills the container properly
        scatterChart.resize();

        // Display regression equations
        if (regressionEquations.size > 0) {
          equationsSection.style.display = 'block';
          equationsGrid.innerHTML = '';

          regressionEquations.forEach((eq, compound) => {
            const equationDiv = document.createElement('div');
            equationDiv.className = 'equation-item';
            equationDiv.style.borderLeftColor = eq.color;

            const slopeStr = eq.slope >= 0 ? `+${eq.slope.toFixed(4)}` : eq.slope.toFixed(4);
            const interceptStr = eq.intercept >= 0 ? `+${eq.intercept.toFixed(4)}` : eq.intercept.toFixed(4);

            equationDiv.innerHTML = `
              <strong>${compound}:</strong> Deg = ${slopeStr} × Pace ${interceptStr}
              (R² = ${eq.rSquared.toFixed(3)}, n = ${eq.n})
            `;

            equationsGrid.appendChild(equationDiv);
          });
        } else {
          equationsSection.style.display = 'none';
        }
      } else {
        chartsWrapper.style.display = 'none';
        equationsSection.style.display = 'none';
      }
    }

    function updateLapTimeChart(filteredGroups) {
      // Update selected stint count
      selectedStintCount.textContent = selectedStints.size === 0 ?
        'No stints selected' :
        `${selectedStints.size} stint${selectedStints.size > 1 ? 's' : ''} selected`;

      // Initialize ECharts instance if not already created
      if (!lapTimeChart) {
        lapTimeChart = echarts.init(lapTimeChartContainer);
      }

      if (selectedStints.size === 0) {
        lapTimeChart.clear();
        return;
      }

      const fuelAdjusted = fuelAdjustToggle.classList.contains('active');
      const fuelEffect = parseFloat(document.getElementById("fuelEffectSlider").value) || 0;

      // Create ECharts series - one per stint
      const series = [];

      selectedStints.forEach(key => {
        const group = filteredGroups.get(key);
        if (!group) return;

        const compound = getUniqueValue(group.rows, 'lap_Compound');
        const color = getF1TireColor(compound);

        const data = [];

        // Extract lap time and tyre life data for this stint
        group.rows.forEach(r => {
          const tyreLife = parseFloat(r.lap_TyreLife);
          let lapTime = parseFloat(r.lap_LapTime);

          if (!isNaN(tyreLife) && !isNaN(lapTime) && lapTime > 0) {
            // Apply fuel adjustment if enabled
            if (fuelAdjusted) {
              const lapNumber = parseFloat(r.lap_LapNumber);
              const schedLaps = parseInt(getUniqueValue(group.rows, 'sched_laps'));
              if (!isNaN(lapNumber) && !isNaN(schedLaps)) {
                const lapsRemaining = schedLaps - lapNumber;
                lapTime = lapTime - lapsRemaining * fuelEffect;
              }
            }

            data.push({
              value: [tyreLife, lapTime],
              driver: group.lap_Driver,
              event: group.event,
              stint: group.lap_Stint,
              compound: compound
            });
          }
        });

        // Sort by tyre life for proper line connection
        data.sort((a, b) => a.value[0] - b.value[0]);

        // Create a series for this stint
        series.push({
          name: `${group.lap_Driver} - ${compound} - Stint ${group.lap_Stint}`,
          type: 'line',
          data: data,
          showSymbol: true,
          symbol: 'circle',
          symbolSize: 4,
          itemStyle: { borderWidth: 0 },
          color: color,
          lineStyle: { width: 2, opacity: 0.95, color: color },
          emphasis: { focus: 'series', blurScope: 'global', lineStyle: { width: 3.2 } },
          blur: { lineStyle: { opacity: 0.5 } },
          animation: false
        });
      });

      lapTimeChart.setOption({
        backgroundColor: 'transparent',
        grid: { left: 60, right: 20, top: 20, bottom: 60 },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const data = p.data;
            const tyreLife = data.value[0];
            const lapTime = data.value[1];
            return `
              <strong>${data.driver} - ${data.event}</strong><br/>
              ${data.compound} - Stint ${data.stint}<br/>
              Tyre Life: ${tyreLife.toFixed(0)} laps<br/>
              Lap Time: ${lapTime.toFixed(3)}s
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Tyre Life (laps)',
          nameLocation: 'middle',
          nameGap: 30,
          scale: true,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        yAxis: {
          type: 'value',
          scale: true,
          name: 'Lap Time (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        series: series
      }, true);
    }

    // Set up document-level click listener for closing dropdowns (only once)
    document.addEventListener('click', function(e) {
      if (activeDropdown && !e.target.closest('.clickable-header') && !e.target.closest('.header-dropdown')) {
        activeDropdown.remove();
        activeDropdown = null;
        activeDropdownColumn = null;
      }
    });

    function attachHeaderDropdownListeners(filteredGroups) {
      // Attach click listeners to clickable headers
      document.querySelectorAll('.clickable-header').forEach(header => {
        // Remove any existing listeners by cloning and replacing
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);

        newHeader.addEventListener('click', function(e) {
          e.stopPropagation();

          const column = this.dataset.column;

          // Toggle: if clicking same header, close dropdown
          if (activeDropdown && activeDropdownColumn === column) {
            activeDropdown.remove();
            activeDropdown = null;
            activeDropdownColumn = null;
            return;
          }

          // Close any existing dropdown
          if (activeDropdown) {
            activeDropdown.remove();
            activeDropdown = null;
          }

          const table = this.closest('table');
          const tableRect = table.getBoundingClientRect();
          const headerRect = this.getBoundingClientRect();

          // Get unique values for this column
          const uniqueValues = new Set();
          filteredGroups.forEach(group => {
            if (column === 'driver') {
              uniqueValues.add(group.lap_Driver);
            } else if (column === 'compound') {
              const compound = getUniqueValue(group.rows, 'lap_Compound');
              uniqueValues.add(compound);
            }
          });

          // Create dropdown
          const dropdown = document.createElement('div');
          dropdown.className = 'header-dropdown show';

          // Position relative to the header, using absolute positioning within the table
          dropdown.style.left = `${headerRect.left - tableRect.left}px`;
          dropdown.style.top = `${headerRect.bottom - tableRect.top}px`;

          // Add options
          Array.from(uniqueValues).sort().forEach(value => {
            const option = document.createElement('div');
            option.className = 'dropdown-option';

            const label = document.createElement('span');
            label.className = 'dropdown-option-label';
            label.textContent = value;

            const buttons = document.createElement('div');
            buttons.className = 'dropdown-option-buttons';

            const selectBtn = document.createElement('button');
            selectBtn.className = 'dropdown-btn';
            selectBtn.textContent = 'Select';
            selectBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              selectByValue(column, value, filteredGroups, true);
            });

            const deselectBtn = document.createElement('button');
            deselectBtn.className = 'dropdown-btn';
            deselectBtn.textContent = 'Clear';
            deselectBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              selectByValue(column, value, filteredGroups, false);
            });

            buttons.appendChild(selectBtn);
            buttons.appendChild(deselectBtn);

            option.appendChild(label);
            option.appendChild(buttons);
            dropdown.appendChild(option);
          });

          table.appendChild(dropdown);
          activeDropdown = dropdown;
          activeDropdownColumn = column;
        });
      });
    }

    function selectByValue(column, value, filteredGroups, select) {
      filteredGroups.forEach((group, key) => {
        let matches = false;

        if (column === 'driver' && group.lap_Driver === value) {
          matches = true;
        } else if (column === 'compound') {
          const compound = getUniqueValue(group.rows, 'lap_Compound');
          if (compound === value) matches = true;
        }

        if (matches) {
          if (select) {
            selectedStints.add(key);
          } else {
            selectedStints.delete(key);
          }
        }
      });

      // Close the dropdown
      if (activeDropdown) {
        activeDropdown.remove();
        activeDropdown = null;
        activeDropdownColumn = null;
      }

      // Refresh table to update checkboxes
      onEventSelectionChange();
    }

    function calculateRegressionStats(rows) {
      // Extract lap_TyreLife (X) and lap_LapTime (Y) data
      const data = [];

      rows.forEach(r => {
        const tyreLife = parseFloat(r.lap_TyreLife);
        const lapTime = parseFloat(r.lap_LapTime);

        // Only include valid numeric values
        if (!isNaN(tyreLife) && !isNaN(lapTime) && lapTime > 0) {
          data.push([tyreLife, lapTime]);
        }
      });

      // Need at least 2 points for regression
      if (data.length < 2) {
        return {
          slope: '-',
          intercept: '-',
          correlation: '-',
          rmse: '-'
        };
      }

      try {
        // Calculate linear regression using simple-statistics
        const regression = ss.linearRegression(data);
        const slope = regression.m;
        const intercept = regression.b;

        // Calculate correlation
        const xValues = data.map(d => d[0]);
        const yValues = data.map(d => d[1]);
        const correlation = ss.sampleCorrelation(xValues, yValues);

        // Calculate RMSE
        let sumSquaredErrors = 0;
        data.forEach(([x, y]) => {
          const predicted = slope * x + intercept;
          const error = y - predicted;
          sumSquaredErrors += error * error;
        });
        const rmse = Math.sqrt(sumSquaredErrors / data.length);

        // Format with fixed decimals
        return {
          slope: slope.toFixed(4),
          intercept: intercept.toFixed(4),
          correlation: correlation.toFixed(4),
          rmse: rmse.toFixed(4)
        };
      } catch (error) {
        console.error('Error calculating regression:', error);
        return {
          slope: 'error',
          intercept: 'error',
          correlation: 'error',
          rmse: 'error'
        };
      }
    }

    function displayGroupsTable(rows) {
      if (!rows.length) {
        groupsTableContainer.innerHTML = "";
        chartsWrapper.style.display = 'none';
        equationsSection.style.display = 'none';
        if (scatterChart) {
          scatterChart.destroy();
          scatterChart = null;
        }
        if (lapTimeChart) {
          lapTimeChart.destroy();
          lapTimeChart = null;
        }
        return;
      }

      // Group by year, round_no, meeting_name, lap_Driver, session_type, lap_Stint
      const groups = new Map();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const driver = String(r.lap_Driver || "").trim();
        const session = String(r.session_type || "").trim();
        const stint = String(r.lap_Stint || "").trim();
        const key = `${year}||${round}||${meeting}||${driver}||${session}||${stint}`;

        if (!groups.has(key)) {
          groups.set(key, {
            event: `${year} - ${round}. ${meeting}`,
            lap_Driver: driver,
            session_type: session,
            lap_Stint: stint,
            rows: []
          });
        }
        groups.get(key).rows.push(r);
      });

      // Apply minimum rows filter
      const minRows = parseInt(document.getElementById("filterMinRows").value) || 7;
      const minCorr = parseFloat(document.getElementById("filterMinCorr").value);
      const minCorrValue = isNaN(minCorr) ? 0.5 : minCorr;

      const filteredGroups = new Map();
      groups.forEach((group, key) => {
        if (group.rows.length >= minRows) {
          // Calculate regression stats to check correlation
          const stats = calculateRegressionStats(group.rows);

          // Apply correlation filter
          if (stats.correlation !== '-' && stats.correlation !== 'error') {
            const correlation = parseFloat(stats.correlation);
            if (!isNaN(correlation) && correlation >= minCorrValue) {
              // Calculate min_tyre_life and laps_to_go
              const tyreLifeValues = group.rows.map(r => parseFloat(r.lap_TyreLife)).filter(v => !isNaN(v));
              const lapNumberValues = group.rows.map(r => parseFloat(r.lap_LapNumber)).filter(v => !isNaN(v));
              const schedLapsValue = parseInt(getUniqueValue(group.rows, 'sched_laps'));

              const minTyreLife = tyreLifeValues.length > 0 ? Math.min(...tyreLifeValues) : 0;
              const minLapNum = lapNumberValues.length > 0 ? Math.min(...lapNumberValues) : 0;
              const lapsToGo = !isNaN(schedLapsValue) && schedLapsValue > 0 ? schedLapsValue - minLapNum : 0;

              // Store stats and calculated values with group to avoid recalculating later
              group.regressionStats = stats;
              group.minTyreLife = minTyreLife;
              group.lapsToGo = lapsToGo;
              filteredGroups.set(key, group);
            }
          }
        }
      });

      // Select all stints by default on first load
      const isFirstLoad = selectedStints.size === 0;
      if (isFirstLoad) {
        filteredGroups.forEach((group, key) => {
          selectedStints.add(key);
        });
      }

      // Render scatter plot with selected stints only (or all if none selected)
      renderScatterPlot(filteredGroups, selectedStints);

      // Build table
      let html = `
        <table class="groups-table">
          <thead>
            <tr>
              <th><input type="checkbox" id="selectAllCheckbox" class="stint-checkbox"></th>
              <th>Event</th>
              <th class="clickable-header" data-column="driver">Driver</th>
              <th>Session Type</th>
              <th>Stint</th>
              <th>Lap Count</th>
              <th>Sched Laps</th>
              <th class="clickable-header" data-column="compound">Compound</th>
              <th>Finish Status</th>
              <th>Min Tyre Life</th>
              <th>Laps to Go</th>
              <th>Deg</th>
              <th>Pace</th>
              <th>Correlation</th>
              <th>RMSE</th>
            </tr>
          </thead>
          <tbody>
      `;

      // Get fuel effect value
      const fuelEffect = parseFloat(document.getElementById("fuelEffectSlider").value) || 0;

      // Sort groups by compound, driver, session type, stint
      const sortedGroups = Array.from(filteredGroups.entries()).sort((a, b) => {
        const [keyA, groupA] = a;
        const [keyB, groupB] = b;

        const compoundA = getUniqueValue(groupA.rows, 'lap_Compound');
        const compoundB = getUniqueValue(groupB.rows, 'lap_Compound');
        if (compoundA !== compoundB) return compoundA.localeCompare(compoundB);

        if (groupA.lap_Driver !== groupB.lap_Driver) {
          return groupA.lap_Driver.localeCompare(groupB.lap_Driver);
        }

        if (groupA.session_type !== groupB.session_type) {
          return groupA.session_type.localeCompare(groupB.session_type);
        }

        return groupA.lap_Stint.localeCompare(groupB.lap_Stint);
      });

      sortedGroups.forEach(([key, group]) => {
        const schedLaps = getUniqueValue(group.rows, 'sched_laps');
        const compound = getUniqueValue(group.rows, 'lap_Compound');
        const finishStatus = getUniqueValue(group.rows, 'finish_status');

        // Use cached regression stats and calculated values
        const regressionStats = group.regressionStats;
        const minTyreLife = group.minTyreLife;
        const lapsToGo = group.lapsToGo;

        // Apply fuel effect adjustments
        const deg = parseFloat(regressionStats.slope);
        const pace = parseFloat(regressionStats.intercept);
        const degAdj = deg + fuelEffect;
        const paceAdj = pace - (minTyreLife + lapsToGo) * fuelEffect;

        const isChecked = selectedStints.has(key) ? 'checked' : '';

        html += `
          <tr data-stint-key="${key}">
            <td><input type="checkbox" class="stint-checkbox" data-stint-key="${key}" ${isChecked}></td>
            <td>${escapeHtml(group.event)}</td>
            <td>${escapeHtml(group.lap_Driver)}</td>
            <td>${escapeHtml(group.session_type)}</td>
            <td>${escapeHtml(group.lap_Stint)}</td>
            <td>${group.rows.length}</td>
            <td${schedLaps === 'error' ? ' class="error-cell"' : ''}>${escapeHtml(schedLaps)}</td>
            <td${compound === 'error' ? ' class="error-cell"' : ''}>${escapeHtml(compound)}</td>
            <td${finishStatus === 'error' ? ' class="error-cell"' : ''}>${escapeHtml(finishStatus)}</td>
            <td>${minTyreLife.toFixed(0)}</td>
            <td>${lapsToGo.toFixed(0)}</td>
            <td>${degAdj.toFixed(4)}</td>
            <td>${paceAdj.toFixed(4)}</td>
            <td>${regressionStats.correlation}</td>
            <td>${regressionStats.rmse}</td>
          </tr>
        `;
      });

      html += `
          </tbody>
        </table>
      `;

      groupsTableContainer.innerHTML = html;

      // Attach checkbox event listeners
      document.querySelectorAll('.stint-checkbox').forEach(checkbox => {
        checkbox.addEventListener('change', function() {
          const key = this.dataset.stintKey;
          if (key) {
            if (this.checked) {
              selectedStints.add(key);
            } else {
              selectedStints.delete(key);
            }
            updateLapTimeChart(filteredGroups);
            renderScatterPlot(filteredGroups, selectedStints);
          }
        });
      });

      // Attach select all checkbox listener
      const selectAllCheckbox = document.getElementById('selectAllCheckbox');
      if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', function() {
          if (this.checked) {
            // Select all visible stints
            filteredGroups.forEach((group, key) => {
              selectedStints.add(key);
            });
          } else {
            // Deselect all visible stints (not all stints globally)
            filteredGroups.forEach((group, key) => {
              selectedStints.delete(key);
            });
          }
          // Update individual checkboxes without rebuilding entire table
          document.querySelectorAll('.stint-checkbox').forEach(checkbox => {
            const key = checkbox.dataset.stintKey;
            if (key) {
              checkbox.checked = selectedStints.has(key);
            }
          });
          // Update the charts
          renderScatterPlot(filteredGroups, selectedStints);
          updateLapTimeChart(filteredGroups);
        });

        // Update select all checkbox state based on currently visible stints
        let visibleSelectedCount = 0;
        filteredGroups.forEach((group, key) => {
          if (selectedStints.has(key)) visibleSelectedCount++;
        });

        selectAllCheckbox.checked = filteredGroups.size > 0 &&
          visibleSelectedCount === filteredGroups.size;
        selectAllCheckbox.indeterminate = visibleSelectedCount > 0 &&
          visibleSelectedCount < filteredGroups.size;
      }

      // Attach clickable header listeners
      attachHeaderDropdownListeners(filteredGroups);

      // Store filtered groups globally for lap time chart
      window.currentFilteredGroups = filteredGroups;

      // Update lap time chart
      updateLapTimeChart(filteredGroups);
    }

    function getUniqueValue(rows, column) {
      const values = new Set();
      rows.forEach(r => {
        const val = String(r[column] || "").trim();
        values.add(val);
      });
      
      if (values.size === 1) {
        return Array.from(values)[0];
      }
      return 'error';
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }
  </script>
</body>
</html>