<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>F1 Race Analysis</title>
  <link rel="stylesheet" href="common.css">
  <style>
    /* Page-specific styles */
    .page-content {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 16px 16px;
    }

    .container {
      max-width: 1400px;
      width: 100%;
    }

    /* Tab Navigation */
    .tab-navigation {
      display: flex;
      gap: 8px;
      margin-bottom: 16px;
      align-items: center;
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      border-radius: 12px;
      border: 1px solid var(--border-color);
    }

    .tab-button {
      padding: 10px 20px;
      background: transparent;
      border: none;
      border-radius: 8px;
      color: var(--muted-color);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      position: relative;
    }

    .tab-button:hover {
      color: var(--text-color);
      background: rgba(255, 255, 255, 0.05);
      transform: translateY(-1px);
    }

    .tab-button[data-tooltip]::after {
      content: attr(data-tooltip);
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%) translateY(8px);
      padding: 10px 14px;
      background: rgba(26, 29, 36, 0.96);
      color: var(--text-color);
      border: 1px solid var(--accent-color);
      font-size: 11px;
      font-weight: 500;
      border-radius: 8px;
      width: 350px;
      white-space: normal;
      line-height: 1.4;
      opacity: 0;
      pointer-events: none;
      transition: opacity 0.15s ease, transform 0.15s ease;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .tab-button[data-tooltip]:hover::after {
      opacity: 1;
      transform: translateX(-50%) translateY(4px);
      transition-delay: 0.3s;
    }

    .tab-button.active {
      color: #fff;
      background: linear-gradient(135deg, rgba(0, 224, 255, 0.15), rgba(0, 180, 255, 0.1));
      box-shadow: 0 0 20px rgba(0, 224, 255, 0.3), inset 0 0 10px rgba(0, 224, 255, 0.1);
      border: 1px solid rgba(0, 224, 255, 0.3);
    }

    .tab-navigation .status-message {
      margin-left: auto;
      font-size: 12px;
      color: var(--muted-color);
      padding: 0 12px;
    }

    .tab-navigation #reloadDataBtn,
    .tab-navigation #spoilerModeBtn {
      padding: 8px 16px;
      font-size: 12px;
      border-radius: 8px;
    }

    /* Session Selector */
    .session-selector {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .small {
      color: var(--muted-color);
      font-size: 12px;
    }

    select {
      min-width: 160px;
      width: auto;
    }

    #sessionSel {
      min-width: 120px;
    }

    /* Content Panels */
    .content-panel {
      display: none;
    }

    .content-panel.active {
      display: block;
    }

    /* ========================================================================
       STRATEGY PANEL STYLES
       ======================================================================== */

    #strategy-panel {
      display: flex;
      justify-content: center;
    }

    .strategy-container {
      max-width: 900px;
      width: 100%;
      margin-top: 20px;
      padding: 20px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      display: none;
    }

    .strategy-container.show {
      display: block;
    }

    .driver-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      position: relative;
    }

    .driver-label {
      width: 80px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-color);
      text-align: right;
      padding-right: 12px;
      flex-shrink: 0;
    }

    .strategy-bar {
      flex: 1;
      height: 24px;
      display: flex;
      position: relative;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      overflow: hidden;
    }

    .stint-segment {
      height: 100%;
      position: relative;
      border-right: 3px solid #000;
      box-shadow: 2px 0 0 rgba(0, 0, 0, 0.8);
    }

    .stint-segment:last-child {
      border-right: none;
      box-shadow: none;
    }

    .missing-laps {
      height: 100%;
      background: repeating-linear-gradient(
        45deg,
        #333,
        #333 4px,
        #222 4px,
        #222 8px
      );
      opacity: 0.5;
    }

    .lap-axis {
      display: flex;
      align-items: center;
      position: relative;
    }

    .lap-axis.top {
      margin-bottom: 8px;
    }

    .lap-axis.bottom {
      margin-top: 16px;
    }

    .lap-axis-spacer {
      width: 80px;
      flex-shrink: 0;
    }

    .lap-axis-track {
      flex: 1;
      height: 30px;
      position: relative;
      border-top: 1px solid var(--border-color);
    }

    .lap-axis.bottom .lap-axis-track {
      border-top: 1px solid var(--border-color);
      border-bottom: none;
    }

    .lap-axis.top .lap-axis-track {
      border-top: none;
      border-bottom: 1px solid var(--border-color);
    }

    .lap-tick {
      position: absolute;
      width: 1px;
      background: var(--muted-color);
    }

    .lap-axis.bottom .lap-tick {
      top: 0;
      height: 8px;
    }

    .lap-axis.top .lap-tick {
      bottom: 0;
      height: 8px;
    }

    .lap-label {
      position: absolute;
      font-size: 10px;
      color: var(--muted-color);
      transform: translateX(-50%);
    }

    .lap-axis.bottom .lap-label {
      top: 10px;
    }

    .lap-axis.top .lap-label {
      bottom: 10px;
    }

    .tooltip {
      position: absolute;
      background: rgba(26, 29, 36, 0.96);
      border: 1px solid var(--accent-color);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 11px;
      color: var(--text-color);
      pointer-events: none;
      z-index: 1000;
      display: none;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .tooltip.show {
      display: block;
    }

    /* Hide the common.js navigation since we have our own tabs */
    nav {
      display: none !important;
    }

    /* ========================================================================
       RACE TRACE PANEL STYLES
       ======================================================================== */

    .race-trace-controls {
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid var(--border-color);
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .race-trace-controls-row {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      align-items: center;
    }

    .race-trace-controls-box {
      display: flex;
      gap: 8px;
      padding: 10px 14px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      align-items: center;
    }

    .race-trace-controls input[type="number"] {
      width: 90px;
    }

    .race-trace-controls-box input[type="number"] {
      width: 90px;
    }

    .race-trace-layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 600px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .race-trace-sidebar {
      background: rgba(0, 224, 255, 0.03);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
    }

    .race-trace-sidebar .section {
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .race-trace-sidebar .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    #raceTraceDriverList {
      padding: 10px;
      overflow: auto;
    }

    .race-trace-driver {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.2s;
    }

    .race-trace-driver:hover {
      background: rgba(0, 224, 255, 0.1);
    }

    .race-trace-driver input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .race-trace-driver label {
      cursor: pointer;
      flex: 1;
    }

    #raceTraceChart {
      width: 100%;
      height: 100%;
      min-height: 600px;
    }

    .race-trace-debug-info {
      padding: 20px;
      color: var(--text-color);
      font-size: 14px;
    }

    /* ========================================================================
       LAP TIME PANEL STYLES
       ======================================================================== */

    .lap-time-layout {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
    }

    .lap-time-sidebar {
      width: 200px;
      padding: 12px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      max-height: 610px;
      overflow-y: auto;
    }

    .lap-time-chart-wrapper {
      flex: 1;
    }

    .lap-time-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
      justify-content: space-between;
    }

    .lap-time-controls-left {
      display: flex;
      gap: 8px;
    }

    .toggle-button {
      padding: 4px 12px;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .toggle-button.active {
      background: var(--accent-color);
      color: #000;
      border-color: var(--accent-color);
    }

    .toggle-button:hover {
      border-color: var(--accent-color);
    }

    .copy-data-button {
      padding: 8px 16px;
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid var(--border-color);
      border-radius: 6px;
      color: var(--text-color);
      font-size: 13px;
      font-weight: 500;
      cursor: pointer;
      transition: all 0.2s ease;
    }

    .copy-data-button:hover {
      background: rgba(255, 255, 255, 0.1);
      border-color: var(--primary-color);
      color: var(--primary-color);
    }

    .copy-data-button:active {
      transform: scale(0.98);
    }

    #lapTimeChart {
      width: 100%;
      height: 610px;
    }

    .lap-time-filters {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
    }

    .filter-panel {
      padding: 16px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .filters-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .drivers-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .filters-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .filter-item {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .filter-item.vertical {
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
    }

    .filter-label {
      font-size: 10px;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    .filter-item input[type="number"] {
      width: 100px;
    }

    .exclude-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .checkbox-group label {
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
    }

    .lap-time-driver-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.2s;
    }

    .lap-time-driver-item:hover {
      background: rgba(0, 224, 255, 0.1);
    }

    .lap-time-driver-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .lap-time-driver-item label {
      cursor: pointer;
      flex: 1;
    }

    /* ========================================================================
       TYRE DEGRADATION PANEL STYLES
       ======================================================================== */

    .tyre-choices-display {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
      padding: 10px 14px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      font-size: 14px;
    }

    .tyre-choices-label {
      font-weight: 600;
      color: var(--accent-color);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #tyreDegTyreChoicesText {
      color: var(--text-color);
      font-size: 12px;
    }

    .tyre-deg-charts-wrapper {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .tyre-deg-chart-container {
      padding: 20px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .chart-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #tyreDegScatterChart, #tyreDegLapTimeChart {
      width: 100%;
      height: 400px;
    }

    .tyre-deg-chart-controls {
      margin-bottom: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .equations-section {
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(0, 224, 255, 0.05);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 253, 0.15);
    }

    .equations-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .equations-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 8px;
    }

    .equation-item {
      font-size: 11px;
      color: var(--text-color);
      font-family: 'Courier New', monospace;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      border-left: 3px solid;
    }

    .tyre-deg-filters {
      display: grid;
      grid-template-columns: 1.5fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-value {
      font-size: 11px;
      color: var(--accent-color);
      font-weight: 600;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--border-color);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      box-shadow: 0 0 8px var(--accent-soft);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px var(--accent-soft);
    }

    .stint-checkbox {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    #tyreDegStintsTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-top: 16px;
    }

    #tyreDegStintsTable th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: rgba(0, 224, 255, 0.1);
      color: var(--accent-color);
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 10px;
      border: 1px solid var(--border-color);
      cursor: pointer;
      user-select: none;
    }

    #tyreDegStintsTable th:hover {
      color: #fff;
    }

    #tyreDegStintsTable td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    #tyreDegStintsTable tr:hover {
      background: rgba(0, 224, 255, 0.05);
    }

    .stint-selected {
      background: rgba(0, 224, 255, 0.15) !important;
    }

    .clickable-header {
      cursor: pointer;
      user-select: none;
      position: relative;
    }

    .clickable-header::after {
      content: " ▾";
      font-size: 10px;
      opacity: 0.6;
    }

    .header-dropdown {
      position: absolute;
      background: #0a0c14;
      border: 1px solid var(--accent-color);
      border-radius: 8px;
      padding: 8px;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8), 0 0 16px var(--accent-soft);
      z-index: 1000;
      display: none;
    }

    #tyreDegStintsTable {
      position: relative;
    }

    #fuelEffectGroupsTable {
      position: relative;
    }

    #lapTimeSummaryTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-top: 16px;
    }

    #lapTimeSummaryTable th {
      background: rgba(0, 224, 255, 0.1);
      color: var(--accent-color);
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 10px;
      border: 1px solid var(--border-color);
    }

    #lapTimeSummaryTable th:first-child {
      text-align: left;
    }

    #lapTimeSummaryTable th:not(:first-child) {
      text-align: center;
    }

    #lapTimeSummaryTable td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    #lapTimeSummaryTable tr:hover {
      background: rgba(0, 224, 255, 0.05);
    }

    #lapTimeSummaryTable tbody tr:first-child {
      background: rgba(0, 224, 255, 0.15);
    }

    #lapTimeSummaryTable tbody tr:first-child:hover {
      background: rgba(0, 224, 255, 0.2);
    }

    .pit-loss-header {
      display: flex;
      justify-content: center; /* center the inner container so it lines up with the table */
      margin-bottom: 12px;
    }

    /* inner container sized to match the table's max-width so header items align */
    .pit-loss-header .pit-loss-inner {
      width: 100%;
      max-width: 760px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      gap: 12px;
    }

    .pit-loss-header .pit-loss-stats {
      display: flex;
      gap: 14px;
      align-items: center;
    }

    .pit-loss-stat {
      display: flex;
      gap: 8px;
      align-items: baseline;
      font-size: 13px;
      color: var(--muted-color);
    }

    .pit-loss-stat .label {
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: var(--muted-color);
      margin-right: 6px;
    }

    .pit-loss-stat .value {
      font-size: 18px;
      font-weight: 700;
      color: var(--accent-color);
      text-shadow: 0 0 10px rgba(0, 224, 255, 0.25);
    }

    .pit-loss-table {
      width: 100%;
      max-width: 760px; /* keep the table narrower than the panel */
      table-layout: fixed;
      border-collapse: collapse;
      margin: 12px auto 0 auto;
      font-size: 13px;
      background: rgba(0,0,0,0.02);
      border-radius: 8px;
      overflow: hidden;
    }

    .pit-loss-table th,
    .pit-loss-table td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      text-align: left;
      vertical-align: middle;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    /* Make header narrower and more compact */
    .pit-loss-table th {
      background: rgba(0, 224, 255, 0.04);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.06em;
      font-weight: 700;
      color: var(--accent-color);
    }

    /* Column width hints */
    .pit-loss-table th:nth-child(1) { width: 56px; }
    .pit-loss-table th:nth-child(2) { width: 180px; }
    .pit-loss-table th:nth-child(3) { width: 64px; }
    .pit-loss-table th:nth-child(4) { width: 96px; }

    /* On small screens let the table expand to full width */
    @media (max-width: 820px) {
      .pit-loss-table { max-width: 100%; margin: 12px 0 0 0; }
      .pit-loss-table th:nth-child(2) { width: 140px; }
      .pit-loss-table th:nth-child(4) { width: 90px; }
    }

    .pit-loss-checkbox {
      margin-right: 8px;
    }
    .pit-loss-table tbody tr.selected {
      background: rgba(0, 224, 255, 0.06);
    }

    .header-dropdown.show {
      display: block;
    }

    .dropdown-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      font-size: 11px;
      color: var(--text-color);
      border-bottom: 1px solid rgba(148, 163, 253, 0.1);
    }

    .dropdown-option:last-child {
      border-bottom: none;
    }

    .dropdown-option-label {
      flex: 1;
    }

    .dropdown-option-buttons {
      display: flex;
      gap: 4px;
    }

    .dropdown-btn {
      padding: 2px 8px;
      font-size: 9px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .dropdown-btn:hover {
      border-color: var(--accent-color);
      background: rgba(0, 224, 255, 0.15);
    }

    /* ========================================================================
       FUEL EFFECT PANEL STYLES
       ======================================================================== */

    .groups-table {
      margin-top: 20px;
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .groups-table th {
      position: sticky;
      top: 0;
      z-index: 1;
      background: rgba(0, 224, 255, 0.1);
      color: var(--accent-color);
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 10px;
      border: 1px solid var(--border-color);
    }

    .groups-table td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    .groups-table tr:hover {
      background: rgba(0, 224, 255, 0.05);
    }

    .groups-table td:last-child {
      max-width: 600px;
      word-wrap: break-word;
      white-space: normal;
    }

    /* ========================================================================
       CALCULATOR PANEL STYLES
       ======================================================================== */

    .calculator-layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
    }

    .calculator-left-pane,
    .calculator-right-pane {
      min-width: 0;
    }

    .calculator-left-pane {
      flex: 0 0 42%;
      max-height: calc(100vh - 180px);
      overflow-y: auto;
      padding-right: 4px;
    }

    .calculator-right-pane {
      flex: 1 1 58%;
      max-height: calc(100vh - 180px);
      overflow-y: auto;
      padding-left: 4px;
    }

    .calculator-section {
      background: rgba(0, 224, 255, 0.03);
      border: 1px solid var(--border-color);
      border-radius: var(--radius-lg);
      padding: 12px 14px 14px;
      margin-bottom: 12px;
    }

    .calculator-section-header {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .calculator-section-header h2 {
      margin: 0;
      font-size: 1.1rem;
      font-weight: 500;
    }

    .calculator-inputs-actions {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 12px;
    }

    .calculator-small-note {
      font-size: 0.8rem;
      color: var(--muted-color);
      margin-bottom: 0;
    }

    .calculator-strategies-row {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      margin-top: 8px;
      margin-bottom: 12px;
    }

    .calculator-strategies-col,
    .calculator-race-params-col {
      flex: 1;
    }

    .calculator-strategies-col h3,
    .calculator-race-params-col h3 {
      margin: 0 0 6px;
      font-size: 0.9rem;
      font-weight: 500;
      color: var(--accent-color);
    }

    .calculator-strategy-inputs {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .calculator-race-params-list {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }

    .calculator-race-param-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .calculator-field-label {
      margin: 0;
      font-size: 0.75rem;
      flex: 0 0 120px;
      text-align: left;
      letter-spacing: 0.06em;
      color: var(--muted-color);
    }

    .calculator-field-input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: rgba(7, 11, 17, 0.96);
      color: var(--text-color);
      font-size: 0.86rem;
      outline: none;
      transition: border-color var(--transition-fast);
    }

    .calculator-field-input:focus {
      border-color: var(--accent-color);
      background: rgba(5, 11, 18, 1);
    }

    .calculator-field-input::placeholder {
      color: #4a5568;
      font-size: 0.8rem;
    }

    .calculator-compound-table {
      margin-top: 8px;
      margin-bottom: 10px;
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }

    .calculator-compound-table th,
    .calculator-compound-table td {
      border: 1px solid var(--border-color);
      padding: 5px 7px;
      text-align: center;
      color: var(--muted-color);
    }

    .calculator-compound-table th {
      background: rgba(0, 224, 255, 0.08);
      font-weight: 500;
      color: var(--accent-color);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .calculator-compound-table td {
      color: var(--text-color);
    }

    .calculator-compound-table td input.calculator-field-input {
      padding: 4px 6px;
      font-size: 0.75rem;
    }

    #calculatorScProbTable {
      margin-top: 6px;
      width: 100%;
      border-collapse: collapse;
      font-size: 0.78rem;
    }

    #calculatorScProbTable th,
    #calculatorScProbTable td {
      border: 1px solid var(--border-color);
      padding: 5px 7px;
      text-align: center;
    }

    #calculatorScProbTable th {
      background: rgba(0, 224, 255, 0.08);
      font-weight: 500;
      color: var(--accent-color);
      font-size: 0.75rem;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #calculatorScProbTable td {
      color: var(--text-color);
    }

    #calculatorScProbTable td input.calculator-field-input {
      padding: 4px 6px;
      font-size: 0.75rem;
    }

    .calculator-btn-small {
      margin-top: 6px;
      border-radius: 999px;
      border: 1px solid var(--accent-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--accent-color);
      font-size: 0.7rem;
      padding: 3px 10px;
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .calculator-btn-small:hover {
      background: var(--accent-color);
      color: #000;
      transform: translateY(-1px);
    }

    .calculator-run-btn {
      padding: 7px 18px;
      font-size: 0.9rem;
      background: linear-gradient(to right, var(--accent-color), #63b3ed);
      color: #050608;
      border: none;
      border-radius: 999px;
      cursor: pointer;
      transition: all var(--transition-fast);
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .calculator-run-btn:hover {
      transform: translateY(-1px);
      box-shadow: 0 6px 18px rgba(0, 0, 0, 0.7);
    }

    .calculator-chart {
      width: 100%;
      height: 340px;
      margin-top: 8px;
      border-radius: 10px;
      background: rgba(5, 7, 10, 0.8);
      border: 1px solid var(--border-color);
    }

    .calculator-stints-list {
      margin-top: 8px;
      font-size: 0.8rem;
      color: var(--muted-color);
    }

    .calculator-stints-list h3 {
      font-size: 0.9rem;
      margin-bottom: 6px;
      color: var(--text-color);
      font-weight: 500;
    }

    .calculator-stints-item {
      margin: 2px 0;
      padding: 3px 8px;
      border-left: 2px solid var(--accent-color);
      border-radius: 4px;
      background: rgba(0, 224, 255, 0.03);
    }

    .calculator-stints-label {
      color: var(--accent-color);
      font-weight: 500;
      margin-right: 6px;
    }

    .calculator-error {
      color: var(--error, #f56565);
      font-size: 0.8rem;
      margin-bottom: 8px;
      min-height: 1em;
    }

    @media (max-width: 1200px) {
      .calculator-layout {
        flex-direction: column;
      }
      .calculator-left-pane,
      .calculator-right-pane {
        max-height: none;
        overflow: visible;
      }
    .calculator-strategies-row {
      flex-direction: column;
    }
    }

    .hidden {
      display: none !important;
    }

    .spoiler-overlay {
      position: fixed;
      inset: 0;
      background: rgba(6, 8, 12, 0.92);
      backdrop-filter: blur(4px);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 9999;
      padding: 16px;
    }

    .spoiler-overlay.show {
      display: flex;
    }

    .spoiler-modal {
      width: min(560px, 100%);
      background: rgba(22, 26, 35, 0.9);
      border: 1px solid var(--border-color);
      border-radius: 16px;
      padding: 24px;
      box-shadow: 0 20px 60px rgba(0, 0, 0, 0.65);
      color: var(--text-color);
    }

    .spoiler-modal h2 {
      margin-top: 0;
      margin-bottom: 12px;
    }

    .spoiler-modal p {
      margin-top: 0;
      margin-bottom: 16px;
      color: var(--muted-color);
    }

    .spoiler-choice {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 8px;
    }

    .spoiler-button {
      padding: 10px 18px;
      border-radius: 8px;
      border: none;
      cursor: pointer;
      font-weight: 600;
      background: var(--accent-color);
      color: #050505;
      transition: opacity 0.2s ease;
    }

    .spoiler-button.secondary {
      background: transparent;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    .spoiler-button.link {
      background: transparent;
      border: none;
      color: var(--accent-color);
      text-decoration: underline;
      padding-left: 0;
    }

    .spoiler-button:disabled {
      opacity: 0.5;
      cursor: not-allowed;
    }

    .spoiler-config-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
      margin-top: 16px;
    }

    .spoiler-field {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .spoiler-field label {
      font-size: 13px;
      color: var(--muted-color);
    }

    .spoiler-field select {
      padding: 8px;
      background: rgba(0, 0, 0, 0.2);
      color: var(--text-color);
      border-radius: 6px;
      border: 1px solid var(--border-color);
    }

    .spoiler-actions {
      display: flex;
      flex-wrap: wrap;
      gap: 12px;
      margin-top: 20px;
    }

    .spoiler-status {
      margin-top: 12px;
      font-size: 13px;
      color: var(--accent-color);
    }

    #spoilerModeBtn {
      margin-left: 8px;
    }
  </style>
</head>
<body>
  <div id="spoilerOverlay" class="spoiler-overlay">
    <div class="spoiler-modal">
      <h2>Enable Spoiler Mode?</h2>
      <p>Hide any sessions you have not watched yet.</p>
      <div id="spoilerChoiceSection" class="spoiler-choice">
        <button id="spoilerEnableBtn" class="spoiler-button">Enable Spoiler Mode</button>
        <button id="spoilerSkipBtn" class="spoiler-button secondary">No Thanks</button>
      </div>
      <div id="spoilerConfigSection" class="spoiler-config-grid hidden">
        <div class="spoiler-field">
          <label for="spoilerSeasonSelect">Last race you watched</label>
          <select id="spoilerSeasonSelect" disabled>
            <option value="">Loading...</option>
          </select>
        </div>
        <div class="spoiler-field">
          <label for="spoilerGPSelect">Grand Prix</label>
          <select id="spoilerGPSelect" disabled>
            <option value="">Select a season first</option>
          </select>
        </div>
        <div class="spoiler-field">
          <label for="spoilerSessionSelect">Session</label>
          <select id="spoilerSessionSelect" disabled>
            <option value="">Select a race weekend</option>
          </select>
        </div>
        <div class="spoiler-actions">
          <button id="spoilerSaveBtn" class="spoiler-button">Save & Continue</button>
          <button id="spoilerBackBtn" class="spoiler-button secondary">Back</button>
          <button id="spoilerDisableBtn" class="spoiler-button link">Disable Spoiler Mode</button>
        </div>
        <div id="spoilerConfigStatus" class="spoiler-status"></div>
      </div>
    </div>
  </div>
  <div class="page-content">
  <div class="container">
    <!-- Tab Navigation -->
    <div class="tab-navigation">
      <button class="tab-button active" data-tab="strategy">Strategy</button>
      <button class="tab-button" data-tab="race-trace">Trace</button>
      <button class="tab-button" data-tab="fuel-effect" data-tooltip="Compares laps for the same driver, compound, and tyre life at different fuel loads to calculate fuel effect. Click 'Select Fuel Effect' to apply the coefficient to other tabs.">Fuel Effect</button>
      <button class="tab-button" data-tab="tyre-deg" data-tooltip="Computes fuel-corrected tyre degradation for each stint, then averages these values by compound. Click 'Select' to apply the degradation figures to other pages.">Tyre Deg</button>
      <button class="tab-button" data-tab="lap-time" data-tooltip="Shows fuel- and tyre-corrected lap times for each driver by compound. See table at the bottom. If the parameters are set correctly the lap times in the plot should not trend faster or slower. Use 'Copy Averages To Calculator' to apply the to other pages.">Lap Time</button>
      <button class="tab-button" data-tab="pit-loss" data-tooltip="Displays pit loss estimates by comparing pit laps to the surrounding reference laps.">Pit Loss</button>
      <button class="tab-button" data-tab="calculator" data-tooltip="Calculates the optimal free-air tyre strategy and compares it to other strategies">Calculator</button>
      <span class="status-message" id="statusMessage">Loading...</span>
      <button id="reloadDataBtn" type="button" title="Reload data from server">Reload Data</button>
      <button id="spoilerModeBtn" type="button" title="Adjust spoiler settings">Spoiler</button>
      <button id="copyPermalinkBtn" type="button" data-tooltip="Copy permalink URL to clipboard">Permalink</button>
    </div>

    <!-- Session Selector (shared across all tabs) -->
    <div class="session-selector">
      <label class="small" for="seasonSel">Season</label>
      <select id="seasonSel" title="Season">
        <option value=""></option>
      </select>
      <label class="small" for="gpSel">GP</label>
      <select id="gpSel" title="Grand Prix" disabled>
        <option value=""></option>
      </select>
      <label class="small" for="sessionSel">Session</label>
      <select id="sessionSel" title="Session type" disabled>
        <option value=""></option>
      </select>
    </div>

    <!-- Strategy Panel -->
    <div id="strategy-panel" class="content-panel active">
      <div id="strategyContainer" class="strategy-container">
        <div class="lap-axis top">
          <div class="lap-axis-spacer"></div>
          <div class="lap-axis-track" id="lapAxisTop"></div>
        </div>
        <div id="strategyChart"></div>
        <div class="lap-axis bottom">
          <div class="lap-axis-spacer"></div>
          <div class="lap-axis-track" id="lapAxisBottom"></div>
        </div>
      </div>
    </div>

    <!-- Race Trace Panel -->
    <div id="race-trace-panel" class="content-panel">
      <div class="race-trace-controls-row">
        <div class="race-trace-controls-box">
          <label class="small" for="raceTraceLapMin">Lap min</label>
          <input id="raceTraceLapMin" type="number" min="1" step="1" value="1" title="Min lap" />
          <label class="small" for="raceTraceLapMax">Lap max</label>
          <input id="raceTraceLapMax" type="number" min="1" step="1" value="1" title="Max lap" />
        </div>
      </div>

      <div class="race-trace-layout">
        <aside class="race-trace-sidebar">
          <div id="raceTraceDriverList" aria-label="Driver list"></div>
        </aside>
        <main id="raceTraceChart">
          <div class="race-trace-debug-info" id="raceTraceDebugInfo">
            Waiting for data...
          </div>
        </main>
      </div>
    </div>

    <!-- Lap Time Panel -->
    <div id="lap-time-panel" class="content-panel">
      <div style="display: flex; gap: 16px; margin-bottom: 16px;">
        <!-- LEFT: Filters -->
        <div style="flex: 0 0 275px;">
          <!-- Lap Filters -->
          <div class="filter-panel" style="margin-bottom: 16px;">
            <div class="filters-title">Lap Filters</div>
            <div class="filters-grid" style="grid-template-columns: 1fr;">
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at Start of Race</div>
                <input type="number" id="filterMinLap" value="1" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at End of Race</div>
                <input type="number" id="filterEndLaps" value="1" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at Start of Stint</div>
                <input type="number" id="filterMinStintLap" value="2" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Min Distance to Car Ahead</div>
                <input type="number" id="filterMinDist" value="3" min="0" step="0.1">
              </div>
            </div>
          </div>

          <!-- Analysis Parameters -->
          <div class="filter-panel" style="margin-bottom: 16px;">
            <div class="filters-title">Analysis Parameters</div>
            <div class="filters-grid" style="grid-template-columns: 1fr;">
              <div class="filter-item vertical">
                <div class="filter-label">Fuel Effect (sec/lap)</div>
                <div class="slider-container">
                  <input type="range" id="fuelEffect" min="0" max="0.3" step="0.001" value="0.025">
                  <div class="slider-value" id="fuelEffectValue">0.025</div>
                </div>
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Hard Deg (sec/lap)</div>
                <div class="slider-container">
                  <input type="range" id="degHard" min="0" max="0.3" step="0.001" value="0.05">
                  <div class="slider-value" id="degHardValue">0.050</div>
                </div>
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Medium Deg (sec/lap)</div>
                <div class="slider-container">
                  <input type="range" id="degMedium" min="0" max="0.3" step="0.001" value="0.08">
                  <div class="slider-value" id="degMediumValue">0.080</div>
                </div>
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Soft Deg (sec/lap)</div>
                <div class="slider-container">
                  <input type="range" id="degSoft" min="0" max="0.3" step="0.001" value="0.12">
                  <div class="slider-value" id="degSoftValue">0.120</div>
                </div>
              </div>
            </div>
          </div>

          <!-- Include Filters -->
          <div class="filter-panel">
            <div class="filters-title">Include</div>
            <div class="exclude-checkboxes">
              <div class="checkbox-group">
                <input type="checkbox" id="filterIncludeLapped" checked>
                <label for="filterIncludeLapped">Lapped</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="filterIncludeRetired" checked>
                <label for="filterIncludeRetired">Retired</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="filterRainfall">
                <label for="filterRainfall">Rainfall</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="filterSafetyCar">
                <label for="filterSafetyCar">Safety Car</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="filterPitLaps">
                <label for="filterPitLaps">Pit Laps</label>
              </div>
            </div>
          </div>
        </div>

        <!-- RIGHT: Drivers and Chart -->
        <div style="flex: 1;">
          <div class="lap-time-layout">
            <div class="lap-time-sidebar">
              <div id="lapTimeDriversList"></div>
            </div>
            <div class="lap-time-chart-wrapper">
              <div class="lap-time-controls">
                <div class="lap-time-controls-left">
                  <button id="fuelAdjustToggle" class="toggle-button active">Fuel Adjusted</button>
                  <button id="tyreLifeAdjustToggle" class="toggle-button active">Tyre Life Adjusted</button>
                </div>
                <button id="copyLapTimeDataBtn" class="copy-data-button">Copy Data</button>
              </div>
              <div id="lapTimeChart"></div>
            </div>
          </div>
        </div>
      </div>

      <!-- BOTTOM: Summary Table -->
      <div id="lapTimeSummaryTableContainer"></div>
    </div>

    <!-- Tyre Degradation Panel -->
    <div id="tyre-deg-panel" class="content-panel">
      <div style="display: flex; gap: 16px; margin-bottom: 16px;">
        <!-- LEFT: Filters -->
        <div style="flex: 0 0 275px;">
          <!-- Lap Filters -->
          <div class="filter-panel" style="margin-bottom: 16px;">
            <div class="filters-title">Lap Filters</div>
            <div class="filters-grid" style="grid-template-columns: 1fr;">
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at Start of Race</div>
                <input type="number" id="tyreDegFilterMinLap" value="1" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at End of Race</div>
                <input type="number" id="tyreDegFilterEndLaps" value="1" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at Start of Stint</div>
                <input type="number" id="tyreDegFilterMinStintLap" value="2" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Min Distance to Car Ahead</div>
                <input type="number" id="tyreDegFilterMinDist" value="3" min="0" step="0.1">
              </div>
            </div>
          </div>

          <!-- Analysis Parameters -->
          <div class="filter-panel" style="margin-bottom: 16px;">
            <div class="filters-title">Analysis Parameters</div>
            <div class="filters-grid" style="grid-template-columns: 1fr;">
              <div class="filter-item vertical">
                <div class="filter-label">Fuel Effect (s/lap)</div>
                <div class="slider-container">
                  <input type="range" id="tyreDegFuelEffectSlider" min="0" max="0.1" step="0.001" value="0.025">
                  <div class="slider-value" id="tyreDegFuelEffectValue">0.025</div>
                </div>
              </div>
              <div class="filter-item">
                <div class="filter-label">Min Rows Per Stint</div>
                <input type="number" id="tyreDegFilterMinRows" value="5" min="1">
              </div>
              <div class="filter-item">
                <div class="filter-label">Min Correlation</div>
                <input type="number" id="tyreDegFilterMinCorr" value="-0.5" min="-1" max="1" step="0.1">
              </div>
            </div>
          </div>

          <!-- Include Filters -->
          <div class="filter-panel" style="margin-bottom: 16px;">
            <div class="filters-title">Include</div>
            <div class="exclude-checkboxes">
              <div class="checkbox-group">
                <input type="checkbox" id="tyreDegFilterIncludeLapped" checked>
                <label for="tyreDegFilterIncludeLapped">Lapped</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="tyreDegFilterIncludeRetired" checked>
                <label for="tyreDegFilterIncludeRetired">Retired</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="tyreDegFilterRainfall">
                <label for="tyreDegFilterRainfall">Rainfall</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="tyreDegFilterSafetyCar">
                <label for="tyreDegFilterSafetyCar">Safety Car</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="tyreDegFilterPitLaps">
                <label for="tyreDegFilterPitLaps">Pit Laps</label>
              </div>
            </div>
          </div>

          <!-- Tyre Choices -->
          <div id="tyreDegTyreChoicesDisplay" class="tyre-choices-display" style="display: none; margin-bottom: 16px;">
            <div class="tyre-choices-label">Tyre Choices:</div>
            <div id="tyreDegTyreChoicesText"></div>
          </div>
        </div>

        <!-- RIGHT: Charts and Analysis -->
        <div style="flex: 1;">
          <!-- Charts Side by Side -->
          <div style="display: flex; gap: 16px; margin-bottom: 16px;">
            <!-- Lap Time Chart -->
            <div id="tyreDegChartsWrapper" style="display: none; flex: 1;">
              <div class="tyre-deg-chart-container">
                <div class="chart-title">Lap Time vs Tyre Age</div>
                <div class="tyre-deg-chart-controls">
                  <button id="tyreDegFuelAdjustToggle" class="toggle-button active">Fuel Adjusted</button>
                  <span style="font-size: 10px; color: var(--muted-color);" id="tyreDegSelectedStintCount">No stints selected</span>
                </div>
                <div id="tyreDegLapTimeChart" style="height: 400px;"></div>
              </div>

              <!-- Average Deg Display -->
              <div id="tyreDegAvgDegDisplay" class="equations-section" style="display: none;">
                <div class="equations-title">Average Deg</div>
                <div style="display: flex; gap: 12px; align-items: center;">
                  <div id="tyreDegAvgDegText" class="equations-grid" style="flex: 1;"></div>
                  <button id="tyreDegCopyAvgDegButton" style="display: none; padding: 12px 16px; font-size: 11px; background: var(--accent-color); color: var(--bg-color); border: none; border-radius: 4px; cursor: pointer; font-weight: 600;">Select</button>
                </div>
              </div>
            </div>

            <!-- Scatter Chart -->
            <div id="tyreDegScatterChartWrapper" style="display: none; flex: 1;">
              <div class="tyre-deg-chart-container">
                <div class="chart-title">Tyre Degradation Analysis: Deg vs Pace</div>
                <div style="height: 32px;"></div>
                <div id="tyreDegScatterChart" style="height: 400px;"></div>
                <div id="tyreDegEquationsSection" class="equations-section" style="display: none;">
                  <div class="equations-title">Best Fit Equations (Deg = m × Pace + b)</div>
                  <div id="tyreDegEquationsGrid" class="equations-grid"></div>
                </div>
              </div>
            </div>
          </div>
        </div>
      </div>

      <!-- BOTTOM: Stint Table -->
      <div id="tyreDegStintsTableContainer"></div>
    </div>

    <!-- Fuel Effect Panel -->
    <div id="fuel-effect-panel" class="content-panel">
      <div style="display: flex; gap: 16px; margin-bottom: 16px;">
        <!-- LEFT: Filters -->
        <div style="flex: 0 0 275px;">
          <!-- Lap Filters -->
          <div class="filter-panel" style="margin-bottom: 16px;">
            <div class="filters-title">Lap Filters</div>
            <div class="filters-grid" style="grid-template-columns: 1fr;">
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at Start of Race</div>
                <input type="number" id="fuelEffectFilterMinLap" value="1" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at End of Race</div>
                <input type="number" id="fuelEffectFilterEndLaps" value="1" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Laps to Discard at Start of Stint</div>
                <input type="number" id="fuelEffectFilterMinStintLap" value="2" min="0">
              </div>
              <div class="filter-item vertical">
                <div class="filter-label">Min Distance to Car Ahead</div>
                <input type="number" id="fuelEffectFilterMinDist" value="3" min="0" step="0.1">
              </div>
            </div>
          </div>

          <!-- Include Filters -->
          <div class="filter-panel">
            <div class="filters-title">Include</div>
            <div class="exclude-checkboxes">
              <div class="checkbox-group">
                <input type="checkbox" id="fuelEffectFilterIncludeLapped" checked>
                <label for="fuelEffectFilterIncludeLapped">Lapped</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="fuelEffectFilterIncludeRetired" checked>
                <label for="fuelEffectFilterIncludeRetired">Retired</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="fuelEffectFilterRainfall">
                <label for="fuelEffectFilterRainfall">Rainfall</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="fuelEffectFilterSafetyCar">
                <label for="fuelEffectFilterSafetyCar">Safety Car</label>
              </div>
              <div class="checkbox-group">
                <input type="checkbox" id="fuelEffectFilterPitLaps">
                <label for="fuelEffectFilterPitLaps">Pit Laps</label>
              </div>
            </div>
          </div>
        </div>

        <!-- RIGHT: Chart and Coefficients -->
        <div style="flex: 1;">
          <div id="fuelEffectChartContainer" style="width: 100%; height: 400px; display: none;"></div>
          <div id="fuelEffectCoefficientsContainer" style="display: none; padding: 12px 16px; background: rgba(0, 224, 255, 0.03); border-radius: 8px; border: 1px solid var(--border-color); margin-top: 8px;">
            <div style="font-size: 11px; font-weight: 600; color: var(--accent-color); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Linear Fit Coefficients (y = mx)</div>
            <div id="fuelEffectCoefficientsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;"></div>
          </div>
        </div>
      </div>

      <!-- BOTTOM: Table -->
      <div id="fuelEffectGroupsTableContainer"></div>
    </div>

    <!-- Pit Loss Panel -->
    <div id="pit-loss-panel" class="content-panel">
      <div class="pit-loss-header">
        <div class="pit-loss-inner">
          <div class="pit-loss-stats">
            <div class="pit-loss-stat"><span class="label">Average</span><span class="value"><span id="pitLossAverage">—</span> s</span></div>
            <div class="pit-loss-stat"><span class="label">Median</span><span class="value"><span id="pitLossMedian">—</span> s</span></div>
          </div>
          <div>
            <button id="copyPitLossAverageBtn" type="button" class="calculator-run-btn" style="padding: 8px 14px; font-size: 12px;">Copy Median to Calculator</button>
          </div>
        </div>
      </div>
      <div id="pitLossTableContainer"></div>
    </div>

    <!-- Calculator Panel -->
    <div id="calculator-panel" class="content-panel">
      <div class="calculator-layout">
        <!-- LEFT: INPUTS -->
        <div class="calculator-left-pane">
          <div class="calculator-section">
            <div id="calculatorErrorBox" class="calculator-error"></div>

            <div class="calculator-inputs-actions">
              <div class="calculator-section-header">
                <h2>Inputs</h2>
                <div class="calculator-small-note">Adjust parameters, then Run to recompute.</div>
              </div>
              <button id="calculatorRunBtn" type="button" class="calculator-run-btn">Run</button>
            </div>

            <div class="calculator-strategies-row">
              <div class="calculator-strategies-col">
                <h3>Strategies Of Interest</h3>
                <div id="calculatorStrategyInputs" class="calculator-strategy-inputs">
                  <input type="text" class="calculator-field-input calculatorStrategyInput" placeholder="e.g., S,M,H" />
                  <input type="text" class="calculator-field-input calculatorStrategyInput" placeholder="e.g., M,H" />
                  <input type="text" class="calculator-field-input calculatorStrategyInput" placeholder="e.g., S,H" />
                  <input type="text" class="calculator-field-input calculatorStrategyInput" placeholder="e.g., M,M,H" />
                  <input type="text" class="calculator-field-input calculatorStrategyInput" placeholder="e.g., S,M,M,H" />
                </div>
              </div>

              <div class="calculator-race-params-col">
                <h3>Race Parameters</h3>
                <div class="calculator-race-params-list">
                  <div class="calculator-race-param-row">
                    <span class="calculator-field-label">Num laps</span>
                    <input type="number" id="calculatorNumLaps" class="calculator-field-input" min="1" />
                  </div>
                  <div class="calculator-race-param-row">
                    <span class="calculator-field-label">Pit loss (s)</span>
                    <input type="number" id="calculatorPitLoss" class="calculator-field-input" step="0.1" />
                  </div>
                  <div class="calculator-race-param-row">
                    <span class="calculator-field-label">SC length (laps)</span>
                    <input type="number" id="calculatorScLength" class="calculator-field-input" min="1" />
                  </div>
                  <div class="calculator-race-param-row">
                    <span class="calculator-field-label">Fuel Effect (s/lap)</span>
                    <input type="number" id="calculatorFuelEffect" class="calculator-field-input" step="0.001" />
                  </div>
                </div>
              </div>
            </div>

            <table class="calculator-compound-table">
              <thead>
                <tr>
                  <th>Compound</th>
                  <th>Pace (sec)</th>
                  <th>Degradation (sec/lap)</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td>Hard</td>
                  <td><input type="number" id="calculatorPaceH" class="calculator-field-input" step="0.001" /></td>
                  <td><input type="number" id="calculatorDegH" class="calculator-field-input" step="0.001" /></td>
                </tr>
                <tr>
                  <td>Medium</td>
                  <td><input type="number" id="calculatorPaceM" class="calculator-field-input" step="0.001" /></td>
                  <td><input type="number" id="calculatorDegM" class="calculator-field-input" step="0.001" /></td>
                </tr>
                <tr>
                  <td>Soft</td>
                  <td><input type="number" id="calculatorPaceS" class="calculator-field-input" step="0.001" /></td>
                  <td><input type="number" id="calculatorDegS" class="calculator-field-input" step="0.001" /></td>
                </tr>
              </tbody>
            </table>

            <h3>Safety Car Probability</h3>
            <div class="calculator-small-note">
              Non-overlapping ranges. Final range must leave "To lap" blank (extends to end).
            </div>
            <table id="calculatorScProbTable">
              <thead>
                <tr>
                  <th>From lap</th>
                  <th>To lap (blank = ∞)</th>
                  <th>Probability %</th>
                  <th></th>
                </tr>
              </thead>
              <tbody></tbody>
            </table>
            <button type="button" id="calculatorAddRangeBtn" class="calculator-btn-small">+ Add range</button>
          </div>
        </div>

        <!-- RIGHT: OUTPUTS -->
        <div class="calculator-right-pane">
          <div class="calculator-section">
            <div class="calculator-section-header">
              <h2>Strategy Comparison</h2>
              <div class="calculator-small-note">
                Bars show total race time Δ vs optimal strategy.
              </div>
            </div>

            <div id="calculatorStrategyChart" class="calculator-chart"></div>
            <div id="calculatorStrategyStints" class="calculator-stints-list"></div>
            <div class="calculator-small-note" style="margin-top:6px;">
              <h3>Lap times by strategy. Ignores pit stops and safety cars.</h3>
            </div>
            <div id="calculatorLapTimeChart" class="calculator-chart" style="height:260px; margin-top:4px;"></div>
          </div>
        </div>
      </div>
    </div>

  </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>

  <script>
    // ============================================================================
    // SHARED STATE AND ELEMENTS
    // ============================================================================

    const seasonSel = document.getElementById("seasonSel");
    const gpSel = document.getElementById("gpSel");
    const sessionSel = document.getElementById("sessionSel");
    const statusMessage = document.getElementById("statusMessage");
    const reloadDataBtn = document.getElementById("reloadDataBtn");
    const spoilerModeBtn = document.getElementById("spoilerModeBtn");
    const spoilerOverlay = document.getElementById('spoilerOverlay');
    const spoilerChoiceSection = document.getElementById('spoilerChoiceSection');
    const spoilerConfigSection = document.getElementById('spoilerConfigSection');
    const spoilerSeasonSelect = document.getElementById('spoilerSeasonSelect');
    const spoilerGPSelect = document.getElementById('spoilerGPSelect');
    const spoilerSessionSelect = document.getElementById('spoilerSessionSelect');
    const spoilerEnableBtn = document.getElementById('spoilerEnableBtn');
    const spoilerSkipBtn = document.getElementById('spoilerSkipBtn');
    const spoilerSaveBtn = document.getElementById('spoilerSaveBtn');
    const spoilerBackBtn = document.getElementById('spoilerBackBtn');
    const spoilerDisableBtn = document.getElementById('spoilerDisableBtn');
    const spoilerConfigStatus = document.getElementById('spoilerConfigStatus');

    let allRows = [];
    let allRowsRaw = [];
    let sessionsByKey = new Map();
    const fullSessionsByKey = new Map();
    let currentSessionData = null; // Stores filtered data for current session
    let rawDataReady = false;
    let spoilerDecisionResolved = false;
    let sessionsInitialized = false;
    let pendingSessionRestore = false;
    let spoilerEventsInitialized = false;

    // ============================================================================
    // GLOBAL STATE MANAGEMENT
    // ============================================================================

    /**
     * Default state object defining all initial/default values.
     * Used as a baseline for generating minimal permalink payloads.
     */
    const defaultAppState = {
      // Shared across tabs
      currentActiveTab: 'strategy',
      selectedDrivers: [],

      // Session selection
      session: {
        season: '',
        gp: '',
        sessionType: ''
      },

      // Shared filters (synced across lap time, tyre deg, and fuel effect tabs)
      filters: {
        minLap: 1,
        endLaps: 1,
        minStintLap: 2,
        minDist: 3,
        rainfall: false,
        safetyCar: false,
        pitLaps: false,
        includeLapped: true,
        includeRetired: true
      },

      // Shared pace model parameters (used across lap time and calculator tabs)
      paceModel: {
        fuelEffect: 0.025,
        degSoft: 0.12,
        degMedium: 0.08,
        degHard: 0.05
      },

      // Race Trace tab
      raceTrace: {
        lapMin: 1,
        lapMax: 1
      },

      // Lap Time tab
      lapTime: {
        fuelAdjust: true,
        tyreLifeAdjust: true
      },

      // Tyre Deg tab
      tyreDeg: {
        fuelAdjust: true,
        filterMinRows: 5,
        filterMinCorr: -0.5,
        selectedStints: []
      },

      // Fuel Effect tab
      fuelEffect: {
        selectedRows: []
      },

      // Pit Loss tab
      pitLossTab: {
        selectedKeys: []
      },

      // Calculator tab
      calculator: {
        numLaps: null,
        strategies: ['', '', '', '', ''],
        pitLoss: null,
        scLength: null,
        paceS: null,
        paceM: null,
        paceH: null,
        scProbRanges: [
          {from:'1', to: '1', prob: '26.1'},
          {from:'2', to: '2', prob: '4.9'},
          {from:'3', to: '3', prob: '3.3'},
          {from:'4', to: '', prob: '1.6'}
        ]
      }
    };

    /**
     * Global state object storing all user inputs across all tabs.
     * This allows for future serialization and state persistence.
     */
    const appState = {
      // Shared across tabs
      currentActiveTab: 'strategy',
      selectedDrivers: new Set(), // Shared driver selection across race trace and lap time panels

      // Session selection
      session: {
        season: '',
        gp: '',
        sessionType: ''
      },

      // Shared filters (synced across lap time, tyre deg, and fuel effect tabs)
      filters: {
        minLap: 1,
        endLaps: 1,
        minStintLap: 2,
        minDist: 3,
        rainfall: false,
        safetyCar: false,
        pitLaps: false,
        includeLapped: true,
        includeRetired: true
      },

      // Shared pace model parameters (used across lap time and calculator tabs)
      paceModel: {
        fuelEffect: 0.025,
        degSoft: 0.12,
        degMedium: 0.08,
        degHard: 0.05
      },

      // Race Trace tab
      raceTrace: {
        lapMin: 1,
        lapMax: 1
      },

      // Lap Time tab
      lapTime: {
        fuelAdjust: true,
        tyreLifeAdjust: true
      },

      // Tyre Deg tab
      tyreDeg: {
        fuelAdjust: true,
        filterMinRows: 5,
        filterMinCorr: -0.5,
        selectedStints: new Set() // Selected stint keys (data-dependent)
      },

      // Fuel Effect tab
      fuelEffect: {
        selectedRows: new Set() // Selected row keys (data-dependent)
      },

      // Pit Loss tab
      pitLossTab: {
        selectedKeys: new Set()
      },

      // Calculator tab
      calculator: {
        numLaps: null,
        strategies: ['', '', '', '', ''], // Array of strategy strings
        pitLoss: null,
        scLength: null,
        paceS: null,
        paceM: null,
        paceH: null,
        scProbRanges: [] // Array of {fromLap, toLap, probability}
      }
    };

    // ============================================================================
    // SPOILER MODE HELPERS
    // ============================================================================

    const SPOILER_COOKIE_NAME = 'f1SpoilerConfig';
    const SPOILER_COOKIE_MAX_AGE = 60 * 60 * 24 * 180; // 180 days
    const SPOILER_SESSION_ORDER = [
      'FP0',
      'FP1',
      'FP2',
      'FP3',
      'PRACTICE',
      'SPRINT SHOOTOUT',
      'SPRINT QUALIFYING',
      'SQ',
      'SPRINT',
      'S',
      'QUALIFYING',
      'Q',
      'RACE',
      'R'
    ];

    const spoilerSessionOrderMap = new Map();
    SPOILER_SESSION_ORDER.forEach((label, index) => {
      spoilerSessionOrderMap.set(label, index);
    });

    let spoilerConfig = {
      enabled: false,
      lastSeason: null,
      lastRound: null,
      lastSessionType: null,
      lastMeetingName: null
    };

    function getSessionOrderValue(sessionType) {
      if (!sessionType) return SPOILER_SESSION_ORDER.length + 10;
      const normalized = String(sessionType).trim().toUpperCase();
      return spoilerSessionOrderMap.has(normalized)
        ? spoilerSessionOrderMap.get(normalized)
        : SPOILER_SESSION_ORDER.length + 5;
    }

    function filterRowsForSpoilerConfig(rows, config) {
      if (!config.enabled || !config.lastSeason || !config.lastRound || !config.lastSessionType) {
        return rows.slice();
      }

      const targetSeason = parseInt(config.lastSeason, 10);
      const targetRound = parseInt(config.lastRound, 10);
      const cutoffOrder = getSessionOrderValue(config.lastSessionType);

      return rows.filter(row => {
        const season = parseInt(row.year, 10);
        const round = parseInt(row.round_no, 10);
        if (!Number.isFinite(season) || !Number.isFinite(round)) return false;

        if (season < targetSeason) return true;
        if (season > targetSeason) return false;
        if (round < targetRound) return true;
        if (round > targetRound) return false;

        const order = getSessionOrderValue(row.session_type);
        return order <= cutoffOrder;
      });
    }

    function saveSpoilerConfigToCookie(config) {
      try {
        const payload = encodeURIComponent(JSON.stringify(config));
        document.cookie = `${SPOILER_COOKIE_NAME}=${payload};path=/;max-age=${SPOILER_COOKIE_MAX_AGE}`;
      } catch (err) {
        console.warn('Unable to save spoiler settings', err);
      }
    }

    function loadSpoilerConfigFromCookie() {
      const cookies = document.cookie ? document.cookie.split('; ') : [];
      const entry = cookies.find(row => row.startsWith(`${SPOILER_COOKIE_NAME}=`));
      if (!entry) return null;
      try {
        const value = decodeURIComponent(entry.split('=')[1] || '');
        return JSON.parse(value);
      } catch (err) {
        console.warn('Unable to parse spoiler cookie', err);
        return null;
      }
    }

    function updateSpoilerModeButtonState() {
      if (!spoilerModeBtn) return;
      spoilerModeBtn.textContent = spoilerConfig.enabled ? 'Spoiler: ON' : 'Spoiler: OFF';
    }

    function showSpoilerChoiceView() {
      if (!spoilerChoiceSection || !spoilerConfigSection) return;
      spoilerChoiceSection.classList.remove('hidden');
      spoilerConfigSection.classList.add('hidden');
    }

    function showSpoilerConfigFormView() {
      if (!spoilerChoiceSection || !spoilerConfigSection) return;
      spoilerChoiceSection.classList.add('hidden');
      spoilerConfigSection.classList.remove('hidden');
      if (spoilerConfigStatus) spoilerConfigStatus.textContent = '';
      if (rawDataReady) {
        const prefs = getSpoilerPreferenceValues();
        populateSpoilerSeasonOptions(prefs.season, prefs.gp, prefs.sessionType);
      }
      if (spoilerDisableBtn) {
        spoilerDisableBtn.classList.toggle('hidden', !spoilerConfig.enabled);
      }
    }

    function openSpoilerOverlay(options = {}) {
      const { forceConfig = false } = options;
      if (!spoilerOverlay) return;
      spoilerOverlay.classList.add('show');
      document.body.style.overflow = 'hidden';
      if (forceConfig || spoilerConfig.enabled) {
        showSpoilerConfigFormView();
      } else {
        showSpoilerChoiceView();
      }
    }

    function closeSpoilerOverlay() {
      if (!spoilerOverlay) return;
      spoilerOverlay.classList.remove('show');
      document.body.style.overflow = '';
    }

    function formatSessionLabel(sessionType) {
      if (!sessionType) return '';
      const normalized = String(sessionType).trim().toUpperCase();
      switch (normalized) {
        case 'R':
        case 'RACE':
          return 'Race';
        case 'S':
        case 'SPRINT':
          return 'Sprint';
        case 'SQ':
        case 'SPRINT QUALIFYING':
        case 'SPRINT SHOOTOUT':
          return 'Sprint Shootout';
        case 'Q':
        case 'QUALIFYING':
          return 'Qualifying';
        case 'FP1':
          return 'Practice 1';
        case 'FP2':
          return 'Practice 2';
        case 'FP3':
          return 'Practice 3';
        default:
          return sessionType;
      }
    }

    function getSpoilerPreferenceValues() {
      const season = appState.session.season || spoilerConfig.lastSeason || '';
      const gpPref = appState.session.gp || (spoilerConfig.lastRound && spoilerConfig.lastMeetingName ? `${spoilerConfig.lastRound}||${spoilerConfig.lastMeetingName}` : '');
      const sessionType = appState.session.sessionType || spoilerConfig.lastSessionType || '';
      return {
        season: season || '',
        gp: gpPref || '',
        sessionType: sessionType || ''
      };
    }

    function populateSpoilerSeasonOptions(preferredSeason = null, preferredGP = null, preferredSession = null) {
      if (!spoilerSeasonSelect) return;
      const seasons = new Set();
      fullSessionsByKey.forEach(value => {
        if (value.year) seasons.add(value.year);
      });
      const sorted = Array.from(seasons).sort((a, b) => parseInt(b, 10) - parseInt(a, 10));
      spoilerSeasonSelect.innerHTML = '<option value="">Select a season</option>';
      sorted.forEach(season => {
        const opt = document.createElement('option');
        opt.value = season;
        opt.textContent = season;
        spoilerSeasonSelect.appendChild(opt);
      });
      spoilerSeasonSelect.disabled = sorted.length === 0;
      if (sorted.length === 0) {
        populateSpoilerGPOptions('', null);
        return;
      }
      let targetSeason = preferredSeason && sorted.includes(preferredSeason) ? preferredSeason : sorted[0];
      spoilerSeasonSelect.value = targetSeason;
      populateSpoilerGPOptions(targetSeason, preferredGP, preferredSession);
    }

    function populateSpoilerGPOptions(season, preferredGP = null, preferredSession = null) {
      if (!spoilerGPSelect) return;
      spoilerGPSelect.innerHTML = '<option value="">Select a race weekend</option>';
      spoilerGPSelect.disabled = true;
      populateSpoilerSessionOptions('', '', '', null);
      if (!season) return;

      const gpEntries = new Map();
      fullSessionsByKey.forEach(value => {
        if (value.year === season) {
          const round = parseInt(value.round_no, 10) || 0;
          const key = `${round}||${value.meeting_name}`;
          if (!gpEntries.has(key)) {
            gpEntries.set(key, { round, meeting: value.meeting_name });
          }
        }
      });

      const sorted = Array.from(gpEntries.values()).sort((a, b) => a.round - b.round);
      sorted.forEach(entry => {
        const opt = document.createElement('option');
        opt.value = `${entry.round}||${entry.meeting}`;
        opt.textContent = `Round ${entry.round}: ${entry.meeting}`;
        spoilerGPSelect.appendChild(opt);
      });
      spoilerGPSelect.disabled = sorted.length === 0;
      if (sorted.length === 0) {
        populateSpoilerSessionOptions('', '', '', null);
        return;
      }
      let targetEntry = sorted[sorted.length - 1];
      if (preferredGP) {
        const [round, meeting] = preferredGP.split('||');
        const found = sorted.find(entry => String(entry.round) === String(round) && entry.meeting === meeting);
        if (found) {
          targetEntry = found;
        }
      }
      const targetOption = `${targetEntry.round}||${targetEntry.meeting}`;
      spoilerGPSelect.value = targetOption;
      populateSpoilerSessionOptions(season, targetEntry.round, targetEntry.meeting, preferredSession);
    }

    function populateSpoilerSessionOptions(season, round, meetingName, preferredSession = null) {
      if (!spoilerSessionSelect) return;
      spoilerSessionSelect.innerHTML = '<option value="">Select a session</option>';
      spoilerSessionSelect.disabled = true;

      if (!season || !round) return;

      const sessions = new Set();
      fullSessionsByKey.forEach(value => {
        if (value.year === String(season) &&
            String(value.round_no) === String(round) &&
            (!meetingName || value.meeting_name === meetingName)) {
          sessions.add(value.session_type);
        }
      });

      const sortedSessions = Array.from(sessions).sort((a, b) => {
        return getSessionOrderValue(a) - getSessionOrderValue(b);
      });

      sortedSessions.forEach(sessionType => {
        const opt = document.createElement('option');
        opt.value = sessionType;
        opt.textContent = formatSessionLabel(sessionType);
        spoilerSessionSelect.appendChild(opt);
      });

      spoilerSessionSelect.disabled = sortedSessions.length === 0;
      if (sortedSessions.length === 0) return;

      let targetSession = sortedSessions[sortedSessions.length - 1];
      if (preferredSession && sortedSessions.includes(preferredSession)) {
        targetSession = preferredSession;
      }
      spoilerSessionSelect.value = targetSession;
    }

    function updateStatusMessageForSpoilers() {
      if (!statusMessage || !rawDataReady) return;
      if (spoilerConfig.enabled && spoilerConfig.lastSeason) {
        const meeting = spoilerConfig.lastMeetingName ? ` - ${spoilerConfig.lastMeetingName}` : '';
        const roundLabel = spoilerConfig.lastRound ? ` Round ${spoilerConfig.lastRound}` : '';
      }
      statusMessage.textContent = `${allRows.length} laps loaded`;
    }

    function applySpoilerFilter() {
      allRows = filterRowsForSpoilerConfig(allRowsRaw, spoilerConfig);
      indexSessions(allRows, sessionsByKey);
    }

    function initializeSessionsUI(options = {}) {
      const { preserveSelection = false } = options;
      sessionsInitialized = true;

      if (pendingSessionRestore) {
        window.permalinkSession = window.permalinkSession || {};
        window.permalinkSession.isRestoring = true;
      }

      UIHelpers.populateSeasons(seasonSel, sessionsByKey, {});
      const availableSeasons = Array.from(seasonSel.options).map(opt => opt.value);

      let targetSeason = null;
      if (preserveSelection && seasonSel.value && availableSeasons.includes(seasonSel.value)) {
        targetSeason = seasonSel.value;
      } else if (appState.session.season && availableSeasons.includes(appState.session.season)) {
        targetSeason = appState.session.season;
      } else if (availableSeasons.length > 0) {
        targetSeason = availableSeasons[0];
      }

      if (targetSeason) {
        seasonSel.value = targetSeason;
        appState.session.season = targetSeason;
      }

      onSeasonChange();

      if (pendingSessionRestore && window.permalinkSession) {
        window.permalinkSession.isRestoring = false;
        pendingSessionRestore = false;
      }

      updateStatusMessageForSpoilers();
    }

    function maybeInitializeAfterPrereqs(options = {}) {
      const { preserveSelection = false } = options;
      if (!rawDataReady || !spoilerDecisionResolved) return;
      applySpoilerFilter();
      initializeSessionsUI({ preserveSelection });
    }

    function handleSpoilerSelectionSaved({ enabled, season, round, sessionType, meetingName }) {
      spoilerConfig = {
        enabled,
        lastSeason: enabled ? (season || null) : null,
        lastRound: enabled ? (round || null) : null,
        lastSessionType: enabled ? (sessionType || null) : null,
        lastMeetingName: enabled ? (meetingName || null) : null
      };
      spoilerDecisionResolved = true;
      saveSpoilerConfigToCookie(spoilerConfig);
      updateSpoilerModeButtonState();
      if (spoilerConfigStatus) spoilerConfigStatus.textContent = '';
      closeSpoilerOverlay();
      maybeInitializeAfterPrereqs({ preserveSelection: false });
    }

    function handleSpoilerSaveSelection() {
      if (!spoilerSeasonSelect || !spoilerGPSelect || !spoilerSessionSelect) return;
      const season = spoilerSeasonSelect.value;
      const gpValue = spoilerGPSelect.value;
      const sessionType = spoilerSessionSelect.value;

      if (!season || !gpValue || !sessionType) {
        if (spoilerConfigStatus) {
          spoilerConfigStatus.textContent = 'Please select a season, Grand Prix, and session.';
        }
        return;
      }

      const [round, meetingName] = gpValue.split('||');
      handleSpoilerSelectionSaved({
        enabled: true,
        season,
        round,
        sessionType,
        meetingName
      });
    }

    function handleSpoilerSkipChoice() {
      handleSpoilerSelectionSaved({ enabled: false });
    }

    function handleSpoilerDisableChoice() {
      handleSpoilerSelectionSaved({ enabled: false });
    }

    function handleSpoilerBackToChoice() {
      showSpoilerChoiceView();
    }

    function initializeSpoilerStateFromCookie() {
      const saved = loadSpoilerConfigFromCookie();
      if (saved && typeof saved === 'object') {
        spoilerConfig = {
          enabled: !!saved.enabled,
          lastSeason: saved.lastSeason || null,
          lastRound: saved.lastRound || null,
          lastSessionType: saved.lastSessionType || null,
          lastMeetingName: saved.lastMeetingName || null
        };
        spoilerDecisionResolved = true;
      }
      updateSpoilerModeButtonState();
    }

    function setupSpoilerEventListeners() {
      if (spoilerEventsInitialized) return;
      spoilerEventsInitialized = true;

      if (spoilerEnableBtn) {
        spoilerEnableBtn.addEventListener('click', () => showSpoilerConfigFormView());
      }
      if (spoilerSkipBtn) {
        spoilerSkipBtn.addEventListener('click', handleSpoilerSkipChoice);
      }
      if (spoilerSaveBtn) {
        spoilerSaveBtn.addEventListener('click', handleSpoilerSaveSelection);
      }
      if (spoilerBackBtn) {
        spoilerBackBtn.addEventListener('click', handleSpoilerBackToChoice);
      }
      if (spoilerDisableBtn) {
        spoilerDisableBtn.addEventListener('click', handleSpoilerDisableChoice);
      }
      if (spoilerModeBtn) {
        spoilerModeBtn.addEventListener('click', () => {
          openSpoilerOverlay({ forceConfig: true });
        });
      }
      if (spoilerSeasonSelect) {
        spoilerSeasonSelect.addEventListener('change', () => {
          populateSpoilerGPOptions(spoilerSeasonSelect.value, null);
        });
      }
      if (spoilerGPSelect) {
        spoilerGPSelect.addEventListener('change', () => {
          const gpValue = spoilerGPSelect.value;
          if (!gpValue) {
            populateSpoilerSessionOptions('', '', '', null);
            return;
          }
          const [round, meeting] = gpValue.split('||');
          populateSpoilerSessionOptions(spoilerSeasonSelect.value, round, meeting, null);
        });
      }
      if (spoilerSessionSelect) {
        spoilerSessionSelect.addEventListener('change', () => {
          if (spoilerConfigStatus) spoilerConfigStatus.textContent = '';
        });
      }
    }
    /**
     * Save a value to the state object
     * @param {string} path - Dot-notation path (e.g., 'filters.minLap' or 'lapTime.fuelAdjust')
     * @param {*} value - Value to save
     */
    function saveToState(path, value) {
      const keys = path.split('.');
      let obj = appState;
      for (let i = 0; i < keys.length - 1; i++) {
        obj = obj[keys[i]];
      }
      obj[keys[keys.length - 1]] = value;
    }

    /**
     * Get a value from the state object
     * @param {string} path - Dot-notation path
     * @returns {*} The value at that path
     */
    function getFromState(path) {
      const keys = path.split('.');
      let obj = appState;
      for (let i = 0; i < keys.length; i++) {
        obj = obj[keys[i]];
        if (obj === undefined) return undefined;
      }
      return obj;
    }

    // ============================================================================
    // PERMALINK UTILITIES
    // ============================================================================

    /**
     * Deep equality check for two values
     */
    function deepEqual(a, b) {
      if (a === b) return true;
      if (a == null || b == null) return false;
      if (typeof a !== typeof b) return false;

      if (Array.isArray(a) && Array.isArray(b)) {
        if (a.length !== b.length) return false;
        for (let i = 0; i < a.length; i++) {
          if (!deepEqual(a[i], b[i])) return false;
        }
        return true;
      }

      if (typeof a === 'object') {
        const keysA = Object.keys(a);
        const keysB = Object.keys(b);
        if (keysA.length !== keysB.length) return false;
        for (const key of keysA) {
          if (!keysB.includes(key)) return false;
          if (!deepEqual(a[key], b[key])) return false;
        }
        return true;
      }

      return false;
    }

    /**
     * Deep merge source object into target object
     */
    function deepMerge(target, source) {
      const result = { ...target };

      for (const key in source) {
        if (source.hasOwnProperty(key)) {
          if (source[key] && typeof source[key] === 'object' && !Array.isArray(source[key])) {
            result[key] = deepMerge(result[key] || {}, source[key]);
          } else {
            result[key] = source[key];
          }
        }
      }

      return result;
    }

    /**
     * Build minimal permalink payload by extracting only differences from defaults
     */
    function buildPermalinkPayload() {
      // Build overrides object with only differences from defaults
      const overrides = {};

      // Helper to add property if different from default
      function addIfDifferent(path, value, defaultValue) {
        if (!deepEqual(value, defaultValue)) {
          const keys = path.split('.');
          let obj = overrides;
          for (let i = 0; i < keys.length - 1; i++) {
            if (!obj[keys[i]]) obj[keys[i]] = {};
            obj = obj[keys[i]];
          }
          obj[keys[keys.length - 1]] = value;
        }
      }

      // Compare each top-level property
      if (appState.currentActiveTab !== defaultAppState.currentActiveTab) {
        overrides.currentActiveTab = appState.currentActiveTab;
      }

      // Filters
      const filtersOverrides = {};
      for (const key in appState.filters) {
        if (!deepEqual(appState.filters[key], defaultAppState.filters[key])) {
          filtersOverrides[key] = appState.filters[key];
        }
      }
      if (Object.keys(filtersOverrides).length > 0) {
        overrides.filters = filtersOverrides;
      }

      // Pace model
      const paceModelOverrides = {};
      for (const key in appState.paceModel) {
        if (!deepEqual(appState.paceModel[key], defaultAppState.paceModel[key])) {
          paceModelOverrides[key] = appState.paceModel[key];
        }
      }
      if (Object.keys(paceModelOverrides).length > 0) {
        overrides.paceModel = paceModelOverrides;
      }

      // Race trace
      const raceTraceOverrides = {};
      for (const key in appState.raceTrace) {
        if (!deepEqual(appState.raceTrace[key], defaultAppState.raceTrace[key])) {
          raceTraceOverrides[key] = appState.raceTrace[key];
        }
      }
      if (Object.keys(raceTraceOverrides).length > 0) {
        overrides.raceTrace = raceTraceOverrides;
      }

      // Lap time
      const lapTimeOverrides = {};
      for (const key in appState.lapTime) {
        if (!deepEqual(appState.lapTime[key], defaultAppState.lapTime[key])) {
          lapTimeOverrides[key] = appState.lapTime[key];
        }
      }
      if (Object.keys(lapTimeOverrides).length > 0) {
        overrides.lapTime = lapTimeOverrides;
      }

      // Tyre deg
      const tyreDegOverrides = {};
      for (const key in appState.tyreDeg) {
        if (key === 'selectedStints') {
          continue;
        }
        if (!deepEqual(appState.tyreDeg[key], defaultAppState.tyreDeg[key])) {
          tyreDegOverrides[key] = appState.tyreDeg[key];
        }
      }
      if (Object.keys(tyreDegOverrides).length > 0) {
        overrides.tyreDeg = tyreDegOverrides;
      }

      // Fuel effect
      const fuelEffectOverrides = {};
      for (const key in appState.fuelEffect) {
        if (key === 'selectedRows') {
          continue;
        }
        if (!deepEqual(appState.fuelEffect[key], defaultAppState.fuelEffect[key])) {
          fuelEffectOverrides[key] = appState.fuelEffect[key];
        }
      }
      if (Object.keys(fuelEffectOverrides).length > 0) {
        overrides.fuelEffect = fuelEffectOverrides;
      }

      // Pit Loss tab
      const pitLossTabOverrides = {};
      for (const key in appState.pitLossTab) {
        if (key === 'selectedKeys') {
          continue;
        }
        if (!deepEqual(appState.pitLossTab[key], defaultAppState.pitLossTab[key])) {
          pitLossTabOverrides[key] = appState.pitLossTab[key];
        }
      }
      if (Object.keys(pitLossTabOverrides).length > 0) {
        overrides.pitLossTab = pitLossTabOverrides;
      }

      // Calculator
      const calculatorOverrides = {};
      for (const key in appState.calculator) {
        if (!deepEqual(appState.calculator[key], defaultAppState.calculator[key])) {
          calculatorOverrides[key] = appState.calculator[key];
        }
      }
      if (Object.keys(calculatorOverrides).length > 0) {
        overrides.calculator = calculatorOverrides;
      }

      return {
        v: 1,
        session: {
          season: appState.session.season,
          gp: appState.session.gp,
          session: appState.session.sessionType
        },
        tab: appState.currentActiveTab,
        overrides
      };
    }

    /**
     * Encode permalink state to URL-safe base64
     */
    function encodePermalinkState(payload) {
      try {
        const json = JSON.stringify(payload);
        const base64 = btoa(json);
        // Make URL-safe: + -> -, / -> _, remove = padding
        return base64.replace(/\+/g, '-').replace(/\//g, '_').replace(/=/g, '');
      } catch (e) {
        console.error('Failed to encode permalink state:', e);
        return null;
      }
    }

    /**
     * Decode permalink state from URL-safe base64
     */
    function decodePermalinkState(encoded) {
      try {
        // Restore standard base64: - -> +, _ -> /
        let base64 = encoded.replace(/-/g, '+').replace(/_/g, '/');
        // Add padding if needed
        while (base64.length % 4) {
          base64 += '=';
        }
        const json = atob(base64);
        const payload = JSON.parse(json);

        // Validate version
        if (payload.v !== 1) {
          console.warn('Unsupported permalink version:', payload.v);
          return null;
        }

        return payload;
      } catch (e) {
        console.error('Failed to decode permalink state:', e);
        return null;
      }
    }

    /**
     * Generate permalink URL and copy to clipboard
     */
    function generateAndCopyPermalink() {
      const payload = buildPermalinkPayload();
      const encoded = encodePermalinkState(payload.overrides);

      if (encoded) {
        const params = new URLSearchParams();
        params.set('season', payload.session.season);
        params.set('gp', payload.session.gp);
        params.set('session', payload.session.session);
        params.set('tab', payload.tab);
        params.set('s', encoded);

        const permalinkURL = `${window.location.origin}${window.location.pathname}?${params.toString()}`;

        // Copy to clipboard
        navigator.clipboard.writeText(permalinkURL).then(() => {
          // Visual feedback
          const btn = document.getElementById('copyPermalinkBtn');
          const originalText = btn.textContent;
          btn.textContent = 'Copied!';
          setTimeout(() => {
            btn.textContent = originalText;
          }, 1500);
        }).catch(err => {
          console.error('Failed to copy permalink:', err);
          alert('Failed to copy permalink to clipboard');
        });
      }
    }

    /**
     * Load state from URL on page load
     */
    function loadStateFromURL() {
      const params = new URLSearchParams(window.location.search);

      // Get simple params
      const season = params.get('season');
      const gp = params.get('gp');
      const session = params.get('session');
      const tab = params.get('tab');
      const encoded = params.get('s');

      // If we have encoded state, decode and apply it
      if (encoded) {
        const payload = decodePermalinkState(encoded);
        if (payload && payload.overrides) {
          // Merge overrides into appState (but keep Sets for now, we'll convert arrays to sets later)
          const merged = deepMerge(defaultAppState, payload.overrides);

          // Apply merged values to appState, converting arrays to sets where appropriate
          Object.assign(appState.session, merged.session || {});
          Object.assign(appState.filters, merged.filters || {});
          Object.assign(appState.paceModel, merged.paceModel || {});
          Object.assign(appState.raceTrace, merged.raceTrace || {});
          Object.assign(appState.lapTime, merged.lapTime || {});
          Object.assign(appState.calculator, merged.calculator || {});

          // Handle tyre deg
          if (merged.tyreDeg) {
            Object.assign(appState.tyreDeg, merged.tyreDeg);
            if (Array.isArray(merged.tyreDeg.selectedStints)) {
              appState.tyreDeg.selectedStints = new Set(merged.tyreDeg.selectedStints);
            }
          }

          // Handle fuel effect
          if (merged.fuelEffect) {
            Object.assign(appState.fuelEffect, merged.fuelEffect);
            if (Array.isArray(merged.fuelEffect.selectedRows)) {
              appState.fuelEffect.selectedRows = new Set(merged.fuelEffect.selectedRows);
            }
          }

          // Handle pit loss selections
          if (merged.pitLossTab) {
            Object.assign(appState.pitLossTab, merged.pitLossTab);
            if (Array.isArray(merged.pitLossTab.selectedKeys)) {
              appState.pitLossTab.selectedKeys = new Set(merged.pitLossTab.selectedKeys);
            }
          }

          // Handle selected drivers
          if (Array.isArray(merged.selectedDrivers)) {
            appState.selectedDrivers = new Set(merged.selectedDrivers);
          }

          // Handle tab
          if (merged.currentActiveTab) {
            appState.currentActiveTab = merged.currentActiveTab;
          }
        }
      }

      // Override with simple params if provided (for backwards compatibility and flexibility)
      if (season) appState.session.season = season;
      if (gp) appState.session.gp = gp;
      if (session) appState.session.sessionType = session;
      if (tab) appState.currentActiveTab = tab;
    }
    
    /**
     * Restore state to UI elements from appState
     * Called after loading state from URL or storage
     */
    function restoreStateToUI() {
      renderSharedFiltersFromState();

      // Pace model / Lap time sliders
      renderPaceModelInputsFromState();

      // Lap time tab toggle buttons
      renderLapTimeToggleInputsFromState();

      // Race trace tab
      renderRaceTraceLapInputsFromState();

      // Tyre deg tab
      const tyreDegFuelEffectSlider = document.getElementById('tyreDegFuelEffectSlider');
      const tyreDegFuelEffectValue = document.getElementById('tyreDegFuelEffectValue');

      renderTyreDegToggleInputsFromState();
      if (tyreDegFuelEffectSlider) {
        tyreDegFuelEffectSlider.value = appState.paceModel.fuelEffect;
        if (tyreDegFuelEffectValue) tyreDegFuelEffectValue.textContent = appState.paceModel.fuelEffect.toFixed(3);
      }
      renderTyreDegFilterInputsFromState();

      // Calculator tab
      renderCalculatorInputsFromState();
      renderCalculatorStrategyInputsFromState();
      renderCalculatorScProbTableFromState();
    }

    /**
     * Restore data-dependent selections with validation
     * Only restores selections that exist in the current data
     */
    function restoreDataDependentSelections(panelName) {
      let selectionChanged = false;
      switch(panelName) {
        case 'race-trace':
        case 'lap-time': {
          const savedDriversArray = Array.from(appState.selectedDrivers);
          const availableDrivers = panelName === 'race-trace'
            ? Object.keys(raceTraceDriverLines)
            : Array.from(lapTimeCurrentGroups.keys());
          const availableSet = new Set(availableDrivers);
          const nextDrivers = savedDriversArray.filter(driver => availableSet.has(driver));

          if (nextDrivers.length === 0 && availableDrivers.length > 0) {
            if (panelName === 'race-trace') {
              const driverFinishInfo = availableDrivers.map(driver => {
                const data = raceTraceDriverLines[driver];
                const maxLapNum = Math.max(...data.laps);
                const lastLapIndex = data.laps.indexOf(maxLapNum);
                const lastPosition = data.positions[lastLapIndex];
                return { driver, maxLapNum, lastPosition };
              });
              const sortedDrivers = sortDriversByFinishingOrder(driverFinishInfo);
              sortedDrivers.slice(0, 5).forEach(({ driver }) => nextDrivers.push(driver));
            } else {
              const top5 = availableDrivers.slice(0, Math.min(5, availableDrivers.length));
              top5.forEach(driver => nextDrivers.push(driver));
            }
          }

          if (replaceSelectedDrivers(nextDrivers, { silent: true })) {
            selectionChanged = true;
          }
          break;
        }

        case 'tyre-deg':
          // Restore stint selections
          // appState.tyreDeg.selectedStints is already a Set, but if restored from saved state it might be an array
          const currentStintSelection = appState.tyreDeg.selectedStints;
          const savedStintsArray = Array.isArray(currentStintSelection) ? currentStintSelection : Array.from(currentStintSelection);

          // Clear and rebuild selection with only valid stints
          appState.tyreDeg.selectedStints.clear();

          const availableStintKeys = Array.from(tyreDegFilteredGroups.keys());

          // Only select stints that exist in the current filtered data
          savedStintsArray.forEach(stintKey => {
            if (availableStintKeys.includes(stintKey)) {
              appState.tyreDeg.selectedStints.add(stintKey);
            }
          });
          break;

        case 'fuel-effect':
          // Restore row selections
          // appState.fuelEffect.selectedRows is already a Set, but if restored from saved state it might be an array
          const currentRowSelection = appState.fuelEffect.selectedRows;
          const savedRowsArray = Array.isArray(currentRowSelection) ? currentRowSelection : Array.from(currentRowSelection);

          // Clear and rebuild selection with only valid rows
          appState.fuelEffect.selectedRows.clear();

          const availableRowKeys = Array.from(fuelEffectFilteredGroups.keys());

          // Only select rows that exist in the current filtered data
          savedRowsArray.forEach(rowKey => {
            if (availableRowKeys.includes(rowKey)) {
              appState.fuelEffect.selectedRows.add(rowKey);
            }
          });
          break;
      }

      if ((panelName === 'race-trace' || panelName === 'lap-time') && selectionChanged) {
        refreshDriverSelectionUI();
      }
    }

    // ============================================================================
    // TAB SWITCHING
    // ============================================================================

    function initTabNavigation() {
      const tabButtons = document.querySelectorAll('.tab-button');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const tabName = button.dataset.tab;
          switchTab(tabName);
        });
      });
    }

    function switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
      });

      // Update panels
      document.querySelectorAll('.content-panel').forEach(panel => {
        panel.classList.remove('active');
      });
      document.getElementById(`${tabName}-panel`).classList.add('active');

      // Hide strategy container when switching away from strategy
      if (tabName !== 'strategy') {
        strategyContainer.classList.remove('show');
      }

      appState.currentActiveTab = tabName;

      // Initialize panel if data is available
      if (currentSessionData) {
        initializePanel(tabName, currentSessionData);
      }
    }

    function initializePanel(panelName, sessionData) {
      if (!sessionData || sessionData.length === 0) return;

      // Get current session info
      const year = appState.session.season;
      const [round, meeting] = appState.session.gp.split('||');
      const sessionType = appState.session.sessionType;

      switch(panelName) {
        case 'strategy':
          renderStrategyChart(sessionData, year, round, sessionType);
          break;
        case 'race-trace':
          raceTraceCurrentSessionRows = sessionData;
          raceTraceYear = year;
          raceTraceRound = round;
          raceTraceSessionType = sessionType;
          raceTraceDriverColors = DriverInfo.getDriverColors(year, round, sessionType);
          const lapNumbers = sessionData.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n));
          const minLapNum = Math.min(...lapNumbers);
          const maxLapNum = Math.max(...lapNumbers);

          setRaceTraceLapBounds(minLapNum, maxLapNum);

          const hasSavedRange = (appState.raceTrace.lapMin !== 1 || appState.raceTrace.lapMax !== 1);
          let nextMin = hasSavedRange ? appState.raceTrace.lapMin : minLapNum;
          let nextMax = hasSavedRange ? appState.raceTrace.lapMax : maxLapNum;

          nextMin = Math.max(minLapNum, Math.min(nextMin ?? minLapNum, maxLapNum));
          nextMax = Math.max(nextMin, Math.min(nextMax ?? maxLapNum, maxLapNum));

          appState.raceTrace.lapMin = nextMin;
          appState.raceTrace.lapMax = nextMax;
          renderRaceTraceLapInputsFromState();
          calculateRaceTraceGaps(sessionData);
          buildRaceTraceDriverList();

          // Restore driver selections from state AFTER building the list
          // (so raceTraceDriverLines is populated)
          if (appState.selectedDrivers.size === 0) {
            restoreDataDependentSelections('race-trace');
          }

          renderRaceTraceChart();
          break;
        case 'lap-time':
          // Initialize lap time panel
          lapTimeCurrentSessionRows = sessionData;
          lapTimeYear = year;
          lapTimeRound = round;
          lapTimeSessionType = sessionType;
          lapTimeDriverColors = DriverInfo.getDriverColors(year, round, sessionType);
          lapTimeScheduledLaps = sessionData.length > 0 ? parseInt(sessionData[0].sched_laps) : null;
          if (isNaN(lapTimeScheduledLaps)) {
            lapTimeScheduledLaps = null;
          }

          // Circuit config is now applied once per session in onSessionChange()

          // Process lap time data with shared filters
          processLapTimeData(sessionData);

          // Restore driver selections from state AFTER processing data
          // (so lapTimeCurrentGroups is populated)
          if (appState.selectedDrivers.size === 0 && lapTimeCurrentGroups.size > 0) {
            restoreDataDependentSelections('lap-time');
            // Re-render to show the selected drivers
            const drivers = Array.from(lapTimeCurrentGroups.keys());
            buildLapTimeDriversList(drivers);
            renderLapTimeChart();
            renderLapTimeSummaryTable();
          }
          break;
        case 'tyre-deg':
          // Initialize tyre deg panel
          // Clear previous stints tracker for event change detection
          // Note: Don't clear appState.tyreDeg.selectedStints here - it may contain
          // selections restored from URL. Let processTyreDegData handle selection logic.
          window.tyreDegPreviousFilteredStints = [];

          // Display tyre choices for the selected event
          const tyreKey = `${year}||${round}`;
          const tyres = tyreDegTyreChoices.get(tyreKey);
          if (tyres && tyres.hard && tyres.medium && tyres.soft) {
            tyreDegTyreChoicesText.textContent = `${tyres.hard}-${tyres.medium}-${tyres.soft}`;
            tyreDegTyreChoicesDisplay.style.display = 'flex';
          } else {
            tyreDegTyreChoicesDisplay.style.display = 'none';
          }

          processTyreDegData(sessionData);
          break;
        case 'fuel-effect':
          // Initialize fuel effect panel
          processFuelEffectData(sessionData, { restoreSelections: true });
          break;
        case 'pit-loss':
          processPitLossData(sessionData);
          break;
        case 'calculator':
          // Initialize calculator panel
          initializeCalculatorPanel(sessionData);
          break;
      }
    }

    // ============================================================================
    // SHARED DATA LOADING
    // ============================================================================

    function init() {
      // Load state from URL first (before restoring to UI)
      loadStateFromURL();

      // Restore UI elements from appState
      restoreStateToUI();

      initializeSpoilerStateFromCookie();
      setupSpoilerEventListeners();
      if (!spoilerDecisionResolved) {
        openSpoilerOverlay();
      }
      updateSpoilerModeButtonState();

      initTabNavigation();

      // Set up reload data button
      reloadDataBtn.addEventListener('click', () => {
        DataCache.reloadData();
      });

      // Set up copy permalink button
      const copyPermalinkBtn = document.getElementById('copyPermalinkBtn');
      copyPermalinkBtn.addEventListener('click', generateAndCopyPermalink);

      DriverInfo.load(loadMainCSV);

      switchTab(appState.currentActiveTab);
    }

    function loadMainCSV() {
      ParsedDataCache.loadCSV("all_df.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRowsRaw = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.session_type !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRowsRaw.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          indexSessions(allRowsRaw, fullSessionsByKey);
          rawDataReady = true;
          const prefs = getSpoilerPreferenceValues();
          populateSpoilerSeasonOptions(prefs.season, prefs.gp, prefs.sessionType);

          const shouldRestore = Boolean(appState.session.season || appState.session.gp || appState.session.sessionType);
          pendingSessionRestore = shouldRestore;
          if (shouldRestore) {
            window.permalinkSession = { isRestoring: true };
          }

          maybeInitializeAfterPrereqs();
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      seasonSel.addEventListener("change", onSeasonChange);
      gpSel.addEventListener("change", onGPChange);
      sessionSel.addEventListener("change", onSessionChange);
    }

    function indexSessions(rows, targetMap = sessionsByKey) {
      targetMap.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const sessionType = String(r.session_type || "").trim();
        const circuit = String(r.circuit_name || "").trim();
        if (!year || !round || !meeting || !sessionType || !circuit) return;

        const key = `${year}||${round}||${meeting}||${sessionType}`;
        if (!targetMap.has(key)) {
          targetMap.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            session_type: sessionType,
            circuit_name: circuit
          });
        }
      });
    }

    

    function onSeasonChange() {
      const selectedSeason = seasonSel.value;

      // Only update appState if not currently restoring from permalink
      if (!window.permalinkSession || !window.permalinkSession.isRestoring) {
        appState.session.season = selectedSeason;
      }

      sessionSel.innerHTML = '';
      sessionSel.disabled = true;

      currentSessionData = null;

      UIHelpers.populateGPs(gpSel, sessionsByKey, selectedSeason, {
        // onChange: onGPChange
      });

      // Restore GP from appState if restoring from permalink
      if (window.permalinkSession && window.permalinkSession.isRestoring && appState.session.gp) {
        const gp = appState.session.gp;
        const gpOption = gpSel.querySelector(`option[value="${gp}"]`);
        if (gpOption) {
          gpSel.value = gp;
          
        } else {
          console.warn('Permalink GP not found in dropdown:', gp);
        }
      };
      onGPChange();
    }

    function onGPChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;

      // Only update appState if not currently restoring from permalink
      if (!window.permalinkSession || !window.permalinkSession.isRestoring) {
        appState.session.gp = selectedGP;
      }

      currentSessionData = null;

      UIHelpers.populateSessions(sessionSel, sessionsByKey, selectedSeason, selectedGP, {
        // onChange: onSessionChange
      });

      // Restore session from appState if restoring from permalink
      if (window.permalinkSession && window.permalinkSession.isRestoring && appState.session.sessionType) {
        const session = appState.session.sessionType;
        const sessionOption = sessionSel.querySelector(`option[value="${session}"]`);
        if (sessionOption) {
          sessionSel.value = session;
          
        } else {
          console.warn('Permalink session not found in dropdown:', session);
        }
      };
      onSessionChange();
    }

    function onSessionChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      // Only update appState if not currently restoring from permalink
      if (!window.permalinkSession || !window.permalinkSession.isRestoring) {
        appState.session.sessionType = selectedSession;
      }

      if (!selectedSeason || !selectedGP || !selectedSession) {
        currentSessionData = null;
        return;
      }

      const [round, meeting] = selectedGP.split('||');

      // Filter data for this session (shared across all tabs)
      currentSessionData = allRows.filter(r => {
        return String(r.year || "").trim() === selectedSeason &&
               String(r.round_no || "").trim() === round &&
               String(r.meeting_name || "").trim() === meeting &&
               String(r.session_type || "").trim() === selectedSession;
      });

      // Clear selected drivers when a new session is selected (unless restoring from permalink)
      if (!window.permalinkSession || !window.permalinkSession.isRestoring) {
        appState.selectedDrivers.clear();
      }

      // Apply circuit config once for the new session (before initializing any panels)
      // Only apply config values if appState still has default values (not overridden by URL params)
      const circuitName = currentSessionData.length > 0 ? String(currentSessionData[0].circuit_name || "").trim() : "";
      applyPaceModelDefaultsForCircuit(circuitName);

      // Initialize the currently active panel with new data
      if (currentSessionData.length > 0) {
        initializePanel(appState.currentActiveTab, currentSessionData);
      }

      // Restore tab if we're restoring from permalink and tab is different from current
      if (window.permalinkSession && window.permalinkSession.isRestoring) {
        const tab = appState.currentActiveTab;
        // Get the default tab name (what the page loads to)
        const currentlyActiveTab = document.querySelector('.tab-button.active')?.dataset.tab || 'strategy';
        if (tab && tab !== currentlyActiveTab) {
          switchTab(tab);
        }
        // Note: Don't clear isRestoring flag here - it's cleared after explicit restoration completes
      }
    }

    // ============================================================================
    // PANEL-SPECIFIC CODE SECTIONS
    // ============================================================================

    // Strategy Panel
    const strategyChart = document.getElementById('strategyChart');
    const strategyContainer = document.getElementById('strategyContainer');
    const lapAxisTop = document.getElementById('lapAxisTop');
    const lapAxisBottom = document.getElementById('lapAxisBottom');
    const tooltip = document.getElementById('tooltip');

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();
      const colorMap = {
        'soft': '#FF0000',
        'medium': '#FFF200',
        'hard': '#FFFFFF',
        'intermediate': '#00FF00',
        'wet': '#0000FF'
      };
      return colorMap[compoundLower] || '#999999';
    }

    function updateTooltipPosition(e) {
      const x = e.clientX;
      const y = e.clientY;
      tooltip.style.left = `${x + 15}px`;
      tooltip.style.top = `${y + 15}px`;
    }

    function renderStrategyChart(rows, year, round, sessionType) {
      // Get driver colors for this specific session
      const driverColors = DriverInfo.getDriverColors(year, round, sessionType);

      // Group by driver
      const driverData = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNum = parseInt(r.lap_LapNumber);
        const stint = parseInt(r.lap_Stint);
        const compound = String(r.lap_Compound || "").trim();
        const gridPos = parseInt(r.grid_position);
        const tyreLife = parseInt(r.lap_TyreLife);
        const position = parseInt(r.lap_Position);

        if (!driver || isNaN(lapNum)) return;

        if (!driverData.has(driver)) {
          driverData.set(driver, {
            driver: driver,
            gridPosition: gridPos,
            laps: new Map(),
            stints: new Map(),
            maxLapNum: 0,
            lastPosition: null
          });
        }

        const data = driverData.get(driver);
        data.laps.set(lapNum, { compound, stint, tyreLife, position });

        // Track max lap number and position on that lap
        if (lapNum > data.maxLapNum) {
          data.maxLapNum = lapNum;
          data.lastPosition = position;
        }

        if (!data.stints.has(stint)) {
          data.stints.set(stint, {
            compound: compound,
            startLap: lapNum,
            endLap: lapNum,
            startTyreLife: tyreLife
          });
        } else {
          const stintData = data.stints.get(stint);
          if (lapNum < stintData.startLap) {
            stintData.startLap = lapNum;
            stintData.startTyreLife = tyreLife;
          }
          if (lapNum > stintData.endLap) {
            stintData.endLap = lapNum;
          }
        }
      });

      // Get max lap number (scheduled laps)
      const schedLaps = parseInt(rows[0]?.sched_laps || 0);
      const maxLap = schedLaps > 0 ? schedLaps : Math.max(...Array.from(driverData.values()).flatMap(d => Array.from(d.laps.keys())));

      // Sort drivers by finishing position using shared utility
      const sortedDrivers = sortDriversByFinishingOrder(Array.from(driverData.values()));

      // Clear chart
      strategyChart.innerHTML = '';

      // Render driver rows
      sortedDrivers.forEach(data => {
        const row = document.createElement('div');
        row.className = 'driver-row';

        const label = document.createElement('div');
        label.className = 'driver-label';
        label.textContent = data.driver;

        // Apply driver color if available
        const driverColor = driverColors.get(data.driver);
        if (driverColor) {
          label.style.color = driverColor;
        }

        const bar = document.createElement('div');
        bar.className = 'strategy-bar';

        // Build stint segments
        const sortedStints = Array.from(data.stints.values()).sort((a, b) => a.startLap - b.startLap);

        sortedStints.forEach((stint, idx) => {
          const segment = document.createElement('div');
          segment.className = 'stint-segment';
          const stintLaps = stint.endLap - stint.startLap + 1;
          const widthPercent = (stintLaps / maxLap) * 100;
          segment.style.width = `${widthPercent}%`;
          segment.style.backgroundColor = getF1TireColor(stint.compound);

          // Add tooltip
          segment.addEventListener('mouseenter', (e) => {
            const info = DriverInfo.getDriverInfo(data.driver, year, round, sessionType);
            const tyreAgeText = !isNaN(stint.startTyreLife) ? `Tyre age at start: ${stint.startTyreLife} laps` : '';

            if (info && info.headshotUrl) {
              const fullName = info.fullName || data.driver;
              const teamName = info.teamName || '';
              const stintInfo = `
                <div style="margin-top:4px">Stint ${idx + 1}: ${stint.compound}</div>
                <div>Laps ${stint.startLap}-${stint.endLap} (${stintLaps} laps)</div>
                ${tyreAgeText ? `<div>${tyreAgeText}</div>` : ''}
              `;
              tooltip.innerHTML = `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${data.driver})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${stintInfo}
                  </div>
                </div>
              `;
            } else {
              tooltip.innerHTML = `
                <strong>${data.driver}</strong><br/>
                Stint ${idx + 1}: ${stint.compound}<br/>
                Laps ${stint.startLap}-${stint.endLap} (${stintLaps} laps)${tyreAgeText ? `<br/>${tyreAgeText}` : ''}
              `;
            }
            tooltip.classList.add('show');
            updateTooltipPosition(e);
          });

          segment.addEventListener('mousemove', updateTooltipPosition);

          segment.addEventListener('mouseleave', () => {
            tooltip.classList.remove('show');
          });

          bar.appendChild(segment);
        });

        // Add missing laps if driver didn't complete all laps
        const lastLap = Math.max(...Array.from(data.laps.keys()));
        if (lastLap < maxLap) {
          const missingLaps = maxLap - lastLap;
          const widthPercent = (missingLaps / maxLap) * 100;
          const missing = document.createElement('div');
          missing.className = 'missing-laps';
          missing.style.width = `${widthPercent}%`;
          bar.appendChild(missing);
        }

        row.appendChild(label);
        row.appendChild(bar);
        strategyChart.appendChild(row);
      });

      // Render lap axes
      renderLapAxis(maxLap);

      // Show the container
      strategyContainer.classList.add('show');
    }

    function renderLapAxis(maxLap) {
      lapAxisTop.innerHTML = '';
      lapAxisBottom.innerHTML = '';

      // Create tick marks at intervals
      const interval = maxLap > 50 ? 10 : 5;

      for (let lap = 0; lap <= maxLap; lap += interval) {
        // Top axis
        const tickTop = document.createElement('div');
        tickTop.className = 'lap-tick';
        const position = (lap / maxLap) * 100;
        tickTop.style.left = `${position}%`;
        lapAxisTop.appendChild(tickTop);

        const labelTop = document.createElement('div');
        labelTop.className = 'lap-label';
        labelTop.textContent = lap;
        labelTop.style.left = `${position}%`;
        lapAxisTop.appendChild(labelTop);

        // Bottom axis
        const tickBottom = document.createElement('div');
        tickBottom.className = 'lap-tick';
        tickBottom.style.left = `${position}%`;
        lapAxisBottom.appendChild(tickBottom);

        const labelBottom = document.createElement('div');
        labelBottom.className = 'lap-label';
        labelBottom.textContent = lap;
        labelBottom.style.left = `${position}%`;
        lapAxisBottom.appendChild(labelBottom);
      }
    }

    // Race Trace Panel
    const raceTraceLapMin = document.getElementById('raceTraceLapMin');
    const raceTraceLapMax = document.getElementById('raceTraceLapMax');
    const raceTraceDriverList = document.getElementById('raceTraceDriverList');
    const raceTraceDebugInfo = document.getElementById('raceTraceDebugInfo');

let raceTraceDriverLines = {};
let raceTraceChart = null;
let raceTraceCurrentSessionRows = [];
let raceTraceDriverColors = new Map();
let raceTraceYear = '';
let raceTraceRound = '';
let raceTraceSessionType = '';
let raceTraceAvailableDrivers = [];
let lapTimeAvailableDrivers = [];
let raceTraceDriverManager = null;
let lapTimeDriverManager = null;
let lapTimeSummaryCheckboxManager = null;
let tyreDegSelectionManager = null;
let fuelEffectSelectionManager = null;
let raceTraceDriverDisplayData = [];
let lapTimeDriverDisplayData = [];

function setsAreEqual(a, b) {
  if (a.size !== b.size) return false;
  for (const value of a) {
    if (!b.has(value)) return false;
  }
  return true;
}

function refreshDriverSelectionUI() {
  if (Object.keys(raceTraceDriverLines).length > 0) {
    buildRaceTraceDriverList();
  }
  if (lapTimeAvailableDrivers.length > 0) {
    buildLapTimeDriversList();
  }
  if (Object.keys(raceTraceDriverLines).length > 0) {
    renderRaceTraceChart();
  }
  if (lapTimeCurrentGroups.size > 0) {
    renderLapTimeChart();
    renderLapTimeSummaryTable();
  }
}

function commitSelectedDrivers(nextSet, options = {}) {
  if (!(nextSet instanceof Set)) {
    nextSet = new Set(nextSet);
  }
  if (setsAreEqual(appState.selectedDrivers, nextSet)) {
    return false;
  }
  appState.selectedDrivers = nextSet;
  if (!options.silent) {
    refreshDriverSelectionUI();
  }
  return true;
}

function updateSelectedDrivers(mutator, options = {}) {
  const next = new Set(appState.selectedDrivers);
  mutator(next);
  commitSelectedDrivers(next, options);
}

    function replaceSelectedDrivers(drivers, options = {}) {
      return commitSelectedDrivers(new Set(drivers), options);
    }

    class CheckboxManager {
      constructor(options = {}) {
        this.container = options.container || null;
        this.selectAllId = options.selectAllId || null;
        this.itemsSource = options.itemsSource || (() => []);
        this.getSelectionSet = options.getSelectionSet || (() => options.selectionState || new Set());
        this.selectionUpdater = options.selectionUpdater || (mutator => {
          const set = this.getSelectionSet();
          if (set) mutator(set);
        });
        this.onSelectionChange = options.onSelectionChange || (() => {});
        this.getItemKey = options.getItemKey || (item => item);
        this.updateItemAppearance = options.updateItemAppearance || null;
        this.structureBuilder = options.buildStructure || null;
        this.pendingStructure = null;
      }

      setStructure(structure) {
        this.pendingStructure = structure;
      }

      buildStructure() {
        if (this.pendingStructure) {
          const structure = this.pendingStructure;
          this.pendingStructure = null;
          return structure;
        }
        if (typeof this.structureBuilder === 'function') {
          return this.structureBuilder();
        }
        return this.buildStructureFromOptions();
      }

      buildStructureFromOptions() {
        return { items: [], selectAllElement: null };
      }

      render() {
        const { items, selectAllElement } = this.buildStructure();
        this.items = Array.isArray(items) ? items : [];
        this.selectAllElement = selectAllElement || null;
        this.attachListeners();
        this.syncCheckboxStates();
        this.updateSelectAllState();
      }

      attachListeners() {
        if (this.selectAllElement) {
          this.selectAllElement.addEventListener('change', (e) => {
            this.handleSelectAll(e.target.checked);
          });
        }
        this.items.forEach(item => {
          if (item.checkbox) {
            item.checkbox.addEventListener('change', (e) => {
              this.handleItemToggle(item, e.target.checked);
            });
          }
        });
      }

      handleSelectAll(checked) {
        const keys = this.items.map(item => item.key);
        this.selectionUpdater(set => {
          keys.forEach(key => {
            if (checked) {
              set.add(key);
            } else {
              set.delete(key);
            }
          });
        });
        this.onSelectionChange({ type: 'selectAll', checked });
        this.syncCheckboxStates();
        this.updateSelectAllState();
      }

      handleItemToggle(item, checked) {
        this.selectionUpdater(set => {
          if (checked) {
            set.add(item.key);
          } else {
            set.delete(item.key);
          }
        });
        this.onSelectionChange({ key: item.key, checked });
        this.syncCheckboxStates();
        this.updateSelectAllState();
      }

      syncCheckboxStates() {
        const selection = this.getSelectionSet() || new Set();
        this.items.forEach(item => {
          const isSelected = selection.has(item.key);
          if (item.checkbox) {
            item.checkbox.checked = isSelected;
          }
          if (typeof this.updateItemAppearance === 'function') {
            this.updateItemAppearance(item, isSelected);
          } else if (item.rowElement && this.selectAllId === null) {
            item.rowElement.classList.toggle('selected', isSelected);
          }
        });
      }

      updateSelectAllState() {
        if (!this.selectAllElement || !this.items) return;
        const selection = this.getSelectionSet() || new Set();
        const total = this.items.length;
        if (total === 0) {
          this.selectAllElement.checked = false;
          this.selectAllElement.indeterminate = false;
          return;
        }
        const selectedCount = this.items.filter(item => selection.has(item.key)).length;
        this.selectAllElement.checked = selectedCount === total;
        this.selectAllElement.indeterminate = selectedCount > 0 && selectedCount < total;
      }
    }

    class DriverSelectionManager extends CheckboxManager {
      constructor(options = {}) {
        super({
          ...options,
          getSelectionSet: options.getSelectionSet || (() => appState.selectedDrivers),
          selectionUpdater: options.selectionUpdater || (mutator => updateSelectedDrivers(mutator))
        });
        this.container = options.container;
        this.itemsSource = options.itemsSource || (() => []);
        this.selectAllId = options.selectAllId;
        this.selectAllLabel = options.selectAllLabel || 'Select All';
        this.rowTag = options.rowTag || 'div';
        this.rowClass = options.rowClass || '';
        this.selectAllClass = options.selectAllClass || '';
        this.inputIdPrefix = options.inputIdPrefix || 'driver';
      }

      buildStructure() {
        const container = this.container;
        if (!container) {
          return { items: [], selectAllElement: null };
        }
        const drivers = this.itemsSource ? this.itemsSource() : [];
        container.innerHTML = '';
        if (!drivers || drivers.length === 0) {
          return { items: [], selectAllElement: null };
        }

        const selectAllWrapper = document.createElement(this.rowTag === 'label' ? 'label' : 'div');
        selectAllWrapper.className = this.selectAllClass;
        selectAllWrapper.style.borderBottom = '1px solid var(--border-color)';
        selectAllWrapper.style.marginBottom = '8px';
        selectAllWrapper.style.paddingBottom = '8px';
        const selectAllCheckbox = document.createElement('input');
        selectAllCheckbox.type = 'checkbox';
        selectAllCheckbox.id = this.selectAllId;
        const selectAllLabel = document.createElement(this.rowTag === 'label' ? 'span' : 'label');
        selectAllLabel.textContent = this.selectAllLabel;
        selectAllLabel.style.fontWeight = '600';
        if (selectAllLabel.tagName.toLowerCase() === 'label') {
          selectAllLabel.htmlFor = this.selectAllId;
        }
        selectAllWrapper.appendChild(selectAllCheckbox);
        selectAllWrapper.appendChild(selectAllLabel);
        container.appendChild(selectAllWrapper);

        const items = [];
        drivers.forEach(driver => {
          const wrapper = document.createElement(this.rowTag);
          wrapper.className = this.rowClass;
          if (this.rowTag === 'label') {
            wrapper.htmlFor = `${this.inputIdPrefix}-${driver.key}`;
          }

          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = `${this.inputIdPrefix}-${driver.key}`;
          if (driver.color) {
            checkbox.style.accentColor = driver.color;
          }

          const labelEl = document.createElement(this.rowTag === 'label' ? 'span' : 'label');
          if (labelEl.tagName.toLowerCase() === 'label') {
            labelEl.htmlFor = checkbox.id;
          }
          labelEl.textContent = driver.label;
          if (driver.color) {
            labelEl.style.color = driver.color;
          }

          wrapper.appendChild(checkbox);
          wrapper.appendChild(labelEl);
          container.appendChild(wrapper);
          items.push({ key: driver.key, checkbox });
        });

        return { items, selectAllElement: selectAllCheckbox };
      }
    }

    class TableCheckboxManager extends CheckboxManager {
      constructor(options = {}) {
        super({
          ...options,
          updateItemAppearance: options.updateItemAppearance || ((item, isSelected) => {
            if (options.selectedClass && item.rowElement) {
              item.rowElement.classList.toggle(options.selectedClass, isSelected);
            }
          })
        });
      }
    }
        let raceTraceLapBounds = { min: 1, max: 1 };

    const DEFAULT_SC_PROB_RANGES = [
      { from: '1', to: '1', prob: '26.1' },
      { from: '2', to: '2', prob: '4.9' },
      { from: '3', to: '3', prob: '3.3' },
      { from: '4', to: '', prob: '1.6' }
    ];

    function cloneDefaultScProbRanges() {
      return DEFAULT_SC_PROB_RANGES.map(range => ({ ...range }));
    }

    function renderPaceModelInputsFromState(options = {}) {
      const skipSet = new Set(options.skip || []);
      const degHard = document.getElementById('degHard');
      const degHardValue = document.getElementById('degHardValue');
      const degMedium = document.getElementById('degMedium');
      const degMediumValue = document.getElementById('degMediumValue');
      const degSoft = document.getElementById('degSoft');
      const degSoftValue = document.getElementById('degSoftValue');
      const fuelEffect = document.getElementById('fuelEffect');
      const fuelEffectValue = document.getElementById('fuelEffectValue');
      const tyreDegFuelEffectSlider = document.getElementById('tyreDegFuelEffectSlider');
      const tyreDegFuelEffectValue = document.getElementById('tyreDegFuelEffectValue');
      const calculatorFuelEffect = document.getElementById('calculatorFuelEffect');

      if (degHard) {
        if (!skipSet.has('degHard')) {
          degHard.value = appState.paceModel.degHard;
        }
        if (degHardValue) degHardValue.textContent = appState.paceModel.degHard.toFixed(3);
      }
      if (degMedium) {
        if (!skipSet.has('degMedium')) {
          degMedium.value = appState.paceModel.degMedium;
        }
        if (degMediumValue) degMediumValue.textContent = appState.paceModel.degMedium.toFixed(3);
      }
      if (degSoft) {
        if (!skipSet.has('degSoft')) {
          degSoft.value = appState.paceModel.degSoft;
        }
        if (degSoftValue) degSoftValue.textContent = appState.paceModel.degSoft.toFixed(3);
      }
      if (fuelEffect) {
        if (!skipSet.has('fuelEffect')) {
          fuelEffect.value = appState.paceModel.fuelEffect;
        }
        if (fuelEffectValue) fuelEffectValue.textContent = appState.paceModel.fuelEffect.toFixed(3);
      }
      if (tyreDegFuelEffectSlider) {
        tyreDegFuelEffectSlider.value = appState.paceModel.fuelEffect;
        if (tyreDegFuelEffectValue) tyreDegFuelEffectValue.textContent = appState.paceModel.fuelEffect.toFixed(3);
      }
      if (calculatorFuelEffect && !skipSet.has('calculatorFuelEffect')) {
        calculatorFuelEffect.value = appState.paceModel.fuelEffect;
      }
      if (calculatorDegS && !skipSet.has('calculatorDegS')) calculatorDegS.value = appState.paceModel.degSoft;
      if (calculatorDegM && !skipSet.has('calculatorDegM')) calculatorDegM.value = appState.paceModel.degMedium;
      if (calculatorDegH && !skipSet.has('calculatorDegH')) calculatorDegH.value = appState.paceModel.degHard;
    }

    function renderLapTimeToggleInputsFromState(options = {}) {
      const skipSet = new Set(options.skip || []);
      const fuelToggle = document.getElementById('fuelAdjustToggle');
      const tyreLifeToggle = document.getElementById('tyreLifeAdjustToggle');

      if (fuelToggle && !skipSet.has('fuelAdjustToggle')) {
        fuelToggle.classList.toggle('active', !!appState.lapTime.fuelAdjust);
      }
      if (tyreLifeToggle && !skipSet.has('tyreLifeAdjustToggle')) {
        tyreLifeToggle.classList.toggle('active', !!appState.lapTime.tyreLifeAdjust);
      }
    }

    function renderTyreDegToggleInputsFromState(options = {}) {
      const skipSet = new Set(options.skip || []);
      const tyreDegFuelToggle = document.getElementById('tyreDegFuelAdjustToggle');
      if (tyreDegFuelToggle && !skipSet.has('tyreDegFuelAdjustToggle')) {
        tyreDegFuelToggle.classList.toggle('active', !!appState.tyreDeg.fuelAdjust);
      }
    }

    function renderTyreDegFilterInputsFromState() {
      const tyreDegFilterMinRows = document.getElementById('tyreDegFilterMinRows');
      const tyreDegFilterMinCorr = document.getElementById('tyreDegFilterMinCorr');
      if (tyreDegFilterMinRows) {
        const val = appState.tyreDeg.filterMinRows;
        tyreDegFilterMinRows.value = (val === null || val === undefined) ? '' : val;
      }
      if (tyreDegFilterMinCorr) {
        const val = appState.tyreDeg.filterMinCorr;
        tyreDegFilterMinCorr.value = (val === null || val === undefined) ? '' : val;
      }
    }

    function renderCalculatorInputsFromState(options = {}) {
      const skipSet = new Set(options.skip || []);
      const calculatorPitLoss = document.getElementById('calculatorPitLoss');
      const calculatorScLength = document.getElementById('calculatorScLength');
      const calculatorNumLaps = document.getElementById('calculatorNumLaps');
      const calculatorPaceS = document.getElementById('calculatorPaceS');
      const calculatorPaceM = document.getElementById('calculatorPaceM');
      const calculatorPaceH = document.getElementById('calculatorPaceH');
      const calculatorDegS = document.getElementById('calculatorDegS');
      const calculatorDegM = document.getElementById('calculatorDegM');
      const calculatorDegH = document.getElementById('calculatorDegH');

      if (calculatorNumLaps && !skipSet.has('calculatorNumLaps')) {
        const value = appState.calculator.numLaps;
        calculatorNumLaps.value = value === null || value === undefined ? '' : value;
      }

      if (calculatorPitLoss && !skipSet.has('calculatorPitLoss')) {
        const value = appState.calculator.pitLoss;
        calculatorPitLoss.value = value === null || value === undefined ? '' : value;
      }

      if (calculatorScLength && !skipSet.has('calculatorScLength')) {
        const value = appState.calculator.scLength;
        calculatorScLength.value = value === null || value === undefined ? '' : value;
      }

      if (calculatorPaceS && !skipSet.has('calculatorPaceS')) {
        const value = appState.calculator.paceS;
        calculatorPaceS.value = value === null || value === undefined ? '' : value;
      }
      if (calculatorPaceM && !skipSet.has('calculatorPaceM')) {
        const value = appState.calculator.paceM;
        calculatorPaceM.value = value === null || value === undefined ? '' : value;
      }
      if (calculatorPaceH && !skipSet.has('calculatorPaceH')) {
        const value = appState.calculator.paceH;
        calculatorPaceH.value = value === null || value === undefined ? '' : value;
      }
      if (calculatorDegS && !skipSet.has('calculatorDegS')) calculatorDegS.value = appState.paceModel.degSoft;
      if (calculatorDegM && !skipSet.has('calculatorDegM')) calculatorDegM.value = appState.paceModel.degMedium;
      if (calculatorDegH && !skipSet.has('calculatorDegH')) calculatorDegH.value = appState.paceModel.degHard;
    }

    function renderCalculatorStrategyInputsFromState() {
      const inputs = document.querySelectorAll('.calculatorStrategyInput');
      let strategies = Array.isArray(appState.calculator.strategies)
        ? appState.calculator.strategies
        : [];
      if (strategies.length < inputs.length) {
        strategies = strategies.slice();
        while (strategies.length < inputs.length) {
          strategies.push('');
        }
        saveToState('calculator.strategies', strategies);
      }
      inputs.forEach((input, idx) => {
        input.value = strategies[idx] || '';
      });
    }

    function ensureCalculatorScProbRangesInitialized() {
      if (!Array.isArray(appState.calculator.scProbRanges) || appState.calculator.scProbRanges.length === 0) {
        const defaults = cloneDefaultScProbRanges();
        saveToState('calculator.scProbRanges', defaults);
        return defaults;
      }
      return appState.calculator.scProbRanges;
    }

    function renderCalculatorScProbTableFromState() {
      const tbody = document.querySelector('#calculatorScProbTable tbody');
      if (!tbody) return;
      const ranges = ensureCalculatorScProbRangesInitialized();
      tbody.innerHTML = '';
      ranges.forEach((range, index) => {
        const tr = document.createElement('tr');

        const fromTd = document.createElement('td');
        const fromInput = document.createElement('input');
        fromInput.className = 'calculator-field-input calcFromLap';
        fromInput.type = 'number';
        fromInput.min = '1';
        fromInput.value = range.from ?? '';
        fromInput.addEventListener('input', (e) => updateCalculatorScProbRange(index, 'from', e.target.value));
        fromTd.appendChild(fromInput);

        const toTd = document.createElement('td');
        const toInput = document.createElement('input');
        toInput.className = 'calculator-field-input calcToLap';
        toInput.type = 'number';
        toInput.min = '1';
        toInput.value = range.to ?? '';
        toInput.addEventListener('input', (e) => updateCalculatorScProbRange(index, 'to', e.target.value));
        toTd.appendChild(toInput);

        const probTd = document.createElement('td');
        const probInput = document.createElement('input');
        probInput.className = 'calculator-field-input calcProb';
        probInput.type = 'number';
        probInput.step = '0.1';
        probInput.min = '0';
        probInput.max = '100';
        probInput.value = range.prob ?? '';
        probInput.addEventListener('input', (e) => updateCalculatorScProbRange(index, 'prob', e.target.value));
        probTd.appendChild(probInput);

        const deleteTd = document.createElement('td');
        const deleteBtn = document.createElement('button');
        deleteBtn.type = 'button';
        deleteBtn.className = 'calculator-btn-small calcDeleteRangeBtn';
        deleteBtn.textContent = '✕';
        deleteBtn.addEventListener('click', () => removeCalculatorScProbRange(index));
        deleteTd.appendChild(deleteBtn);

        tr.appendChild(fromTd);
        tr.appendChild(toTd);
        tr.appendChild(probTd);
        tr.appendChild(deleteTd);
        tbody.appendChild(tr);
      });
    }

    function updateCalculatorScProbRange(index, field, value) {
      const ranges = Array.isArray(appState.calculator.scProbRanges)
        ? appState.calculator.scProbRanges.slice()
        : [];
      if (!ranges[index]) return;
      ranges[index] = { ...ranges[index], [field]: value };
      saveToState('calculator.scProbRanges', ranges);
      renderCalculatorScProbTableFromState();
    }

    function addCalculatorScProbRow(initial = { from: '', to: '', prob: '' }) {
      const ranges = Array.isArray(appState.calculator.scProbRanges)
        ? appState.calculator.scProbRanges.slice()
        : [];
      ranges.push({
        from: initial.from ?? '',
        to: initial.to ?? '',
        prob: initial.prob ?? ''
      });
      saveToState('calculator.scProbRanges', ranges);
      renderCalculatorScProbTableFromState();
    }

    function removeCalculatorScProbRange(index) {
      const ranges = Array.isArray(appState.calculator.scProbRanges)
        ? appState.calculator.scProbRanges.slice()
        : [];
      if (ranges.length === 0) return;
      ranges.splice(index, 1);
      if (ranges.length === 0) {
        ranges.push({ from: '', to: '', prob: '' });
      }
      saveToState('calculator.scProbRanges', ranges);
      renderCalculatorScProbTableFromState();
    }

    function getCalculatorScProbRangesFromState() {
      const ranges = Array.isArray(appState.calculator.scProbRanges)
        ? appState.calculator.scProbRanges
        : [];
      const parsed = [];
      ranges.forEach(range => {
        const fromVal = String(range.from ?? '').trim();
        const toVal = String(range.to ?? '').trim();
        const probVal = String(range.prob ?? '').trim();
        if (!fromVal || !probVal) return;
        const fromLap = parseInt(fromVal, 10);
        const toLap = toVal === '' ? null : parseInt(toVal, 10);
        const prob = parseFloat(probVal);
        if (!Number.isFinite(fromLap) || fromLap <= 0) return;
        if (toLap !== null && (!Number.isFinite(toLap) || toLap < fromLap)) return;
        if (!Number.isFinite(prob) || prob < 0) return;
        parsed.push([fromLap, toLap, prob / 100]);
      });

      if (parsed.length === 0) {
        throw new Error('Define at least one SC probability range.');
      }
      const last = parsed[parsed.length - 1];
      if (last[1] !== null) {
        throw new Error('Last SC probability range must leave "To lap" blank (open-ended).');
      }
      return parsed;
    }

    function updateTyreDegFilterState(key, rawValue) {
      const rawText = rawValue !== undefined && rawValue !== null ? String(rawValue).trim() : '';
      const previousValue = appState.tyreDeg[key];

      if (rawText === '') {
        if (!Object.is(previousValue, null)) {
          saveToState(`tyreDeg.${key}`, null);
        }
        return null;
      }

      let parsedValue;
      if (key === 'filterMinRows') {
        const parsed = parseInt(rawText, 10);
        if (!Number.isFinite(parsed) || parsed < 1) {
          return previousValue;
        }
        parsedValue = parsed;
      } else {
        const parsed = parseFloat(rawText);
        if (!Number.isFinite(parsed)) {
          return previousValue;
        }
        parsedValue = parsed;
      }

      if (!Object.is(parsedValue, previousValue)) {
        saveToState(`tyreDeg.${key}`, parsedValue);
      }

      return parsedValue;
    }

    function setRaceTraceLapBounds(minLap, maxLap) {
      const clampedMin = Number.isFinite(minLap) ? minLap : 1;
      const clampedMax = Number.isFinite(maxLap) ? Math.max(clampedMin, maxLap) : clampedMin;
      raceTraceLapBounds = { min: clampedMin, max: clampedMax };
      if (raceTraceLapMin) raceTraceLapMin.min = clampedMin;
      if (raceTraceLapMax) raceTraceLapMax.max = clampedMax;
    }

    function renderRaceTraceLapInputsFromState() {
      if (raceTraceLapMin) {
        const value = appState.raceTrace.lapMin;
        raceTraceLapMin.value = (value === 0 || value === null || value === undefined) ? '' : value;
      }
      if (raceTraceLapMax) {
        const value = appState.raceTrace.lapMax;
        raceTraceLapMax.value = (value === 0 || value === null || value === undefined) ? '' : value;
      }
    }

    function updateRaceTraceLapState(key, rawValue) {
      const rawText = rawValue !== undefined && rawValue !== null ? String(rawValue).trim() : '';
      const previousValue = appState.raceTrace[key];

      if (rawText === '') {
        if (previousValue !== 0) {
          saveToState(`raceTrace.${key}`, 0);
        }
        renderRaceTraceLapInputsFromState();
        return 0;
      }

      const fallback = previousValue && previousValue !== 0
        ? previousValue
        : (key === 'lapMin' ? raceTraceLapBounds.min : raceTraceLapBounds.max);
      const parsed = parseInt(rawText, 10);
      let nextValue = Number.isFinite(parsed) ? parsed : fallback;
      nextValue = Math.max(raceTraceLapBounds.min, Math.min(nextValue, raceTraceLapBounds.max));

      if (nextValue !== previousValue) {
        saveToState(`raceTrace.${key}`, nextValue);
      }

      renderRaceTraceLapInputsFromState();
      return nextValue;
    }

    // Set up race trace event listeners
    raceTraceLapMin.addEventListener('input', function() {
      updateRaceTraceLapState('lapMin', this.value);
      renderRaceTraceChart();
    });
    raceTraceLapMax.addEventListener('input', function() {
      updateRaceTraceLapState('lapMax', this.value);
      renderRaceTraceChart();
    });

    function getDriverInfo(code) {
      // Get driver info for current session with proper parameters
      if (!raceTraceYear || !raceTraceRound || !raceTraceSessionType) {
        return { fullName: code, color: '#888888', teamName: '', headshotUrl: '' };
      }

      return DriverInfo.getDriverInfo(code, raceTraceYear, raceTraceRound, raceTraceSessionType);
    }

    function calculateRaceTraceGaps(rows) {
      const lapData = new Map();

      rows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        const driver = String(r.lap_Driver || "").trim();
        const position = parseInt(r.lap_Position);
        const lapTime = parseFloat(r.lap_Time);

        if (isNaN(lapNum) || !driver || isNaN(lapTime) || isNaN(position)) return;

        if (!lapData.has(lapNum)) {
          lapData.set(lapNum, []);
        }

        lapData.get(lapNum).push({ driver, position, lapTime });
      });

      raceTraceDriverLines = {};

      lapData.forEach((driversInLap, lapNum) => {
        driversInLap.sort((a, b) => a.position - b.position);
        const minTime = Math.min(...driversInLap.map(d => d.lapTime));

        driversInLap.forEach(d => {
          const gap = minTime - d.lapTime;

          if (!raceTraceDriverLines[d.driver]) {
            raceTraceDriverLines[d.driver] = {
              laps: [],
              gaps: [],
              positions: []
            };
          }

          raceTraceDriverLines[d.driver].laps.push(lapNum);
          raceTraceDriverLines[d.driver].gaps.push(gap);
          raceTraceDriverLines[d.driver].positions.push(d.position);
        });
      });
    }

    function buildRaceTraceDriverList() {
      if (!raceTraceDriverList) return;

      const drivers = Object.keys(raceTraceDriverLines);
      if (drivers.length === 0) {
        raceTraceDriverList.innerHTML = '';
        return;
      }
      const driverFinishInfo = drivers.map(driver => {
        const data = raceTraceDriverLines[driver];
        const maxLapNum = Math.max(...data.laps);
        const lastLapIndex = data.laps.indexOf(maxLapNum);
        const lastPosition = data.positions[lastLapIndex];

        return { driver, maxLapNum, lastPosition };
      });

      const sortedDriverFinishInfo = sortDriversByFinishingOrder(driverFinishInfo);
      raceTraceAvailableDrivers = sortedDriverFinishInfo.map(({ driver }) => driver);

      raceTraceDriverDisplayData = sortedDriverFinishInfo.map(({ driver }) => {
        const info = getDriverInfo(driver);
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        return {
          key: driver,
          label: displayName,
          color: info.color || '#888888'
        };
      });

      if (!raceTraceDriverManager) {
        raceTraceDriverManager = new DriverSelectionManager({
          container: raceTraceDriverList,
          selectAllId: 'raceTraceSelectAllDrivers',
          selectAllLabel: 'Select All',
          rowTag: 'div',
          rowClass: 'race-trace-driver',
          selectAllClass: 'race-trace-driver',
          inputIdPrefix: 'race-trace-driver',
          itemsSource: () => raceTraceDriverDisplayData
        });
      }

      raceTraceDriverManager.render();
    }

    // Shared detection functions that work with any session rows
    function detectRainfallLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapRainfall = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRainfall.has(lapNum)) {
          lapRainfall.set(lapNum, { total: 0, rainfall: 0 });
        }

        const lapData = lapRainfall.get(lapNum);
        lapData.total++;

        const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
        if (rainfall === 'true' || rainfall === '1') {
          lapData.rainfall++;
        }
      });

      const rainfallLaps = [];
      lapRainfall.forEach((data, lapNum) => {
        if (data.rainfall / data.total >= 0.5) {
          rainfallLaps.push(lapNum);
        }
      });

      if (rainfallLaps.length === 0) return [];

      rainfallLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = rainfallLaps[0];
      let end = rainfallLaps[0];

      for (let i = 1; i < rainfallLaps.length; i++) {
        if (rainfallLaps[i] === end + 1) {
          end = rainfallLaps[i];
        } else {
          ranges.push({ start, end });
          start = rainfallLaps[i];
          end = rainfallLaps[i];
        }
      }
      ranges.push({ start, end });
      return ranges;
    }

    function detectSafetyCarLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapSafetyCar = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapSafetyCar.has(lapNum)) {
          lapSafetyCar.set(lapNum, { total: 0, safetyCar: 0 });
        }

        const lapData = lapSafetyCar.get(lapNum);
        lapData.total++;

        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('4') || trackStatus.includes('6') || trackStatus.includes('7')) {
          if (!trackStatus.includes('5')) {
            lapData.safetyCar++;
          }
        }
      });

      const safetyCarLaps = [];
      lapSafetyCar.forEach((data, lapNum) => {
        if (data.safetyCar / data.total >= 0.5) {
          safetyCarLaps.push(lapNum);
        }
      });

      if (safetyCarLaps.length === 0) return [];

      safetyCarLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = safetyCarLaps[0];
      let end = safetyCarLaps[0];

      for (let i = 1; i < safetyCarLaps.length; i++) {
        if (safetyCarLaps[i] === end + 1) {
          end = safetyCarLaps[i];
        } else {
          ranges.push({ start, end });
          start = safetyCarLaps[i];
          end = safetyCarLaps[i];
        }
      }
      ranges.push({ start, end });
      return ranges;
    }

    function detectRedFlagLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapRedFlag = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRedFlag.has(lapNum)) {
          lapRedFlag.set(lapNum, { total: 0, redFlag: 0 });
        }

        const lapData = lapRedFlag.get(lapNum);
        lapData.total++;

        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('5')) {
          lapData.redFlag++;
        }
      });

      const redFlagLaps = [];
      lapRedFlag.forEach((data, lapNum) => {
        if (data.redFlag / data.total >= 0.5) {
          redFlagLaps.push(lapNum);
        }
      });

      return redFlagLaps.sort((a, b) => a - b);
    }

    function renderRaceTraceChart() {
      if (Object.keys(raceTraceDriverLines).length === 0) return;

      const chartContainer = document.getElementById('raceTraceChart');
      const debugDiv = document.getElementById('raceTraceDebugInfo');
      if (debugDiv) debugDiv.remove();

      if (!raceTraceChart) {
        raceTraceChart = echarts.init(chartContainer);
      }

      const storedMinLap = appState.raceTrace.lapMin;
      const storedMaxLap = appState.raceTrace.lapMax;
      const minLapState = (storedMinLap === 0 || storedMinLap === null || storedMinLap === undefined)
        ? raceTraceLapBounds.min
        : storedMinLap;
      const maxLapState = (storedMaxLap === 0 || storedMaxLap === null || storedMaxLap === undefined)
        ? raceTraceLapBounds.max
        : storedMaxLap;
      const minLap = Math.max(raceTraceLapBounds.min, Math.min(minLapState, raceTraceLapBounds.max));
      let maxLap = Math.max(raceTraceLapBounds.min, Math.min(maxLapState, raceTraceLapBounds.max));
      if (maxLap < minLap) {
        maxLap = minLap;
      }

      // Detect rainfall, safety car, and red flag laps using unfiltered session data
      const rainfallRanges = detectRainfallLaps(raceTraceCurrentSessionRows, minLap, maxLap);
      const safetyCarRanges = detectSafetyCarLaps(raceTraceCurrentSessionRows, minLap, maxLap);
      const redFlagLaps = detectRedFlagLaps(raceTraceCurrentSessionRows, minLap, maxLap);

      // Calculate gaps by lap for scaling
      const gapsByLap = new Map();
      appState.selectedDrivers.forEach(driver => {
        const data = raceTraceDriverLines[driver];
        if (!data) return;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            if (!gapsByLap.has(lap)) gapsByLap.set(lap, []);
            gapsByLap.get(lap).push(data.gaps[i]);
          }
        }
      });

      const maxGapByLap = new Map();
      gapsByLap.forEach((gaps, lap) => {
        maxGapByLap.set(lap, Math.max(...gaps));
      });

      const series = [];
      const lapCount = Math.max(...Object.values(raceTraceDriverLines).map(d => Math.max(...d.laps)));
      const rightX = (maxLap === lapCount) ? (maxLap + 0.5) : (maxLap + 0.1);

      appState.selectedDrivers.forEach(driver => {
        const data = raceTraceDriverLines[driver];
        if (!data) return;

        const points = [];
        let lastGap = null;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            const rawGap = data.gaps[i];
            const maxGap = maxGapByLap.get(lap) || 0;
            const adjustedGap = rawGap - maxGap;
            points.push([lap, adjustedGap]);
            lastGap = adjustedGap;
          }
        }

        if (points.length > 0) {
          const info = getDriverInfo(driver);
          const completedAllLaps = data.laps.some(lap => lap === maxLap);

          if (completedAllLaps && lastGap !== null) {
            points.push({
              value: [rightX, lastGap],
              tooltip: { show: false },
              emphasis: { disabled: true }
            });
          }

          series.push({
            name: driver,
            type: 'line',
            data: points,
            step: 'end',
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: info.color },
            itemStyle: { color: info.color, borderWidth: 0 },
            emphasis: { focus: 'series', blurScope: 'global', lineStyle: { width: 3.5 } },
            blur: { lineStyle: { opacity: 0.15 } },
            endLabel: {
              show: completedAllLaps,
              formatter: '{a}',
              position: 'right',
              offset: [6, 0],
              color: info.color
            },
            animation: false
          });
        }
      });

      // Add rainfall shading
      if (rainfallRanges.length > 0) {
        const markAreaData = rainfallRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end ? `Rainfall (Lap ${range.start})` : `Rainfall (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Rainfall',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: { color: 'rgba(30, 144, 255, 0.1)' },
            data: markAreaData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      // Add safety car shading
      if (safetyCarRanges.length > 0) {
        const markAreaData = safetyCarRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end ? `Safety Car (Lap ${range.start})` : `Safety Car (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Safety Car',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: { color: 'rgba(150, 150, 7, 0.15)' },
            data: markAreaData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      // Add red flag lines
      if (redFlagLaps.length > 0) {
        const markLineData = redFlagLaps.map(lap => ({
          xAxis: lap,
          name: `Red Flag (Lap ${lap})`,
          label: { show: false }
        }));

        series.push({
          name: 'Red Flag',
          type: 'line',
          data: [],
          markLine: {
            silent: false,
            symbol: 'none',
            lineStyle: {
              color: 'rgba(255, 0, 0, 0.5)',
              width: 2,
              type: 'dashed'
            },
            data: markLineData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      const option = {
        backgroundColor: 'transparent',
        grid: {
          left: 60,
          right: 120,
          top: 40,
          bottom: 60,
          containLabel: false
        },
        xAxis: [
          {
            type: 'value',
            name: 'Lap',
            min: minLap,
            max: rightX,
            minInterval: 1,
            nameLocation: 'middle',
            nameGap: 35,
            position: 'bottom',
            axisLine: { lineStyle: { color: '#555' } },
            axisLabel: {
              color: '#aaa',
              formatter: function(value) {
                // Only show label if it's an integer
                return Number.isInteger(value) ? value : '';
              }
            },
            splitLine: {
              show: true,
              lineStyle: { color: '#333', type: 'solid', width: 1 }
            }
          },
          {
            type: 'value',
            min: minLap,
            max: rightX,
            minInterval: 1,
            position: 'top',
            axisLine: { lineStyle: { color: '#555' } },
            axisLabel: {
              color: '#aaa',
              formatter: function(value) {
                // Only show label if it's an integer
                return Number.isInteger(value) ? value : '';
              }
            },
            splitLine: { show: false }
          }
        ],
        yAxis: {
          type: 'value',
          name: 'Gap (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameRotate: 90,
          nameTextStyle: { color: '#aaa', fontSize: 12 },
          minInterval: 1,
          axisLine: { lineStyle: { color: '#555' } },
          axisLabel: { color: '#aaa' },
          splitLine: {
            show: true,
            lineStyle: { color: '#333', type: 'solid', width: 1 }
          }
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          appendToBody: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const v = Array.isArray(p.value) ? p.value : p.data?.value || p.data;
            const lap = Array.isArray(v) ? v[0] : v?.[0];
            const gap = Array.isArray(v) ? v[1] : v?.[1];
            const code = p.seriesName;
            const info = getDriverInfo(code);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || code;
              const teamName = info.teamName || '';
              const gapLine = (typeof lap === 'number' && typeof gap === 'number')
                ? `<div style="margin-top:4px">Lap ${lap}: ${gap.toFixed(3)} s</div>`
                : '';
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${code})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${gapLine}
                  </div>
                </div>
              `;
            }

            if (typeof lap === 'number' && typeof gap === 'number') {
              return `${p.marker}<b>${code}</b><br/>Lap ${lap}: ${gap.toFixed(3)} s`;
            }
            return `${p.marker}<b>${code}</b>`;
          }
        },
        series: series
      };

      raceTraceChart.setOption(option, true); // true = notMerge, completely replace the option
    }

    // Lap Time Panel
    const lapTimeDriversList = document.getElementById('lapTimeDriversList');
    const lapTimeChart = document.getElementById('lapTimeChart');
    const fuelAdjustToggle = document.getElementById('fuelAdjustToggle');
    const tyreLifeAdjustToggle = document.getElementById('tyreLifeAdjustToggle');

    let lapTimeChartInstance = null;
    let lapTimeCurrentGroups = new Map();
    let lapTimeDriverColors = new Map();
    let lapTimeScheduledLaps = null;
    let lapTimeCurrentSessionRows = [];
    let lapTimeYear = '';
    let lapTimeRound = '';
    let lapTimeSessionType = '';
    let lapTimeDriverOrder = []; // Stores finishing order from unfiltered data

    const CIRCUIT_CONFIG_FILE = 'strat_calc_config.json';
    const CircuitConfig = {
      data: null,
      promise: null,
      loading: false,
      error: null,
      load() {
        if (this.data) {
          return Promise.resolve(this.data);
        }
        if (this.promise) {
          return this.promise;
        }
        this.loading = true;
        const url = resolveCircuitConfigUrl();
        this.promise = fetch(url)
          .then(response => {
            if (!response.ok) {
              throw new Error(`Failed to load ${CIRCUIT_CONFIG_FILE}: ${response.status} ${response.statusText}`);
            }
            return response.json();
          })
          .then(data => {
            this.data = data || {};
            this.loading = false;
            this.error = null;
            this.promise = null;
            return this.data;
          })
          .catch(err => {
            this.error = err;
            this.loading = false;
            this.promise = null;
            console.error(`Error loading ${CIRCUIT_CONFIG_FILE}:`, err);
            throw err;
          });
        return this.promise;
      },
      get(circuitName) {
        if (!circuitName || !this.data) return null;
        return this.data[circuitName] || null;
      }
    };

    function resolveCircuitConfigUrl() {
      if (typeof DataCache !== 'undefined' && typeof DataCache.getCSVUrl === 'function') {
        return DataCache.getCSVUrl(CIRCUIT_CONFIG_FILE);
      }
      return CIRCUIT_CONFIG_FILE;
    }

    function whenCircuitConfigReady(callback) {
      if (CircuitConfig.data) {
        callback();
        return;
      }
      CircuitConfig.load()
        .then(() => callback())
        .catch(() => callback());
    }

    // Prime cache early
    CircuitConfig.load().catch(() => {});

    function applyPaceModelDefaultsForCircuit(circuitName) {
      if (!circuitName) return;

      const applyConfig = () => {
        const latestCircuit = currentSessionData && currentSessionData.length > 0
          ? String(currentSessionData[0].circuit_name || "").trim()
          : "";
        if (latestCircuit !== circuitName) return;
        const config = CircuitConfig.get(circuitName);
        if (!config) return;

        let paceModelChanged = false;
        if (config["Hard Deg"] !== undefined && appState.paceModel.degHard === defaultAppState.paceModel.degHard) {
          saveToState('paceModel.degHard', config["Hard Deg"]);
          paceModelChanged = true;
        }
        if (config["Medium Deg"] !== undefined && appState.paceModel.degMedium === defaultAppState.paceModel.degMedium) {
          saveToState('paceModel.degMedium', config["Medium Deg"]);
          paceModelChanged = true;
        }
        if (config["Soft Deg"] !== undefined && appState.paceModel.degSoft === defaultAppState.paceModel.degSoft) {
          saveToState('paceModel.degSoft', config["Soft Deg"]);
          paceModelChanged = true;
        }
        if (config["Fuel Effect"] !== undefined && appState.paceModel.fuelEffect === defaultAppState.paceModel.fuelEffect) {
          saveToState('paceModel.fuelEffect', config["Fuel Effect"]);
          paceModelChanged = true;
        }

        if (paceModelChanged) {
          renderPaceModelInputsFromState();
          onLapTimeAdjustmentChange();
        }
      };

      if (CircuitConfig.get(circuitName)) {
        applyConfig();
      } else {
        whenCircuitConfigReady(applyConfig);
      }
    }

    function configureCalculatorPanelFromCircuit(circuitName, options = {}) {
      const { isRestoringPermalink = false } = options;

      const applyFallbackDefaults = () => {
        const setDefaultIfNull = (key, value) => {
          if (appState.calculator[key] === null || appState.calculator[key] === undefined) {
            saveToState(`calculator.${key}`, value);
            return true;
          }
          return false;
        };
        let calculatorDefaultsChanged = false;
        calculatorDefaultsChanged = setDefaultIfNull('pitLoss', 21.8) || calculatorDefaultsChanged;
        calculatorDefaultsChanged = setDefaultIfNull('scLength', 5) || calculatorDefaultsChanged;
        calculatorDefaultsChanged = setDefaultIfNull('paceS', 75.0) || calculatorDefaultsChanged;
        calculatorDefaultsChanged = setDefaultIfNull('paceM', 75.5) || calculatorDefaultsChanged;
        calculatorDefaultsChanged = setDefaultIfNull('paceH', 76.5) || calculatorDefaultsChanged;

        if (calculatorDefaultsChanged) {
          renderCalculatorInputsFromState();
        }

        if (!isRestoringPermalink) {
          saveToState('calculator.scProbRanges', cloneDefaultScProbRanges());
        }
        renderCalculatorScProbTableFromState();

        // Seed patterns from free optimization (no config available)
        seedCalculatorPatternsFromFree();
        runCalculatorSimulation();
      };

      const applyConfigDefaults = config => {
        if (!config) {
          applyFallbackDefaults();
          return;
        }

        let calculatorInputsChanged = false;
        if ((appState.calculator.pitLoss === null || appState.calculator.pitLoss === undefined) && config['Pit Loss'] !== undefined) {
          saveToState('calculator.pitLoss', config['Pit Loss']);
          calculatorInputsChanged = true;
        }
        if ((appState.calculator.scLength === null || appState.calculator.scLength === undefined) && config['SC Length'] !== undefined) {
          saveToState('calculator.scLength', config['SC Length']);
          calculatorInputsChanged = true;
        }

        if ((appState.calculator.paceS === null || appState.calculator.paceS === undefined) && config['Softs']) {
          saveToState('calculator.paceS', parseFloat(config['Softs']['Pace']));
          calculatorInputsChanged = true;
        }

        if ((appState.calculator.paceM === null || appState.calculator.paceM === undefined) && config['Mediums']) {
          saveToState('calculator.paceM', parseFloat(config['Mediums']['Pace']));
          calculatorInputsChanged = true;
        }

        if ((appState.calculator.paceH === null || appState.calculator.paceH === undefined) && config['Hards']) {
          saveToState('calculator.paceH', parseFloat(config['Hards']['Pace']));
          calculatorInputsChanged = true;
        }

        if (calculatorInputsChanged) {
          renderCalculatorInputsFromState();
        }

        let strategiesLoaded = false;
        const strategyInputs = document.querySelectorAll('.calculatorStrategyInput');
        const hasStateStrategies = appState.calculator.strategies &&
          appState.calculator.strategies.some(s => s && s.trim() !== '');

        if (hasStateStrategies) {
          renderCalculatorStrategyInputsFromState();
          strategiesLoaded = true;
        } else if (config['Strategies Of Interest'] && config['Strategies Of Interest'][0]) {
          const strategies = Array.from(strategyInputs, () => '');
          const configStrategies = config['Strategies Of Interest'][0];
          configStrategies.forEach((strategy, index) => {
            if (index < strategies.length) {
              strategies[index] = strategy;
            }
          });
          saveToState('calculator.strategies', strategies);
          renderCalculatorStrategyInputsFromState();
          strategiesLoaded = true;
        } else if (!isRestoringPermalink) {
          const emptyStrategies = Array.from(strategyInputs, () => '');
          saveToState('calculator.strategies', emptyStrategies);
          renderCalculatorStrategyInputsFromState();
        }

        if (!isRestoringPermalink) {
          saveToState('calculator.scProbRanges', cloneDefaultScProbRanges());
        }
        renderCalculatorScProbTableFromState();

        // Seed patterns only if not loaded from config
        if (!strategiesLoaded) {
          seedCalculatorPatternsFromFree();
        }
        runCalculatorSimulation();
      };

      if (!circuitName) {
        applyFallbackDefaults();
        return;
      }

      const immediateConfig = CircuitConfig.get(circuitName);
      if (immediateConfig) {
        applyConfigDefaults(immediateConfig);
        return;
      }

      whenCircuitConfigReady(() => {
        const readyConfig = CircuitConfig.get(circuitName);
        if (readyConfig) {
          applyConfigDefaults(readyConfig);
        } else {
          applyFallbackDefaults();
        }
      });
    }

    function getLapTimeDriverInfo(code) {
      // Get driver info for current session with proper parameters
      if (!lapTimeYear || !lapTimeRound || !lapTimeSessionType) {
        return { fullName: code, color: '#888888', teamName: '', headshotUrl: '' };
      }

      return DriverInfo.getDriverInfo(code, lapTimeYear, lapTimeRound, lapTimeSessionType);
    }

    // Set up lap time filter listeners
    function setupLapTimeFilterListeners() {
      const degHardInput = document.getElementById('degHard');
      const degMediumInput = document.getElementById('degMedium');
      const degSoftInput = document.getElementById('degSoft');
      const fuelEffectInput = document.getElementById('fuelEffect');

      degHardInput.addEventListener('input', () => {
        const value = parseFloat(degHardInput.value);
        if (!Number.isFinite(value)) return;
        saveToState('paceModel.degHard', value);
        renderPaceModelInputsFromState({ skip: ['degHard'] });
        onLapTimeAdjustmentChange();
      });

      degMediumInput.addEventListener('input', () => {
        const value = parseFloat(degMediumInput.value);
        if (!Number.isFinite(value)) return;
        saveToState('paceModel.degMedium', value);
        renderPaceModelInputsFromState({ skip: ['degMedium'] });
        onLapTimeAdjustmentChange();
      });

      degSoftInput.addEventListener('input', () => {
        const value = parseFloat(degSoftInput.value);
        if (!Number.isFinite(value)) return;
        saveToState('paceModel.degSoft', value);
        renderPaceModelInputsFromState({ skip: ['degSoft'] });
        onLapTimeAdjustmentChange();
      });

      fuelEffectInput.addEventListener('input', () => {
        const value = parseFloat(fuelEffectInput.value);
        if (!Number.isFinite(value)) return;
        saveToState('paceModel.fuelEffect', value);
        renderPaceModelInputsFromState({ skip: ['fuelEffect'] });
        onLapTimeAdjustmentChange();
      });

      fuelAdjustToggle.addEventListener('click', function() {
        // Toggle state in appState first
        const newValue = !appState.lapTime.fuelAdjust;
        saveToState('lapTime.fuelAdjust', newValue);
        renderLapTimeToggleInputsFromState();
        renderLapTimeChart();
        renderLapTimeSummaryTable();
      });

      tyreLifeAdjustToggle.addEventListener('click', function() {
        // Toggle state in appState first
        const newValue = !appState.lapTime.tyreLifeAdjust;
        saveToState('lapTime.tyreLifeAdjust', newValue);
        renderLapTimeToggleInputsFromState();
        renderLapTimeChart();
        renderLapTimeSummaryTable();
      });

      // Copy data button
      document.getElementById('copyLapTimeDataBtn').addEventListener('click', copyLapTimeDataToClipboard);
    }

    setupLapTimeFilterListeners();

    function onLapTimeAdjustmentChange() {
      if (lapTimeCurrentGroups.size > 0) {
        renderLapTimeChart();
        renderLapTimeSummaryTable();
      }
    }

    function copyLapTimeDataToClipboard() {
      // Get selected drivers in order
      const selectedDriversList = Array.from(appState.selectedDrivers);
      if (selectedDriversList.length === 0) {
        alert('No drivers selected');
        return;
      }

      // Build a map of lap number -> driver -> lap time
      const lapData = new Map();
      let minLap = Infinity;
      let maxLap = -Infinity;

      selectedDriversList.forEach(driver => {
        const stints = lapTimeCurrentGroups.get(driver);
        if (!stints) return;

        stints.forEach(stint => {
          stint.laps.forEach(lap => {
            const lapNum = lap.lapNumber;
            minLap = Math.min(minLap, lapNum);
            maxLap = Math.max(maxLap, lapNum);

            if (!lapData.has(lapNum)) {
              lapData.set(lapNum, new Map());
            }
            lapData.get(lapNum).set(driver, lap.lapTime);
          });
        });
      });

      if (minLap === Infinity || maxLap === -Infinity) {
        alert('No data available');
        return;
      }

      // Build the table
      const lines = [];

      // Header row
      lines.push(['Lap', ...selectedDriversList].join(' | '));

      // Data rows
      for (let lap = 1; lap <= maxLap; lap++) {
        const row = [lap.toString()];
        const lapDriverData = lapData.get(lap);

        selectedDriversList.forEach(driver => {
          if (lapDriverData && lapDriverData.has(driver)) {
            row.push(lapDriverData.get(driver).toFixed(3));
          } else {
            row.push('NaN');
          }
        });

        lines.push(row.join(' | '));
      }

      // Copy to clipboard
      const text = lines.join('\n');
      navigator.clipboard.writeText(text).then(() => {
        // Show brief success feedback
        const btn = document.getElementById('copyLapTimeDataBtn');
        const originalText = btn.textContent;
        btn.textContent = 'Copied!';
        btn.style.color = 'var(--primary-color)';
        setTimeout(() => {
          btn.textContent = originalText;
          btn.style.color = '';
        }, 1500);
      }).catch(err => {
        console.error('Failed to copy:', err);
        alert('Failed to copy to clipboard');
      });
    }

    function applySharedFilters(rows) {
      const {
        minLap: rawMinLap,
        endLaps: rawEndLaps,
        minStintLap: rawMinStintLap,
        minDist: rawMinDist,
        rainfall: includeRainfall,
        safetyCar: includeSafetyCar,
        pitLaps: includePitLaps,
        includeLapped,
        includeRetired
      } = appState.filters;

      const lapsToDiscard = Number.isFinite(rawMinLap) ? rawMinLap : parseInt(rawMinLap, 10) || 0;
      const minLap = lapsToDiscard + 1;
      const endLaps = Number.isFinite(rawEndLaps) ? rawEndLaps : parseInt(rawEndLaps, 10) || 0;
      const minStintLap = Number.isFinite(rawMinStintLap) ? rawMinStintLap : parseInt(rawMinStintLap, 10) || 0;
      const minDist = Number.isFinite(rawMinDist) ? rawMinDist : parseFloat(rawMinDist) || 0;

      const filteredRows = rows.filter(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap) return false;

        const schedLaps = parseInt(r.sched_laps);
        if (!isNaN(schedLaps)) {
          const maxLap = schedLaps - endLaps;
          if (lapNum > maxLap) return false;
        }

        const status = String(r.finish_status ?? '').trim();
        const plusLapsMatch = status.match(/^\+(\d+)\sLaps$/);
        const lapsBehind = plusLapsMatch ? Number(plusLapsMatch[1]) : 0;
        if (lapsBehind > 1) return false;

        const isLapped = status === 'Lapped' || status === '+1 Lap';
        if (!includeLapped && isLapped) return false;

        const isFinished = status === 'Finished' || isLapped;
        const isRetired = !isFinished;
        if (!includeRetired && isRetired) return false;

        if (!includeRainfall) {
          const rainfall = String(r.weather_Rainfall || '').trim().toLowerCase();
          if (rainfall === 'true' || rainfall === '1') return false;
        }

        if (!includeSafetyCar) {
          const trackStatus = String(r.lap_TrackStatus || '').trim();
          if (trackStatus.includes('4') || trackStatus.includes('5') ||
              trackStatus.includes('6') || trackStatus.includes('7')) {
            return false;
          }
        }

        if (!includePitLaps) {
          const pitIn = String(r.lap_PitInTime || '').trim();
          const pitOut = String(r.lap_PitOutTime || '').trim();
          if ((pitIn && pitIn.toLowerCase() !== 'na' && pitIn !== '') ||
              (pitOut && pitOut.toLowerCase() !== 'na' && pitOut !== '')) {
            return false;
          }
        }

        const dist = parseFloat(r.min_dist);
        if (!isNaN(dist) && dist < minDist) return false;

        return true;
      });

      // apply the min stint lap filter
      const byStintAndDriver = new Map();
      for (const row of filteredRows) {
        const key = `${row.lap_Driver}::${row.lap_Stint}`;
        if (!byStintAndDriver.has(key)) byStintAndDriver.set(key, []);
        byStintAndDriver.get(key).push(row);
      }
      const toRemove = new Set();
      for (const stintRows of byStintAndDriver.values()) {
        const sorted = [...stintRows].sort((a, b) => a.lap_LapNumber - b.lap_LapNumber);
        for (const row of sorted.slice(0, minStintLap)) toRemove.add(row);
      }
      return filteredRows.filter(row => !toRemove.has(row));
    }

    const SHARED_FILTER_CONFIG = {
      minLap: {
        ids: ['filterMinLap', 'tyreDegFilterMinLap', 'fuelEffectFilterMinLap'],
        type: 'int'
      },
      endLaps: {
        ids: ['filterEndLaps', 'tyreDegFilterEndLaps', 'fuelEffectFilterEndLaps'],
        type: 'int'
      },
      minStintLap: {
        ids: ['filterMinStintLap', 'tyreDegFilterMinStintLap', 'fuelEffectFilterMinStintLap'],
        type: 'int'
      },
      minDist: {
        ids: ['filterMinDist', 'tyreDegFilterMinDist', 'fuelEffectFilterMinDist'],
        type: 'float'
      },
      rainfall: {
        ids: ['filterRainfall', 'tyreDegFilterRainfall', 'fuelEffectFilterRainfall'],
        type: 'bool'
      },
      safetyCar: {
        ids: ['filterSafetyCar', 'tyreDegFilterSafetyCar', 'fuelEffectFilterSafetyCar'],
        type: 'bool'
      },
      pitLaps: {
        ids: ['filterPitLaps', 'tyreDegFilterPitLaps', 'fuelEffectFilterPitLaps'],
        type: 'bool'
      },
      includeLapped: {
        ids: ['filterIncludeLapped', 'tyreDegFilterIncludeLapped', 'fuelEffectFilterIncludeLapped'],
        type: 'bool'
      },
      includeRetired: {
        ids: ['filterIncludeRetired', 'tyreDegFilterIncludeRetired', 'fuelEffectFilterIncludeRetired'],
        type: 'bool'
      }
    };

    function formatSharedFilterValue(value) {
      if (typeof value === 'number') {
        return Number.isFinite(value) ? value : '';
      }
      return value ?? '';
    }

    function renderSharedFiltersFromState() {
      Object.entries(SHARED_FILTER_CONFIG).forEach(([key, config]) => {
        const value = appState.filters[key];
        config.ids.forEach(id => {
          const element = document.getElementById(id);
          if (!element) return;
          if (config.type === 'bool') {
            element.checked = Boolean(value);
          } else {
            element.value = formatSharedFilterValue(value);
          }
        });
      });
    }

    function handleSharedFiltersChange() {
      renderSharedFiltersFromState();

      if (lapTimeCurrentSessionRows && lapTimeCurrentSessionRows.length > 0) {
        processLapTimeData(lapTimeCurrentSessionRows);
      }

      if (currentSessionData && currentSessionData.length > 0) {
        processTyreDegData(currentSessionData);
        processFuelEffectData(currentSessionData);
      }
    }

    function setupSharedFilterStateSync() {
      Object.entries(SHARED_FILTER_CONFIG).forEach(([key, config]) => {
        config.ids.forEach(id => {
          const element = document.getElementById(id);
          if (!element) return;
          const eventType = config.type === 'bool' ? 'change' : 'input';
          element.addEventListener(eventType, () => {
            const rawValue = config.type === 'bool'
              ? element.checked
              : config.type === 'float'
                ? parseFloat(element.value)
                : parseInt(element.value, 10);
            const previousValue = appState.filters[key];
            if (Object.is(previousValue, rawValue)) {
              return;
            }
            saveToState(`filters.${key}`, rawValue);
            handleSharedFiltersChange();
          });
        });
      });
    }

    /**
     * Determine finishing order from unfiltered data
     * This must be called before filters are applied to get accurate finishing positions
     */
    function determineFinishingOrder(unfilteredRows) {
      const driverPositions = new Map();

      unfilteredRows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNumber = parseInt(r.lap_LapNumber);
        const position = parseInt(r.lap_Position);

        if (!driver || isNaN(lapNumber) || isNaN(position)) return;

        if (!driverPositions.has(driver)) {
          driverPositions.set(driver, {
            driver: driver,
            maxLapNum: 0,
            lastPosition: null
          });
        }

        const data = driverPositions.get(driver);
        if (lapNumber > data.maxLapNum) {
          data.maxLapNum = lapNumber;
          data.lastPosition = position;
        }
      });

      return sortDriversByFinishingOrder(Array.from(driverPositions.values()));
    }

    function processLapTimeData(sessionData) {
      if (!sessionData || sessionData.length === 0) {
        lapTimeDriverOrder = [];
        lapTimeCurrentGroups = new Map();
        lapTimeSelectedDrivers.clear();
        buildLapTimeDriversList([]);
        renderLapTimeChart();
        renderLapTimeSummaryTable();
        return;
      }

      lapTimeDriverOrder = determineFinishingOrder(sessionData);
      const rows = applySharedFilters(sessionData);

      if (!rows || rows.length === 0) {
        lapTimeCurrentGroups = new Map();
        lapTimeSelectedDrivers.clear();
        buildLapTimeDriversList([]);
        renderLapTimeChart();
        renderLapTimeSummaryTable();
        return;
      }

      let driverOrder = lapTimeDriverOrder;
      // If no driver order provided, fall back to determining it from the rows
      if (!driverOrder || driverOrder.length === 0) {
        console.warn('No driver order provided to processLapTimeData, determining from filtered rows');
        driverOrder = determineFinishingOrder(rows);
      }

      const driverData = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNumber = parseInt(r.lap_LapNumber);
        const lapTime = parseFloat(r.lap_LapTime);
        const compound = String(r.lap_Compound || "").trim();
        const stint = String(r.lap_Stint || "").trim();
        const tyreLife = parseInt(r.lap_TyreLife);
        const schedLaps = parseInt(r.sched_laps);

        if (!driver || isNaN(lapNumber) || isNaN(lapTime) || !stint) return;

        if (!driverData.has(driver)) {
          driverData.set(driver, {
            driver: driver,
            stints: new Map()
          });
        }

        const data = driverData.get(driver);
        const driverStints = data.stints;

        if (!driverStints.has(stint)) {
          driverStints.set(stint, {
            compound: compound,
            laps: []
          });
        }

        driverStints.get(stint).laps.push({
          lapNumber: lapNumber,
          lapTime: lapTime,
          compound: compound,
          tyreLife: tyreLife,
          schedLaps: schedLaps
        });
      });

      // Use the pre-determined driver order
      const sortedDriverData = new Map();
      driverOrder.forEach(d => {
        if (driverData.has(d.driver)) {
          sortedDriverData.set(d.driver, driverData.get(d.driver).stints);
        }
      });
      lapTimeCurrentGroups = sortedDriverData;

      const drivers = driverOrder.filter(d => driverData.has(d.driver)).map(d => d.driver);

      buildLapTimeDriversList(drivers);
      renderLapTimeChart();
      renderLapTimeSummaryTable();
    }

    function buildLapTimeDriversList(drivers = null) {
      if (Array.isArray(drivers)) {
        lapTimeAvailableDrivers = drivers.slice();
      }
      const activeDrivers = Array.isArray(drivers) ? drivers : lapTimeAvailableDrivers;
      if (!lapTimeDriversList) return;
      lapTimeDriversList.innerHTML = '';
      if (!activeDrivers || activeDrivers.length === 0) return;

      lapTimeDriverDisplayData = activeDrivers.map(driver => {
        const info = getLapTimeDriverInfo(driver);
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        return {
          key: driver,
          label: displayName,
          color: info.color || '#888888'
        };
      });

      if (!lapTimeDriverManager) {
        lapTimeDriverManager = new DriverSelectionManager({
          container: lapTimeDriversList,
          selectAllId: 'lapTimeSelectAllDrivers',
          selectAllLabel: 'Select All',
          rowTag: 'label',
          rowClass: 'lap-time-driver-item',
          selectAllClass: 'lap-time-driver-item',
          inputIdPrefix: 'lap-time-driver',
          itemsSource: () => lapTimeDriverDisplayData
        });
      }

      lapTimeDriverManager.render();
    }

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();
      const colorMap = {
        'soft': '#FF0000',
        'medium': '#FFF200',
        'hard': '#FFFFFF',
        'intermediate': '#00FF00',
        'wet': '#0000FF'
      };
      return colorMap[compoundLower] || '#999999';
    }

    function renderLapTimeChart() {
      if (lapTimeCurrentGroups.size === 0) {
        if (lapTimeChartInstance) {
          lapTimeChartInstance.clear();
        }
        return;
      }

      if (!lapTimeChartInstance) {
        lapTimeChartInstance = echarts.init(lapTimeChart);
      }

      const fuelAdjusted = appState.lapTime.fuelAdjust;
      const tyreLifeAdjusted = appState.lapTime.tyreLifeAdjust;
      const {
        fuelEffect,
        degHard,
        degMedium,
        degSoft
      } = appState.paceModel;

      const degradationMap = {
        'HARD': degHard,
        'MEDIUM': degMedium,
        'SOFT': degSoft
      };

      const series = [];
      const seriesIndexByDriver = new Map();
      let seriesIdx = 0;

      lapTimeCurrentGroups.forEach((stints, driver) => {
        if (!appState.selectedDrivers.has(driver)) return;

        const stintArray = Array.from(stints.entries()).sort((a, b) => {
          return parseInt(a[0]) - parseInt(b[0]);
        });

        const lastStintIndex = stintArray.length - 1;

        stintArray.forEach(([stintNumber, stintData], stintIndex) => {
          const isLastStint = stintIndex === lastStintIndex;
          const sortedLaps = stintData.laps.slice().sort((a, b) => a.lapNumber - b.lapNumber);

          const data = sortedLaps.map(lap => {
            let adjustedLapTime = lap.lapTime;

            if (fuelAdjusted && !isNaN(lap.schedLaps)) {
              adjustedLapTime -= (lap.schedLaps - lap.lapNumber) * fuelEffect;
            }

            if (tyreLifeAdjusted && !isNaN(lap.tyreLife)) {
              const tyreDeg = degradationMap[lap.compound.toUpperCase()];
              adjustedLapTime -= lap.tyreLife * tyreDeg;
            }

            return {
              value: [lap.lapNumber, adjustedLapTime],
              driver: driver,
              compound: lap.compound,
              stint: stintNumber,
              originalLapTime: lap.lapTime
            };
          });

          const compound = stintData.compound;
          const compoundColor = getF1TireColor(compound);
          const driverColor = lapTimeDriverColors.get(driver) || '#888888';

          if (!seriesIndexByDriver.has(driver)) {
            seriesIndexByDriver.set(driver, []);
          }
          seriesIndexByDriver.get(driver).push(seriesIdx);

          series.push({
            name: `${driver} - Stint ${stintNumber}`,
            type: 'line',
            data: data,
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: compoundColor },
            triggerLineEvent: true,
            itemStyle: {
              color: driverColor,
              borderColor: driverColor,
              borderWidth: 2
            },
            emphasis: {
              focus: 'none',
              lineStyle: { width: 3 },
              scale: true
            },
            blur: {
              lineStyle: { opacity: 0.05 },
              itemStyle: { opacity: 0.05 }
            },
            endLabel: {
              show: isLastStint,
              formatter: driver,
              position: 'right',
              offset: [6, 0],
              color: driverColor,
              fontSize: 11
            },
            animation: false,
            driver: driver
          });

          seriesIdx++;
        });
      });

      const driverSeriesCount = series.length;

      // Detect rainfall, safety car, and red flag laps for the entire session range
      if (lapTimeCurrentSessionRows.length > 0) {
        // Use the full session lap range (1 to scheduled laps, or max lap in data)
        const minLap = 1;
        const maxLap = lapTimeScheduledLaps || Math.max(...lapTimeCurrentSessionRows.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n)));

        const rainfallRanges = detectRainfallLaps(lapTimeCurrentSessionRows, minLap, maxLap);
        const safetyCarRanges = detectSafetyCarLaps(lapTimeCurrentSessionRows, minLap, maxLap);
        const redFlagLaps = detectRedFlagLaps(lapTimeCurrentSessionRows, minLap, maxLap);

        if (rainfallRanges.length > 0) {
          const markAreaData = rainfallRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Rainfall (Lap ${range.start})`
                : `Rainfall (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Rainfall',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: { color: 'rgba(30, 144, 255, 0.1)' },
              data: markAreaData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }

        if (safetyCarRanges.length > 0) {
          const markAreaData = safetyCarRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Safety Car (Lap ${range.start})`
                : `Safety Car (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Safety Car',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: { color: 'rgba(150, 150, 7, 0.15)' },
              data: markAreaData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }

        if (redFlagLaps.length > 0) {
          const markLineData = redFlagLaps.map(lap => ({
            xAxis: lap,
            name: `Red Flag (Lap ${lap})`,
            label: { show: false }
          }));

          series.push({
            name: 'Red Flag',
            type: 'line',
            data: [],
            markLine: {
              silent: false,
              symbol: 'none',
              lineStyle: {
                color: 'rgba(255, 0, 0, 0.5)',
                width: 2,
                type: 'dotted'
              },
              data: markLineData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }
      }

      if (series.length === 0) {
        lapTimeChartInstance.clear();
        return;
      }

      lapTimeChartInstance.setOption({
        backgroundColor: 'transparent',
        grid: { left: 60, right: 100, top: 20, bottom: 60 },
        legend: { show: false },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const data = p.data;
            const lapNumber = data.value[0];
            const lapTime = data.value[1];
            const info = getLapTimeDriverInfo(data.driver);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || data.driver;
              const teamName = info.teamName || '';
              const lapInfo = `
                <div style="margin-top:4px">Lap ${lapNumber}: ${lapTime.toFixed(3)}s</div>
                <div>Compound: ${data.compound}</div>
                <div>Stint: ${data.stint}</div>
              `;
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${data.driver})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${lapInfo}
                  </div>
                </div>
              `;
            }

            return `
              <strong>${data.driver}</strong><br/>
              Lap: ${lapNumber}<br/>
              Time: ${lapTime.toFixed(3)}s<br/>
              Compound: ${data.compound}<br/>
              Stint: ${data.stint}
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Lap Number',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          min: 1,
          max: lapTimeScheduledLaps || 'dataMax'
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true
        },
        series: series
      }, true);

      lapTimeChartInstance.resize();

      // Custom hover behavior
      lapTimeChartInstance.off('mouseover');
      lapTimeChartInstance.off('mouseout');

      let currentHoveredDriver = null;

      lapTimeChartInstance.on('mouseover', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          const hoveredDriver = params.seriesName.split(' - ')[0];

          if (currentHoveredDriver === hoveredDriver) return;
          currentHoveredDriver = hoveredDriver;

          const driverSeriesIndices = seriesIndexByDriver.get(hoveredDriver) || [];

          const updatedSeries = series.map((s, idx) => {
            if (idx >= driverSeriesCount) return {};

            if (driverSeriesIndices.includes(idx)) {
              return {
                lineStyle: { width: 3, color: s.lineStyle.color, opacity: 1 },
                itemStyle: { ...s.itemStyle, opacity: 1 },
                endLabel: { ...s.endLabel, opacity: 1 }
              };
            } else {
              return {
                lineStyle: { width: 2, color: s.lineStyle.color, opacity: 0.15 },
                itemStyle: { ...s.itemStyle, opacity: 0.05 },
                endLabel: { ...s.endLabel, opacity: 0.15 }
              };
            }
          });

          lapTimeChartInstance.setOption({ series: updatedSeries });
        }
      });

      lapTimeChartInstance.on('mouseout', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          currentHoveredDriver = null;

          const resetSeries = series.map((s, idx) => {
            if (idx >= driverSeriesCount) return {};
            return {
              lineStyle: { width: 2, color: s.lineStyle.color, opacity: 1 },
              itemStyle: { ...s.itemStyle, opacity: 1 },
              endLabel: { ...s.endLabel, opacity: 1 }
            };
          });

          lapTimeChartInstance.setOption({ series: resetSeries });
        }
      });
    }

    function renderLapTimeSummaryTable() {
      const container = document.getElementById('lapTimeSummaryTableContainer');

      if (lapTimeCurrentGroups.size === 0) {
        container.innerHTML = '';
        return;
      }

      // Get adjustment settings
      const fuelAdjusted = appState.lapTime.fuelAdjust;
      const tyreLifeAdjusted = appState.lapTime.tyreLifeAdjust;
      const {
        fuelEffect,
        degHard,
        degMedium,
        degSoft
      } = appState.paceModel;

      const degradationMap = {
        'HARD': degHard,
        'MEDIUM': degMedium,
        'SOFT': degSoft
      };

      // Process data: group by driver and compound, calculate averages
      const driverCompoundData = new Map(); // driver -> { SOFT: [times], MEDIUM: [times], HARD: [times] }
      const compoundLapCounts = { 'SOFT': 0, 'MEDIUM': 0, 'HARD': 0 };

      lapTimeCurrentGroups.forEach((stints, driver) => {
        if (!driverCompoundData.has(driver)) {
          driverCompoundData.set(driver, {});
        }
        const driverData = driverCompoundData.get(driver);

        stints.forEach((stintData, stintNumber) => {
          const compound = stintData.compound.toUpperCase();
          if (!['SOFT', 'MEDIUM', 'HARD'].includes(compound)) return;

          if (!driverData[compound]) {
            driverData[compound] = [];
          }

          stintData.laps.forEach(lap => {
            let adjustedLapTime = lap.lapTime;

            if (fuelAdjusted && !isNaN(lap.schedLaps)) {
              adjustedLapTime -= (lap.schedLaps - lap.lapNumber) * fuelEffect;
            }

            if (tyreLifeAdjusted && !isNaN(lap.tyreLife)) {
              const tyreDeg = degradationMap[compound];
              adjustedLapTime -= lap.tyreLife * tyreDeg;
            }

            driverData[compound].push(adjustedLapTime);
            compoundLapCounts[compound]++;
          });
        });
      });

      // Calculate averages for each driver-compound combination
      const driverAverages = new Map(); // driver -> { SOFT: avg, MEDIUM: avg, HARD: avg }
      driverCompoundData.forEach((compoundData, driver) => {
        const averages = {};
        Object.keys(compoundData).forEach(compound => {
          const times = compoundData[compound];
          if (times.length > 0) {
            averages[compound] = times.reduce((a, b) => a + b, 0) / times.length;
          }
        });
        driverAverages.set(driver, averages);
      });

      // Determine reference compound (compound with most laps total across all drivers)
      let referenceCompound = 'MEDIUM';
      let maxLaps = 0;
      Object.keys(compoundLapCounts).forEach(compound => {
        if (compoundLapCounts[compound] > maxLaps) {
          maxLaps = compoundLapCounts[compound];
          referenceCompound = compound;
        }
      });

      // Build table
      const table = document.createElement('table');
      table.id = 'lapTimeSummaryTable';

      // Header row
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');

      const headers = [
        { text: 'Select', isCheckbox: true },
        { text: 'Driver' },
        { text: 'SOFT' },
        { text: 'MEDIUM' },
        { text: 'HARD' }
      ];

      headers.forEach((header, index) => {
        const th = document.createElement('th');

        if (header.isCheckbox) {
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = 'lapTimeSummarySelectAllCheckbox';
          checkbox.className = 'stint-checkbox';
          th.appendChild(checkbox);
        } else if (index > 1) {
          // Compound columns
          th.textContent = header.text;
          if (header.text === referenceCompound) {
            th.textContent += ' (ref)';
          }
          th.style.color = getF1TireColor(header.text);
        } else {
          th.textContent = header.text;
        }

        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Body
      const tbody = document.createElement('tbody');

      // Average row at top
      const avgRow = document.createElement('tr');

      // Empty checkbox cell for average row
      const avgCheckboxCell = document.createElement('td');
      avgRow.appendChild(avgCheckboxCell);

      const avgDriverCell = document.createElement('td');
      avgDriverCell.textContent = 'Average';
      avgDriverCell.style.color = 'var(--accent-color)';
      avgDriverCell.style.fontWeight = '600';
      avgRow.appendChild(avgDriverCell);

      ['SOFT', 'MEDIUM', 'HARD'].forEach(compound => {
        const td = document.createElement('td');
        td.style.textAlign = 'center';
        td.style.fontWeight = '600';

        // Calculate average for selected drivers only
        const values = [];
        lapTimeDriverOrder.forEach(({ driver }) => {
          if (!appState.selectedDrivers.has(driver)) return;
          const driverData = driverAverages.get(driver);
          if (driverData && driverData[compound] !== undefined) {
            values.push(driverData[compound]);
          }
        });

        if (values.length > 0) {
          const avg = values.reduce((a, b) => a + b, 0) / values.length;

          // Calculate reference average for delta
          const refValues = [];
          lapTimeDriverOrder.forEach(({ driver }) => {
            if (!appState.selectedDrivers.has(driver)) return;
            const driverData = driverAverages.get(driver);
            if (driverData && driverData[referenceCompound] !== undefined) {
              refValues.push(driverData[referenceCompound]);
            }
          });
          const refAvg = refValues.length > 0 ? refValues.reduce((a, b) => a + b, 0) / refValues.length : 0;

          td.innerHTML = avg.toFixed(3);
          if (compound !== referenceCompound && refAvg > 0) {
            const delta = avg - refAvg;
            const deltaStr = delta >= 0 ? `+${delta.toFixed(3)}` : delta.toFixed(3);
            const deltaColor = delta < 0 ? '#00ff00' : '#ff0000';
            td.innerHTML += ` <span style="color: ${deltaColor};">(${deltaStr})</span>`;
          }
        } else {
          td.textContent = '-';
          td.style.color = 'var(--muted-color)';
        }

        avgRow.appendChild(td);
      });

      // Store compound averages for the copy button
      const compoundAverages = new Map();
      ['SOFT', 'MEDIUM', 'HARD'].forEach(compound => {
        const values = [];
        lapTimeDriverOrder.forEach(({ driver }) => {
          if (!appState.selectedDrivers.has(driver)) return;
          const driverData = driverAverages.get(driver);
          if (driverData && driverData[compound] !== undefined) {
            values.push(driverData[compound]);
          }
        });
        if (values.length > 0) {
          const avg = values.reduce((a, b) => a + b, 0) / values.length;
          compoundAverages.set(compound, avg);
        }
      });

      tbody.appendChild(avgRow);

      // Driver rows (in finishing order)
      const summaryCheckboxItems = [];

      lapTimeDriverOrder.forEach(({ driver }) => {
        if (!driverAverages.has(driver)) return; // Skip drivers with no data

        const tr = document.createElement('tr');

        // Select checkbox
        const tdCheckbox = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'stint-checkbox';
        tdCheckbox.appendChild(checkbox);
        tr.appendChild(tdCheckbox);
        summaryCheckboxItems.push({ key: driver, checkbox, rowElement: tr });

        // Driver name cell
        const driverCell = document.createElement('td');
        const info = getLapTimeDriverInfo(driver);
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        driverCell.textContent = displayName;
        const driverColor = lapTimeDriverColors.get(driver) || '#888888';
        driverCell.style.color = driverColor;
        driverCell.style.fontWeight = '600';
        tr.appendChild(driverCell);

        // Compound cells
        const driverData = driverAverages.get(driver);
        const isSelected = appState.selectedDrivers.has(driver);

        ['SOFT', 'MEDIUM', 'HARD'].forEach(compound => {
          const td = document.createElement('td');
          td.style.textAlign = 'center';

          // Show dash if driver not selected or no data for this compound
          if (!isSelected || driverData[compound] === undefined) {
            td.textContent = '-';
            td.style.color = 'var(--muted-color)';
          } else {
            const avg = driverData[compound];
            const refAvg = driverData[referenceCompound];

            td.innerHTML = avg.toFixed(3);
            if (compound !== referenceCompound && refAvg !== undefined) {
              const delta = avg - refAvg;
              const deltaStr = delta >= 0 ? `+${delta.toFixed(3)}` : delta.toFixed(3);
              const deltaColor = delta < 0 ? '#00ff00' : '#ff0000';
              td.innerHTML += ` <span style="color: ${deltaColor};">(${deltaStr})</span>`;
            }
          }

          tr.appendChild(td);
        });

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);

      // Create button to copy averages to calculator
      const buttonContainer = document.createElement('div');
      buttonContainer.style.cssText = 'margin-bottom: 12px; display: flex; justify-content: flex-start;';

      const copyButton = document.createElement('button');
      copyButton.textContent = 'Copy Averages to Calculator';
      copyButton.style.cssText = `
        padding: 6px 12px;
        font-size: 11px;
        background: var(--accent-color);
        color: var(--bg-color);
        border: none;
        border-radius: 4px;
        cursor: pointer;
        font-weight: 600;
      `;
      copyButton.addEventListener('click', () => {
        // Update calculator pace inputs
        if (compoundAverages.has('SOFT')) {
          const value = parseFloat(compoundAverages.get('SOFT').toFixed(3));
          saveToState('calculator.paceS', value);
        }
        if (compoundAverages.has('MEDIUM')) {
          const value = parseFloat(compoundAverages.get('MEDIUM').toFixed(3));
          saveToState('calculator.paceM', value);
        }
        if (compoundAverages.has('HARD')) {
          const value = parseFloat(compoundAverages.get('HARD').toFixed(3));
          saveToState('calculator.paceH', value);
        }
        renderCalculatorInputsFromState();

        // Visual feedback
        copyButton.textContent = 'Copied!';
        setTimeout(() => {
          copyButton.textContent = 'Copy Averages to Calculator';
        }, 1000);
      });

      buttonContainer.appendChild(copyButton);

      container.innerHTML = '';
      container.appendChild(buttonContainer);
      container.appendChild(table);

      // Attach select all checkbox listener
      const selectAllCheckbox = document.getElementById('lapTimeSummarySelectAllCheckbox');
      if (!lapTimeSummaryCheckboxManager) {
        lapTimeSummaryCheckboxManager = new TableCheckboxManager({
          selectAllId: 'lapTimeSummarySelectAllCheckbox',
          getSelectionSet: () => appState.selectedDrivers,
          selectionUpdater: (mutator) => updateSelectedDrivers(mutator)
        });
      }
      lapTimeSummaryCheckboxManager.setStructure({
        selectAllElement: selectAllCheckbox,
        items: summaryCheckboxItems
      });
      lapTimeSummaryCheckboxManager.render();
    }

    const pitLossTableContainer = document.getElementById('pitLossTableContainer');
    const pitLossAverageText = document.getElementById('pitLossAverage');
    const pitLossMedianText = document.getElementById('pitLossMedian');
    const copyPitLossAverageBtn = document.getElementById('copyPitLossAverageBtn');
    let pitLossEvents = [];

    function computePitLossStats() {
      const selected = pitLossEvents.filter(event => appState.pitLossTab.selectedKeys.has(event.key));
      const values = selected.map(event => event.pitLoss);
      if (values.length === 0) {
        return { average: null, median: null, count: 0 };
      }
      const average = values.reduce((sum, value) => sum + value, 0) / values.length;
      const sorted = values.slice().sort((a, b) => a - b);
      const mid = Math.floor(sorted.length / 2);
      const median = sorted.length % 2 === 1
        ? sorted[mid]
        : (sorted[mid - 1] + sorted[mid]) / 2;
      return { average, median, count: values.length };
    }

    function renderPitLossStats() {
      const stats = computePitLossStats();
      if (pitLossAverageText) {
        pitLossAverageText.textContent = Number.isFinite(stats.average) ? stats.average.toFixed(3) : '—';
      }
      if (pitLossMedianText) {
        pitLossMedianText.textContent = Number.isFinite(stats.median) ? stats.median.toFixed(3) : '—';
      }
    }

    function persistPitLossSelection() {
      saveToState('pitLossTab.selectedKeys', new Set(appState.pitLossTab.selectedKeys));
    }

    function renderPitLossTable() {
      if (!pitLossTableContainer) return;
      if (pitLossEvents.length === 0) {
        pitLossTableContainer.innerHTML = '<p>No pit-loss events identified for this session.</p>';
        return;
      }

      const table = document.createElement('table');
      table.className = 'pit-loss-table';
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');
      ['Select', 'Driver', 'Lap #', 'Pit Loss (s)'].forEach(text => {
        const th = document.createElement('th');
        th.textContent = text;
        headerRow.appendChild(th);
      });
      thead.appendChild(headerRow);
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      pitLossEvents.forEach(event => {
        const row = document.createElement('tr');
        const isSelected = appState.pitLossTab.selectedKeys.has(event.key);

        const selectTd = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'pit-loss-checkbox';
        checkbox.dataset.key = event.key;
        checkbox.checked = isSelected;
        selectTd.appendChild(checkbox);
        row.appendChild(selectTd);

        const driverTd = document.createElement('td');
        // Lookup driver full name and color (fall back gracefully)
        const info = (typeof DriverInfo !== 'undefined' && DriverInfo.getDriverInfo)
          ? DriverInfo.getDriverInfo(event.driver, event.year, event.round, event.sessionType)
          : { fullName: event.driver, color: '#888888' };

        const nameSpan = document.createElement('span');
        nameSpan.textContent = info.fullName || event.driver;
        // Color the driver name with their team/driver color
        nameSpan.style.color = info.color || '#888888';
        nameSpan.style.fontWeight = '600';
        nameSpan.style.verticalAlign = 'middle';
        nameSpan.style.whiteSpace = 'nowrap';

        driverTd.appendChild(nameSpan);
        row.appendChild(driverTd);

        const pitTd = document.createElement('td');
        pitTd.textContent = event.pitInLapNum;
        row.appendChild(pitTd);

        const lossTd = document.createElement('td');
        lossTd.textContent = event.pitLoss.toFixed(3);
        row.appendChild(lossTd);

        row.classList.toggle('selected', isSelected);
        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      pitLossTableContainer.innerHTML = '';
      pitLossTableContainer.appendChild(table);
    }

    function updatePitLossSelectionKeys() {
      const validKeys = new Set(pitLossEvents.map(event => event.key));
      appState.pitLossTab.selectedKeys.forEach(key => {
        if (!validKeys.has(key)) {
          appState.pitLossTab.selectedKeys.delete(key);
        }
      });
      if (appState.pitLossTab.selectedKeys.size === 0) {
        pitLossEvents.forEach(event => appState.pitLossTab.selectedKeys.add(event.key));
      }
      persistPitLossSelection();
    }

    function processPitLossData(sessionData) {
      pitLossEvents = [];
      if (!sessionData || sessionData.length === 0) {
        renderPitLossStats();
        renderPitLossTable();
        return [];
      }

      const rows = sessionData;
      if (!rows || rows.length === 0) {
        renderPitLossStats();
        renderPitLossTable();
        return [];
      }

      const driverLaps = new Map();
      rows.forEach(row => {
        const driver = String(row.lap_Driver || "").trim();
        if (!driver) return;
        if (!driverLaps.has(driver)) {
          driverLaps.set(driver, []);
        }
        driverLaps.get(driver).push(row);
      });

  const events = [];
  // derive session identifiers from the data so we can lookup driver metadata
  const firstRow = rows.length > 0 ? rows[0] : null;
  const sessYear = firstRow ? String(firstRow.year || "").trim() : '';
  const sessRound = firstRow ? String(firstRow.round_no || "").trim() : '';
  const sessType = firstRow ? String(firstRow.session_type || "").trim() : '';
      driverLaps.forEach((rows, driver) => {
        const sortedRows = rows.slice().sort((a, b) => {
          const aLap = parseFloat(a.lap_LapNumber);
          const bLap = parseFloat(b.lap_LapNumber);
          return (Number.isFinite(aLap) ? aLap : 0) - (Number.isFinite(bLap) ? bLap : 0);
        });

        const lapLookup = new Map();
        sortedRows.forEach(row => {
          const lapNum = parseInt(row.lap_LapNumber, 10);
          if (!Number.isFinite(lapNum)) return;
          lapLookup.set(lapNum, row);
        });

        const pitInRows = sortedRows
          .map(row => ({
            row,
            lapNum: parseInt(row.lap_LapNumber, 10),
            hasPitIn: row.lap_PitInTime.trim() !== '',
          }))
          .filter(entry => Number.isFinite(entry.lapNum) && entry.hasPitIn);

        let pitIndex = 0;
        for (let i = 0; i < pitInRows.length; i++) {
          const pitInLapNum = pitInRows[i].lapNum;
          const pitInLap = lapLookup.get(pitInLapNum);
          // check that pitInLapNum + 1 is in the lookup
          if (!lapLookup.has(pitInLapNum + 1) || !lapLookup.has(pitInLapNum-1) || !lapLookup.has(pitInLapNum+2)) continue;

          const pitOutLap = lapLookup.get(pitInLapNum + 1);
          if (pitOutLap.lap_PitOutTime.trim() === '') continue;

          const beforeLap = lapLookup.get(pitInLapNum - 1);
          const afterLap = lapLookup.get(pitInLapNum + 2);
          const pitLoss = parseFloat(pitInLap.lap_LapTime) + parseFloat(pitOutLap.lap_LapTime) - (parseFloat(beforeLap.lap_LapTime) + parseFloat(afterLap.lap_LapTime));

            events.push({
              key: `${driver}||${pitInLapNum}||${pitIndex}`,
              pitInLapNum,
              driver,
              pitIndex,
              pitLoss,
              year: sessYear,
              round: sessRound,
              sessionType: sessType
            });
          pitIndex++;
        }
      });

      events.sort((a, b) => {return b.pitLoss - a.pitLoss});

      pitLossEvents = events;
      updatePitLossSelectionKeys();
      renderPitLossStats();
      renderPitLossTable();
      return events;
    }

    if (pitLossTableContainer) {
      pitLossTableContainer.addEventListener('change', (event) => {
        const checkbox = event.target.closest('.pit-loss-checkbox');
        if (!checkbox) return;
        const key = checkbox.dataset.key;
        if (!key) return;
        if (checkbox.checked) {
          appState.pitLossTab.selectedKeys.add(key);
        } else {
          appState.pitLossTab.selectedKeys.delete(key);
        }
        persistPitLossSelection();
        renderPitLossStats();
      });
    }

    if (copyPitLossAverageBtn) {
      copyPitLossAverageBtn.addEventListener('click', () => {
        const stats = computePitLossStats();
        if (!Number.isFinite(stats.median)) {
          return;
        }
        const value = parseFloat(stats.median.toFixed(3));
        saveToState('calculator.pitLoss', value);
        renderCalculatorInputsFromState();
        const originalText = copyPitLossAverageBtn.textContent;
        copyPitLossAverageBtn.textContent = 'Copied!';
        setTimeout(() => {
          copyPitLossAverageBtn.textContent = originalText;
        }, 1200);
      });
    }

    // Handle window resize for lap time chart
    window.addEventListener('resize', () => {
      if (lapTimeChartInstance) {
        lapTimeChartInstance.resize();
      }
      if (tyreDegScatterChartInstance) {
        tyreDegScatterChartInstance.resize();
      }
      if (tyreDegLapTimeChartInstance) {
        tyreDegLapTimeChartInstance.resize();
      }
    });

    // Tyre Degradation Panel
    const tyreDegTyreChoicesDisplay = document.getElementById('tyreDegTyreChoicesDisplay');
    const tyreDegTyreChoicesText = document.getElementById('tyreDegTyreChoicesText');
    const tyreDegAvgDegDisplay = document.getElementById('tyreDegAvgDegDisplay');
    const tyreDegAvgDegText = document.getElementById('tyreDegAvgDegText');
    const tyreDegChartsWrapper = document.getElementById('tyreDegChartsWrapper');
    const tyreDegScatterChart = document.getElementById('tyreDegScatterChart');
    const tyreDegLapTimeChart = document.getElementById('tyreDegLapTimeChart');
    const tyreDegEquationsSection = document.getElementById('tyreDegEquationsSection');
    const tyreDegEquationsGrid = document.getElementById('tyreDegEquationsGrid');
    const tyreDegFuelAdjustToggle = document.getElementById('tyreDegFuelAdjustToggle');
    const tyreDegSelectedStintCount = document.getElementById('tyreDegSelectedStintCount');
    const tyreDegStintsTableContainer = document.getElementById('tyreDegStintsTableContainer');

    let tyreDegScatterChartInstance = null;
    let tyreDegLapTimeChartInstance = null;
    let tyreDegFilteredGroups = new Map();
    let tyreDegTyreChoices = new Map();

    // Mappings for synchronized hover between charts
    let scatterStintToPoint = new Map(); // stint key -> {seriesIndex, dataIndex} in scatter chart
    let lapTimeStintToSeriesIndex = new Map(); // stint key -> series index in lap time chart

    // Dropdown menu tracking
    const tyreDegDropdownState = { dropdown: null, column: null };

    // Load tyre choices
    function loadTyreDegTyreChoices() {
      ParsedDataCache.loadCSV("tyre_choices.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.data) {
            results.data.forEach(row => {
              const year = String(row.year || "").trim();
              const round = String(row.round_no || "").trim();
              if (year && round) {
                const key = `${year}||${round}`;
                tyreDegTyreChoices.set(key, {
                  hard: String(row.hard || "").trim(),
                  medium: String(row.medium || "").trim(),
                  soft: String(row.soft || "").trim()
                });
              }
            });
          }
        },
        error: function (err) {
          console.error("Error loading tyre_choices.csv:", err);
        }
      });
    }

    loadTyreDegTyreChoices();

    // Set up filter listeners for tyre deg panel
    function setupTyreDegFilterListeners() {
      const minRowsInput = document.getElementById('tyreDegFilterMinRows');
      const minCorrInput = document.getElementById('tyreDegFilterMinCorr');

      if (minRowsInput) {
        minRowsInput.addEventListener('input', () => {
          updateTyreDegFilterState('filterMinRows', minRowsInput.value);
          if (currentSessionData && currentSessionData.length > 0) {
            processTyreDegData(currentSessionData);
          }
        });
      }

      if (minCorrInput) {
        minCorrInput.addEventListener('input', () => {
          updateTyreDegFilterState('filterMinCorr', minCorrInput.value);
          if (currentSessionData && currentSessionData.length > 0) {
            processTyreDegData(currentSessionData);
          }
        });
      }

      // Fuel effect slider
      const slider = document.getElementById('tyreDegFuelEffectSlider');
      const value = document.getElementById('tyreDegFuelEffectValue');
      slider.addEventListener('input', function() {
        const numericValue = parseFloat(this.value);
        if (!Number.isFinite(numericValue)) return;
        saveToState('paceModel.fuelEffect', numericValue);
        renderPaceModelInputsFromState();
        onLapTimeAdjustmentChange();
        if (currentSessionData && currentSessionData.length > 0) {
          processTyreDegData(currentSessionData);
        }
      });

      // Fuel adjust toggle for lap time chart
      tyreDegFuelAdjustToggle.addEventListener('click', function() {
        // Toggle state in appState first
        const newValue = !appState.tyreDeg.fuelAdjust;
        saveToState('tyreDeg.fuelAdjust', newValue);
        renderTyreDegToggleInputsFromState();
        renderTyreDegLapTimeChart();
      });
    }

    setupTyreDegFilterListeners();

    // Generic helper for header dropdown filtering in tables
    function attachHeaderDropdowns({
      tableSelector,
      groupsMap,
      getColumnValue,
      onSelectByValue,
      activeDropdownRef
    }) {
      document.querySelectorAll(`${tableSelector} .clickable-header`).forEach(header => {
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);

        newHeader.addEventListener('click', function(e) {
          e.stopPropagation();
          const column = this.dataset.column;
          const { dropdown, column: activeCol } = activeDropdownRef;

          // Toggle: if clicking same header, close dropdown
          if (dropdown && activeCol === column) {
            dropdown.remove();
            activeDropdownRef.dropdown = null;
            activeDropdownRef.column = null;
            return;
          }

          // Close any existing dropdown
          if (dropdown) {
            dropdown.remove();
            activeDropdownRef.dropdown = null;
          }

          const table = this.closest('table');
          const tableRect = table.getBoundingClientRect();
          const headerRect = this.getBoundingClientRect();

          // Get unique values for this column
          const uniqueValues = new Set();
          groupsMap.forEach(group => {
            const val = getColumnValue(group, column);
            if (val != null && val !== '') uniqueValues.add(val);
          });

          // Create dropdown
          const dd = document.createElement('div');
          dd.className = 'header-dropdown show';
          dd.style.left = `${headerRect.left - tableRect.left}px`;
          dd.style.top = `${headerRect.bottom - tableRect.top}px`;

          // Add options
          Array.from(uniqueValues).sort().forEach(value => {
            const option = document.createElement('div');
            option.className = 'dropdown-option';

            const label = document.createElement('span');
            label.className = 'dropdown-option-label';
            label.textContent = value;

            const buttons = document.createElement('div');
            buttons.className = 'dropdown-option-buttons';

            const selectBtn = document.createElement('button');
            selectBtn.className = 'dropdown-btn';
            selectBtn.textContent = 'Select';
            selectBtn.addEventListener('click', function(ev) {
              ev.stopPropagation();
              onSelectByValue(column, value, true);
            });

            const clearBtn = document.createElement('button');
            clearBtn.className = 'dropdown-btn';
            clearBtn.textContent = 'Clear';
            clearBtn.addEventListener('click', function(ev) {
              ev.stopPropagation();
              onSelectByValue(column, value, false);
            });

            buttons.appendChild(selectBtn);
            buttons.appendChild(clearBtn);
            option.appendChild(label);
            option.appendChild(buttons);
            dd.appendChild(option);
          });

          table.appendChild(dd);
          activeDropdownRef.dropdown = dd;
          activeDropdownRef.column = column;
        });
      });
    }

    setupSharedFilterStateSync();

    // Set up document-level click listener for closing dropdowns
    document.addEventListener('click', function(e) {
      if (tyreDegDropdownState.dropdown && !e.target.closest('.clickable-header') && !e.target.closest('.header-dropdown')) {
        tyreDegDropdownState.dropdown.remove();
        tyreDegDropdownState.dropdown = null;
        tyreDegDropdownState.column = null;
      }
      if (fuelEffectDropdownState.dropdown && !e.target.closest('.clickable-header') && !e.target.closest('.header-dropdown')) {
        fuelEffectDropdownState.dropdown.remove();
        fuelEffectDropdownState.dropdown = null;
        fuelEffectDropdownState.column = null;
      }
    });

    function processTyreDegData(sessionData) {
      const filteredRows = applySharedFilters(sessionData);

      // Group by driver and stint
      const groups = new Map();

      filteredRows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const stint = String(r.lap_Stint || "").trim();
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const sessionType = String(r.session_type || "").trim();

        if (!driver || !stint) return;

        const key = `${year}||${round}||${meeting}||${driver}||${sessionType}||${stint}`;

        if (!groups.has(key)) {
          groups.set(key, {
            lap_Driver: driver,
            event: `${year} - ${round}. ${meeting}`,
            session_type: sessionType,
            lap_Stint: stint,
            rows: []
          });
        }

        groups.get(key).rows.push(r);
      });

      // Calculate regression for each group
      const minRows = Number.isFinite(appState.tyreDeg.filterMinRows)
        ? appState.tyreDeg.filterMinRows
        : 5;
      const minCorr = Number.isFinite(appState.tyreDeg.filterMinCorr)
        ? appState.tyreDeg.filterMinCorr
        : -1.0;

      // Track previous stints
      const previousStints = new Set(window.tyreDegPreviousFilteredStints || []);
      const isEventChange = previousStints.size === 0 && groups.size > 0;

      tyreDegFilteredGroups = new Map();

      groups.forEach((group, key) => {
        if (group.rows.length >= minRows) {
          group.regressionStats = calculateRegressionStats(group.rows);

          if (group.regressionStats.correlation >= minCorr) {
            // Calculate additional fields
            const tyreLifeValues = group.rows.map(r => parseFloat(r.lap_TyreLife)).filter(v => !isNaN(v));
            const lapNumberValues = group.rows.map(r => parseFloat(r.lap_LapNumber)).filter(v => !isNaN(v));
            const schedLapsValue = parseInt(group.rows[0]?.sched_laps);

            group.minTyreLife = tyreLifeValues.length > 0 ? Math.min(...tyreLifeValues) : 0;
            const minLapNum = lapNumberValues.length > 0 ? Math.min(...lapNumberValues) : 0;
            group.lapsToGo = !isNaN(schedLapsValue) && schedLapsValue > 0 ? schedLapsValue - minLapNum : 0;
            group.compound = group.rows[0]?.lap_Compound || '-';
            group.finishStatus = group.rows[0]?.finish_status || '-';
            group.schedLaps = schedLapsValue || '-';

            tyreDegFilteredGroups.set(key, group);
          }
        }
      });

      // Handle stint selection on event change
      if (isEventChange) {
        // Event changed - restore from state or select all
        // Note: Don't clear here - restoreDataDependentSelections needs to read
        // the current values (which may have been loaded from URL) before validating them
        restoreDataDependentSelections('tyre-deg');

        // If no stints were restored from state, select all stints
        if (appState.tyreDeg.selectedStints.size === 0) {
          tyreDegFilteredGroups.forEach((group, key) => {
            appState.tyreDeg.selectedStints.add(key);
          });
        }
      } else {
        // Filter changed - maintain selection only for stints that were in previous view
        const stintsToKeep = new Set();
        appState.tyreDeg.selectedStints.forEach(key => {
          if (tyreDegFilteredGroups.has(key) && previousStints.has(key)) {
            stintsToKeep.add(key);
          }
        });

        // Auto-select any newly visible stints
        tyreDegFilteredGroups.forEach((group, key) => {
          if (!previousStints.has(key)) {
            stintsToKeep.add(key);
          }
        });

        appState.tyreDeg.selectedStints.clear();
        stintsToKeep.forEach(key => appState.tyreDeg.selectedStints.add(key));
      }

      // Store current stints for next comparison
      window.tyreDegPreviousFilteredStints = Array.from(tyreDegFilteredGroups.keys());

      // Render table and charts
      renderTyreDegStintsTable();
      renderTyreDegScatterChart();
      renderTyreDegLapTimeChart();
    }

    function calculateRegressionStats(rows) {
      // Simplified regression calculation
      // In production, would use simple-statistics library
      const pairs = rows.map(r => {
        const tyreLife = parseInt(r.lap_TyreLife);
        const lapTime = parseFloat(r.lap_LapTime);
        return { x: tyreLife, y: lapTime };
      }).filter(p => !isNaN(p.x) && !isNaN(p.y));

      if (pairs.length < 2) {
        return { slope: '-', intercept: '-', correlation: 0, rmse: '-' };
      }

      // Simple linear regression calculation
      const n = pairs.length;
      const sumX = pairs.reduce((sum, p) => sum + p.x, 0);
      const sumY = pairs.reduce((sum, p) => sum + p.y, 0);
      const sumXY = pairs.reduce((sum, p) => sum + p.x * p.y, 0);
      const sumX2 = pairs.reduce((sum, p) => sum + p.x * p.x, 0);
      const sumY2 = pairs.reduce((sum, p) => sum + p.y * p.y, 0);

      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;

      const correlation = (n * sumXY - sumX * sumY) /
        Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

      // Calculate RMSE (Root Mean Square Error)
      let sumSquaredErrors = 0;
      pairs.forEach(p => {
        const predicted = slope * p.x + intercept;
        const error = p.y - predicted;
        sumSquaredErrors += error * error;
      });
      const rmse = Math.sqrt(sumSquaredErrors / n);

      return {
        slope: isFinite(slope) ? slope.toFixed(4) : '-',
        intercept: isFinite(intercept) ? intercept.toFixed(3) : '-',
        correlation: isFinite(correlation) ? correlation : 0,
        rmse: isFinite(rmse) ? rmse.toFixed(4) : '-'
      };
    }

    function renderTyreDegStintsTable() {
      if (tyreDegFilteredGroups.size === 0) {
        tyreDegStintsTableContainer.innerHTML = `
          <p style="color: var(--muted-color); padding: 20px; text-align: center;">
            No stints match the current filters
          </p>
        `;
        tyreDegChartsWrapper.style.display = 'none';
        const tyreDegScatterChartWrapper = document.getElementById('tyreDegScatterChartWrapper');
        if (tyreDegScatterChartWrapper) tyreDegScatterChartWrapper.style.display = 'none';
        return;
      }

      tyreDegChartsWrapper.style.display = 'block';
      const tyreDegScatterChartWrapper = document.getElementById('tyreDegScatterChartWrapper');
      if (tyreDegScatterChartWrapper) tyreDegScatterChartWrapper.style.display = 'block';

      const fuelEffect = parseFloat(document.getElementById('tyreDegFuelEffectSlider').value);

      const table = document.createElement('table');
      table.id = 'tyreDegStintsTable';

      // Header row
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');

      const headers = [
        { text: 'Select', isCheckbox: true },
        { text: 'Event' },
        { text: 'Driver', clickable: true, column: 'driver' },
        { text: 'Session Type', clickable: true, column: 'session_type' },
        { text: 'Stint' },
        { text: 'Lap Count' },
        { text: 'Sched Laps' },
        { text: 'Compound', clickable: true, column: 'compound' },
        { text: 'Finish Status' },
        { text: 'Min Tyre Life' },
        { text: 'Laps to Go' },
        { text: 'Deg' },
        { text: 'Pace' },
        { text: 'Correlation' },
        { text: 'RMSE' }
      ];

      headers.forEach(header => {
        const th = document.createElement('th');

        if (header.isCheckbox) {
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = 'tyreDegSelectAllCheckbox';
          checkbox.className = 'stint-checkbox';
          th.appendChild(checkbox);
        } else if (header.clickable) {
          th.textContent = header.text;
          th.className = 'clickable-header';
          th.dataset.column = header.column;
        } else {
          th.textContent = header.text;
        }

        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Body
      const tbody = document.createElement('tbody');

      // Sort by compound, then driver, then session type, then stint
      const sortedGroups = Array.from(tyreDegFilteredGroups.entries()).sort((a, b) => {
        const [keyA, groupA] = a;
        const [keyB, groupB] = b;

        // Sort by compound first
        if (groupA.compound !== groupB.compound) {
          return groupA.compound.localeCompare(groupB.compound);
        }

        // Then by driver
        if (groupA.lap_Driver !== groupB.lap_Driver) {
          return groupA.lap_Driver.localeCompare(groupB.lap_Driver);
        }

        // Then by session type
        if (groupA.session_type !== groupB.session_type) {
          return groupA.session_type.localeCompare(groupB.session_type);
        }

        // Finally by stint
        return parseInt(groupA.lap_Stint) - parseInt(groupB.lap_Stint);
      });

      const tableSelectionItems = [];

      sortedGroups.forEach(([key, group]) => {
        const tr = document.createElement('tr');
        if (appState.tyreDeg.selectedStints.has(key)) {
          tr.classList.add('stint-selected');
        }

        // Select checkbox
        const tdCheckbox = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'stint-checkbox';
        tdCheckbox.appendChild(checkbox);
        tr.appendChild(tdCheckbox);
        tableSelectionItems.push({ key, checkbox, rowElement: tr });

        // Event
        const tdEvent = document.createElement('td');
        tdEvent.textContent = group.event;
        tr.appendChild(tdEvent);

        // Driver
        const tdDriver = document.createElement('td');
        tdDriver.textContent = group.lap_Driver;
        tr.appendChild(tdDriver);

        // Session Type
        const tdSessionType = document.createElement('td');
        tdSessionType.textContent = group.session_type;
        tr.appendChild(tdSessionType);

        // Stint
        const tdStint = document.createElement('td');
        tdStint.textContent = group.lap_Stint;
        tr.appendChild(tdStint);

        // Lap Count
        const tdLapCount = document.createElement('td');
        tdLapCount.textContent = group.rows.length;
        tr.appendChild(tdLapCount);

        // Sched Laps
        const tdSchedLaps = document.createElement('td');
        tdSchedLaps.textContent = group.schedLaps;
        tr.appendChild(tdSchedLaps);

        // Compound
        const tdCompound = document.createElement('td');
        tdCompound.textContent = group.compound;
        tdCompound.style.color = getF1TireColor(group.compound);
        tdCompound.style.fontWeight = '600';
        tr.appendChild(tdCompound);

        // Finish Status
        const tdFinishStatus = document.createElement('td');
        tdFinishStatus.textContent = group.finishStatus;
        tr.appendChild(tdFinishStatus);

        // Min Tyre Life
        const tdMinTyreLife = document.createElement('td');
        tdMinTyreLife.textContent = group.minTyreLife;
        tr.appendChild(tdMinTyreLife);

        // Laps to Go
        const tdLapsToGo = document.createElement('td');
        tdLapsToGo.textContent = group.lapsToGo;
        tr.appendChild(tdLapsToGo);

        // Deg (with fuel effect adjustment)
        const tdDeg = document.createElement('td');
        const deg = parseFloat(group.regressionStats.slope);
        const degAdj = deg + fuelEffect;
        tdDeg.textContent = isNaN(degAdj) ? group.regressionStats.slope : degAdj.toFixed(4);
        tr.appendChild(tdDeg);

        // Pace (with fuel effect adjustment)
        const tdPace = document.createElement('td');
        const pace = parseFloat(group.regressionStats.intercept);
        const minTyreLife = group.minTyreLife;
        const lapsToGo = group.lapsToGo;
        const paceAdj = pace - (minTyreLife + lapsToGo) * fuelEffect;
        tdPace.textContent = isNaN(paceAdj) ? group.regressionStats.intercept : paceAdj.toFixed(4);
        tr.appendChild(tdPace);

        // Correlation
        const tdCorrelation = document.createElement('td');
        tdCorrelation.textContent = typeof group.regressionStats.correlation === 'number'
          ? group.regressionStats.correlation.toFixed(3)
          : group.regressionStats.correlation;
        tr.appendChild(tdCorrelation);

        // RMSE
        const tdRMSE = document.createElement('td');
        tdRMSE.textContent = group.regressionStats.rmse;
        tr.appendChild(tdRMSE);

        // Click row to toggle selection
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      tyreDegStintsTableContainer.innerHTML = '';
      tyreDegStintsTableContainer.appendChild(table);

      const selectAllCheckbox = table.querySelector('#tyreDegSelectAllCheckbox');
      if (!tyreDegSelectionManager) {
        tyreDegSelectionManager = new TableCheckboxManager({
          selectAllId: 'tyreDegSelectAllCheckbox',
          getSelectionSet: () => appState.tyreDeg.selectedStints,
          selectionUpdater: (mutator) => mutator(appState.tyreDeg.selectedStints),
          selectedClass: 'stint-selected'
        });
      }
      tyreDegSelectionManager.onSelectionChange = () => {
        renderTyreDegScatterChart();
        renderTyreDegLapTimeChart();
      };
      tyreDegSelectionManager.setStructure({
        selectAllElement: selectAllCheckbox,
        items: tableSelectionItems
      });
      tyreDegSelectionManager.render();

      // Attach clickable header listeners
      attachTyreDegHeaderDropdownListeners();
    }

    function attachTyreDegHeaderDropdownListeners() {
      attachHeaderDropdowns({
        tableSelector: '#tyreDegStintsTable',
        groupsMap: tyreDegFilteredGroups,
        getColumnValue: (group, column) =>
          column === 'driver'       ? group.lap_Driver :
          column === 'session_type' ? group.session_type :
          column === 'compound'     ? group.compound : null,
        onSelectByValue: selectTyreDegByValue,
        activeDropdownRef: tyreDegDropdownState
      });
    }

    function selectTyreDegByValue(column, value, select) {
      tyreDegFilteredGroups.forEach((group, key) => {
        let matches = false;

        if (column === 'driver' && group.lap_Driver === value) {
          matches = true;
        } else if (column === 'session_type' && group.session_type === value) {
          matches = true;
        } else if (column === 'compound' && group.compound === value) {
          matches = true;
        }

        if (matches) {
          if (select) {
            appState.tyreDeg.selectedStints.add(key);
          } else {
            appState.tyreDeg.selectedStints.delete(key);
          }
        }
      });


      // Close the dropdown
      if (tyreDegDropdownState.dropdown) {
        tyreDegDropdownState.dropdown.remove();
        tyreDegDropdownState.dropdown = null;
        tyreDegDropdownState.column = null;
      }

      // Refresh table and charts
      renderTyreDegStintsTable();
      renderTyreDegScatterChart();
      renderTyreDegLapTimeChart();
    }

    function renderTyreDegScatterChart() {
      if (!tyreDegScatterChartInstance) {
        tyreDegScatterChartInstance = echarts.init(tyreDegScatterChart);
      }

      if (appState.tyreDeg.selectedStints.size === 0) {
        tyreDegScatterChartInstance.clear();
        tyreDegEquationsSection.style.display = 'none';
        tyreDegAvgDegDisplay.style.display = 'none';
        return;
      }

      const fuelEffect = parseFloat(document.getElementById('tyreDegFuelEffectSlider').value);

      // Prepare data grouped by compound - only for selected stints
      const datasets = new Map();
      const equations = new Map();
      const compoundDegValues = new Map(); // Track deg values for averaging

      appState.tyreDeg.selectedStints.forEach(key => {
        const group = tyreDegFilteredGroups.get(key);
        if (!group) return;

        const compound = group.compound;
        const stats = group.regressionStats;

        if (stats && stats.slope !== '-' && stats.intercept !== '-') {
          const deg = parseFloat(stats.slope);
          const pace = parseFloat(stats.intercept);

          // Apply fuel effect adjustments
          const minTyreLife = group.minTyreLife;
          const lapsToGo = group.lapsToGo;
          const degAdj = deg + fuelEffect;
          const paceAdj = pace - (minTyreLife + lapsToGo) * fuelEffect;

          if (!isNaN(paceAdj) && !isNaN(degAdj)) {
            if (!datasets.has(compound)) {
              datasets.set(compound, []);
              compoundDegValues.set(compound, []);
            }

            datasets.get(compound).push({
              value: [paceAdj, degAdj],
              label: `${group.lap_Driver} - ${group.event}`,
              stintKey: key
            });

            // Collect deg values for averaging
            compoundDegValues.get(compound).push(degAdj);
          }
        }
      });

      // Calculate and display average deg for each compound
      const avgDegValues = new Map(); // Store for copy button
      if (compoundDegValues.size > 0) {
        tyreDegAvgDegText.innerHTML = '';
        compoundDegValues.forEach((degValues, compound) => {
          const avgDeg = degValues.reduce((sum, val) => sum + val, 0) / degValues.length;
          avgDegValues.set(compound, avgDeg);
          const color = getF1TireColor(compound);

          const degItem = document.createElement('div');
          degItem.className = 'equation-item';
          degItem.style.borderLeftColor = color;
          degItem.textContent = `${compound}: ${avgDeg.toFixed(4)} s/lap`;
          tyreDegAvgDegText.appendChild(degItem);
        });
        tyreDegAvgDegDisplay.style.display = 'block';

        // Set up copy button
        const copyButton = document.getElementById('tyreDegCopyAvgDegButton');
        if (copyButton) {
          copyButton.style.display = 'block';

          // Remove old event listeners by cloning the button
          const newButton = copyButton.cloneNode(true);
          copyButton.parentNode.replaceChild(newButton, copyButton);

            newButton.addEventListener('click', () => {
            // Update pace model inputs for each compound
            if (avgDegValues.has('SOFT')) {
              const value = parseFloat(avgDegValues.get('SOFT').toFixed(6));
              saveToState('paceModel.degSoft', value);
            }
            if (avgDegValues.has('MEDIUM')) {
              const value = parseFloat(avgDegValues.get('MEDIUM').toFixed(6));
              saveToState('paceModel.degMedium', value);
            }
            if (avgDegValues.has('HARD')) {
              const value = parseFloat(avgDegValues.get('HARD').toFixed(6));
              saveToState('paceModel.degHard', value);
            }
            renderPaceModelInputsFromState();

            // Trigger updates if lap time data exists
            if (lapTimeCurrentGroups && lapTimeCurrentGroups.size > 0) {
              renderLapTimeChart();
              renderLapTimeSummaryTable();
            }

            // Visual feedback
            newButton.textContent = 'Selected!';
            setTimeout(() => {
              newButton.textContent = 'Select';
            }, 1000);
          });
        }
      } else {
        tyreDegAvgDegDisplay.style.display = 'none';
        const copyButton = document.getElementById('tyreDegCopyAvgDegButton');
        if (copyButton) {
          copyButton.style.display = 'none';
        }
      }

      // Create series for scatter plot and build mapping
      const series = [];
      scatterStintToPoint.clear();

      datasets.forEach((points, compound) => {
        const color = getF1TireColor(compound);

        const scatterSeriesIndex = series.length;
        // Store stint key to point mapping
        points.forEach((p, dataIndex) => {
          if (p.stintKey) {
            scatterStintToPoint.set(p.stintKey, { seriesIndex: scatterSeriesIndex, dataIndex });
          }
        });

        series.push({
          name: compound,
          type: 'scatter',
          data: points,
          symbolSize: 8,
          itemStyle: {
            color: color,
            borderColor: color,
            borderWidth: 0
          },
          emphasis: {
            focus: 'self',
            blurScope: 'global',
            itemStyle: {
              borderWidth: 3,
              shadowBlur: 15,
              shadowColor: color
            },
            scale: 1.5
          },
          blur: {
            itemStyle: { opacity: 0.15 }
          }
        });

        // Calculate best fit line for this compound
        if (points.length >= 2) {
          const xVals = points.map(p => p.value[0]);
          const yVals = points.map(p => p.value[1]);

          const n = points.length;
          const sumX = xVals.reduce((a, b) => a + b, 0);
          const sumY = yVals.reduce((a, b) => a + b, 0);
          const sumXY = xVals.reduce((sum, x, i) => sum + x * yVals[i], 0);
          const sumX2 = xVals.reduce((sum, x) => sum + x * x, 0);

          const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
          const intercept = (sumY - slope * sumX) / n;

          if (isFinite(slope) && isFinite(intercept)) {
            equations.set(compound, { slope, intercept, color });

            const minX = Math.min(...xVals);
            const maxX = Math.max(...xVals);
            const lineData = [
              [minX, slope * minX + intercept],
              [maxX, slope * maxX + intercept]
            ];

            series.push({
              type: 'line',
              data: lineData,
              lineStyle: {
                color: color,
                width: 2,
                type: 'dashed'
              },
              symbol: 'none',
              emphasis: { disabled: true },
              blur: { lineStyle: { opacity: 0.15 } },
              silent: true,
              animation: false,
              zlevel: -1
            });
          }
        }
      });

      const option = {
        backgroundColor: 'transparent',
        grid: { left: 60, right: 40, top: 40, bottom: 60 },
        legend: {
          show: true,
          top: 10,
          textStyle: { color: '#8b8b8b', fontSize: 10 }
        },
        tooltip: {
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          formatter: (p) => {
            if (p.data.label) {
              const stintNum = p.data.stintKey ? p.data.stintKey.split('||')[5] : 'N/A';
              return `
                <strong>${p.seriesName}</strong><br/>
                ${p.data.label}<br/>
                Stint: ${stintNum}<br/>
                Pace: ${p.data.value[0].toFixed(3)}s<br/>
                Deg: ${p.data.value[1].toFixed(4)}s/lap
              `;
            }
            return '';
          }
        },
        xAxis: {
          type: 'value',
          name: 'Pace (s)',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af', formatter: v => v.toFixed(1) },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true
        },
        yAxis: {
          type: 'value',
          name: 'Degradation (s/lap)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af', formatter: v => v.toFixed(3) },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        series: series
      };

      tyreDegScatterChartInstance.setOption(option, true);
      tyreDegScatterChartInstance.resize();

      // Remove old event listeners
      tyreDegScatterChartInstance.off('mouseover');
      tyreDegScatterChartInstance.off('mouseout');

      // Add cross-chart interaction for scatter -> lap time
      tyreDegScatterChartInstance.on('mouseover', { seriesType: 'scatter' }, (params) => {
        if (params.data && params.data.stintKey && tyreDegLapTimeChartInstance) {
          const stintKey = params.data.stintKey;
          const lapTimeSeriesIndex = lapTimeStintToSeriesIndex.get(stintKey);
          if (lapTimeSeriesIndex !== undefined) {
            tyreDegLapTimeChartInstance.dispatchAction({
              type: 'highlight',
              seriesIndex: lapTimeSeriesIndex
            });
          }
        }
      });

      tyreDegScatterChartInstance.on('mouseout', { seriesType: 'scatter' }, (params) => {
        if (tyreDegLapTimeChartInstance) {
          tyreDegLapTimeChartInstance.dispatchAction({ type: 'downplay' });
        }
      });

      // Display best fit equations
      renderTyreDegEquations(equations);
    }

    function renderTyreDegEquations(equations) {
      if (equations.size === 0) {
        tyreDegEquationsSection.style.display = 'none';
        return;
      }

      tyreDegEquationsGrid.innerHTML = '';
      equations.forEach(({ slope, intercept, color }, compound) => {
        const equation = document.createElement('div');
        equation.className = 'equation-item';
        equation.style.borderLeftColor = color;
        equation.textContent = `${compound}: Deg = ${slope.toFixed(4)} × Pace + ${intercept.toFixed(4)}`;
        tyreDegEquationsGrid.appendChild(equation);
      });

      tyreDegEquationsSection.style.display = 'block';
    }

    function renderTyreDegLapTimeChart() {
      if (!tyreDegLapTimeChartInstance) {
        tyreDegLapTimeChartInstance = echarts.init(tyreDegLapTimeChart);
      }

      if (appState.tyreDeg.selectedStints.size === 0) {
        tyreDegLapTimeChartInstance.clear();
        tyreDegSelectedStintCount.textContent = 'No stints selected';
        return;
      }

      const fuelAdjusted = appState.tyreDeg.fuelAdjust;
      const fuelEffect = parseFloat(document.getElementById('tyreDegFuelEffectSlider').value);

      const series = [];
      lapTimeStintToSeriesIndex.clear();
      let stintCount = 0;
      let seriesIndex = 0;

      appState.tyreDeg.selectedStints.forEach(key => {
        const group = tyreDegFilteredGroups.get(key);
        if (!group) return;

        const compound = group.rows[0]?.lap_Compound || 'UNKNOWN';
        const driver = group.lap_Driver;
        const color = getF1TireColor(compound);

        const data = group.rows.map(r => {
          const tyreLife = parseInt(r.lap_TyreLife);
          let lapTime = parseFloat(r.lap_LapTime);

          if (fuelAdjusted && !isNaN(r.sched_laps)) {
            const lapNum = parseInt(r.lap_LapNumber);
            const schedLaps = parseInt(r.sched_laps);
            lapTime -= (schedLaps - lapNum) * fuelEffect;
          }

          return {
            value: [tyreLife, lapTime],
            driver: driver,
            compound: compound,
            stintKey: key
          };
        }).filter(p => !isNaN(p.value[0]) && !isNaN(p.value[1]));

        if (data.length > 0) {
          // Store mapping for this stint
          lapTimeStintToSeriesIndex.set(key, seriesIndex);

          series.push({
            name: `${driver} ${compound}`,
            type: 'line',
            data: data,
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: color, opacity: 0.95 },
            itemStyle: { color: color, borderWidth: 0 },
            emphasis: {
              focus: 'series',
              blurScope: 'global',
              lineStyle: { width: 3.2 },
              scale: true
            },
            blur: { lineStyle: { opacity: 0.1 } },
            animation: false,
            stintKey: key,  // Store stint key for reference
            triggerLineEvent: true  // Enable line hover events
          });
          stintCount++;
          seriesIndex++;
        }
      });

      tyreDegSelectedStintCount.textContent = `${stintCount} stint${stintCount !== 1 ? 's' : ''} selected`;

      const option = {
        backgroundColor: 'transparent',
        grid: { left: 60, right: 40, top: 20, bottom: 60 },
        legend: { show: false },
        tooltip: {
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          formatter: (p) => {
            const data = p.data;
            const stintNum = data.stintKey ? data.stintKey.split('||')[5] : 'N/A';
            return `
              <strong>${data.driver}</strong><br/>
              Stint: ${stintNum}<br/>
              Tyre Life: ${data.value[0]} laps<br/>
              Lap Time: ${data.value[1].toFixed(3)}s<br/>
              Compound: ${data.compound}
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Tyre Life (laps)',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          min: 0
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af', formatter: v => v.toFixed(1) },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true
        },
        series: series
      };

      tyreDegLapTimeChartInstance.setOption(option, true);
      tyreDegLapTimeChartInstance.resize();

      // Remove old event listeners
      tyreDegLapTimeChartInstance.off('mouseover');
      tyreDegLapTimeChartInstance.off('mouseout');
      tyreDegLapTimeChartInstance.off('highlight');
      tyreDegLapTimeChartInstance.off('downplay');

      // Listen to both mouseover (for line/point hover) and highlight (for programmatic emphasis)
      const handleLapTimeHover = (params) => {
        if (params.seriesIndex !== undefined && series[params.seriesIndex]) {
          const stintKey = series[params.seriesIndex].stintKey;
          if (stintKey && tyreDegScatterChartInstance) {
            const scatterPoint = scatterStintToPoint.get(stintKey);
            if (scatterPoint) {
              // Highlight single data point on scatter plot
              tyreDegScatterChartInstance.dispatchAction({
                type: 'highlight',
                seriesIndex: scatterPoint.seriesIndex,
                dataIndex: scatterPoint.dataIndex
              });
            }
          }
        }
      };

      tyreDegLapTimeChartInstance.on('mouseover', handleLapTimeHover);
      tyreDegLapTimeChartInstance.on('highlight', handleLapTimeHover);

      tyreDegLapTimeChartInstance.on('mouseout', (params) => {
        if (tyreDegScatterChartInstance) {
          tyreDegScatterChartInstance.dispatchAction({ type: 'downplay' });
        }
      });

      tyreDegLapTimeChartInstance.on('downplay', (params) => {
        if (tyreDegScatterChartInstance) {
          tyreDegScatterChartInstance.dispatchAction({ type: 'downplay' });
        }
      });
    }

    // ============================================================================
    // FUEL EFFECT PANEL
    // ============================================================================

    const fuelEffectChartContainer = document.getElementById('fuelEffectChartContainer');
    const fuelEffectCoefficientsContainer = document.getElementById('fuelEffectCoefficientsContainer');
    const fuelEffectCoefficientsGrid = document.getElementById('fuelEffectCoefficientsGrid');
    const fuelEffectGroupsTableContainer = document.getElementById('fuelEffectGroupsTableContainer');
    let fuelEffectChart = null; // ECharts instance
    let fuelEffectFilteredGroups = new Map(); // Store filtered groups for context menu filtering
    let fuelEffectPreviousFilteredKeys = []; // Remember which keys were visible last time
    const fuelEffectDropdownState = { dropdown: null, column: null };

    function processFuelEffectData(sessionData, options = {}) {
      const { restoreSelections = false } = options;

      if (!sessionData || sessionData.length === 0) {
        fuelEffectFilteredGroups = new Map();
        fuelEffectPreviousFilteredKeys = [];
        fuelEffectGroupsTableContainer.innerHTML = '';
        fuelEffectCoefficientsGrid.innerHTML = '';
        if (fuelEffectChart) {
          fuelEffectChart.dispose();
          fuelEffectChart = null;
        }
        return [];
      }

      const filteredRows = applySharedFilters(sessionData);
      displayFuelEffectGroupsTable(filteredRows);

      if (restoreSelections) {
        restoreDataDependentSelections('fuel-effect');

        if (appState.fuelEffect.selectedRows.size === 0) {
          fuelEffectFilteredGroups.forEach((group, key) => {
            appState.fuelEffect.selectedRows.add(key);
          });
        }

        displayFuelEffectGroupsTable(filteredRows);
      }

      return filteredRows;
    }

    // Handle window resize for fuel effect chart
    window.addEventListener('resize', () => {
      if (fuelEffectChart) {
        fuelEffectChart.resize();
      }
    });

    function renderFuelEffectScatterPlot(groups) {
      // Filter to only selected rows
      const selectedGroups = groups.filter(([key, group]) => {
        return appState.fuelEffect.selectedRows.has(key);
      });

      if (selectedGroups.length === 0) {
        fuelEffectChartContainer.style.display = 'none';
        fuelEffectCoefficientsContainer.style.display = 'none';
        if (fuelEffectChart) {
          fuelEffectChart.dispose();
          fuelEffectChart = null;
        }
        return;
      }

      // Show chart container
      fuelEffectChartContainer.style.display = 'block';
      fuelEffectCoefficientsContainer.style.display = 'block';

      // Initialize chart if needed
      if (!fuelEffectChart) {
        fuelEffectChart = echarts.init(fuelEffectChartContainer);
      }

      // Prepare data by compound
      const dataByCompound = new Map();

      selectedGroups.forEach(([key, group]) => {
        const compound = group.compound;
        if (!dataByCompound.has(compound)) {
          dataByCompound.set(compound, []);
        }

        // Calculate incremental differences
        for (let i = 1; i < group.laps.length; i++) {
          const lapNumDiff = group.laps[i].lapNumber - group.laps[i - 1].lapNumber;
          const lapTimeDiff = group.laps[i].lapTime - group.laps[i - 1].lapTime;

          dataByCompound.get(compound).push({
            value: [lapNumDiff, lapTimeDiff],
            driver: group.driver,
            tyreLife: group.tyreLife,
            lap1Number: group.laps[i - 1].lapNumber,
            lap1Time: group.laps[i - 1].lapTime,
            lap2Number: group.laps[i].lapNumber,
            lap2Time: group.laps[i].lapTime
          });
        }
      });

      // Calculate linear regression (zero intercept) and create series
      const series = [];
      const coefficients = new Map();

      dataByCompound.forEach((data, compound) => {
        const color = getF1TireColor(compound);

        // Add scatter series
        series.push({
          name: compound,
          type: 'scatter',
          data: data,
          symbolSize: 6,
          itemStyle: {
            color: color,
            borderColor: color,
            borderWidth: 0
          },
          emphasis: {
            focus: 'series',
            itemStyle: {
              borderWidth: 2,
              shadowBlur: 10,
              shadowColor: color
            }
          }
        });

        // Calculate linear regression with zero intercept: y = mx
        // m = Σ(xy) / Σ(x²)
        let sumXY = 0;
        let sumX2 = 0;

        data.forEach(point => {
          const x = point.value[0];
          const y = point.value[1];
          sumXY += x * y;
          sumX2 += x * x;
        });

        const slope = sumX2 !== 0 ? sumXY / sumX2 : 0;
        coefficients.set(compound, slope);

        // Find min and max x values for the line
        const xValues = data.map(point => point.value[0]);
        const minX = Math.min(...xValues);
        const maxX = Math.max(...xValues);

        // Create line data
        const lineData = [
          [minX, slope * minX],
          [maxX, slope * maxX]
        ];

        // Add line series
        series.push({
          name: `${compound} fit`,
          type: 'line',
          data: lineData,
          showSymbol: false,
          lineStyle: {
            color: color,
            width: 2,
            type: 'dashed'
          },
          emphasis: { disabled: true },
          silent: true,
          zlevel: -1
        });
      });

      // Set chart options
      fuelEffectChart.setOption({
        backgroundColor: 'transparent',
        grid: { left: 60, right: 20, top: 50, bottom: 60 },
        legend: {
          show: true,
          top: 5,
          textStyle: { color: '#f5f5f5', fontSize: 11 },
          itemWidth: 12,
          itemHeight: 12,
          data: Array.from(dataByCompound.keys()) // Only show compounds, not fit lines
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const data = p.data;
            return `
              <strong>${p.seriesName} - ${data.driver}</strong><br/>
              Tyre Life: ${data.tyreLife}<br/>
              <br/>
              Lap ${data.lap1Number}: ${data.lap1Time.toFixed(3)}s<br/>
              Lap ${data.lap2Number}: ${data.lap2Time.toFixed(3)}s<br/>
              <br/>
              Lap # Diff: ${data.value[0]}<br/>
              Lap Time Diff: ${data.value[1].toFixed(3)}s
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Lap Number Difference',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time Difference (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        series: series
      }, true);

      // Resize chart
      fuelEffectChart.resize();

      // Display coefficients
      fuelEffectCoefficientsGrid.innerHTML = '';
      coefficients.forEach((slope, compound) => {
        const color = getF1TireColor(compound);
        const coeffDiv = document.createElement('div');
        coeffDiv.style.cssText = `
          font-size: 11px;
          color: var(--text-color);
          font-family: 'Courier New', monospace;
          padding: 6px 10px;
          background: rgba(0, 0, 0, 0.3);
          border-radius: 6px;
          border-left: 3px solid ${color};
          display: flex;
          justify-content: space-between;
          align-items: center;
          gap: 8px;
        `;

        const textSpan = document.createElement('span');
        textSpan.innerHTML = `<strong>${compound}:</strong> m = ${slope.toFixed(6)}`;
        coeffDiv.appendChild(textSpan);

        const copyButton = document.createElement('button');
        copyButton.textContent = 'Select Fuel Effect';
        copyButton.style.cssText = `
          padding: 6px 8px;
          font-size: 10px;
          background: var(--accent-color);
          color: var(--bg-color);
          border: none;
          border-radius: 4px;
          cursor: pointer;
          font-weight: 600;
        `;
        copyButton.addEventListener('click', () => {
          // Reverse the sign
          const reversedValue = -slope;
          const formattedValue = parseFloat(reversedValue.toFixed(6));

          saveToState('paceModel.fuelEffect', formattedValue);
          renderPaceModelInputsFromState();
          onLapTimeAdjustmentChange();

          // Visual feedback
          copyButton.textContent = 'Selected!';
          setTimeout(() => {
            copyButton.textContent = 'Select Fuel Effect';
          }, 1000);
        });
        coeffDiv.appendChild(copyButton);

        fuelEffectCoefficientsGrid.appendChild(coeffDiv);
      });
    }

    function displayFuelEffectGroupsTable(rows) {
      if (!rows.length) {
        fuelEffectPreviousFilteredKeys = []; // nothing visible now
        fuelEffectGroupsTableContainer.innerHTML = "";
        fuelEffectChartContainer.style.display = 'none';
        fuelEffectCoefficientsContainer.style.display = 'none';
        if (fuelEffectChart) {
          fuelEffectChart.dispose();
          fuelEffectChart = null;
        }
        fuelEffectFilteredGroups.clear();
        return;
      }

      // Group by driver, compound, and tyre life
      const groups = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const compound = String(r.lap_Compound || "").trim();
        const tyreLife = String(r.lap_TyreLife || "").trim();
        const lapNumber = String(r.lap_LapNumber || "").trim();
        const lapTime = parseFloat(r.lap_LapTime);

        if (!driver || !compound || !tyreLife || !lapNumber || isNaN(lapTime)) {
          return; // Skip invalid rows
        }

        const key = `${driver}||${compound}||${tyreLife}`;

        if (!groups.has(key)) {
          groups.set(key, {
            driver: driver,
            compound: compound,
            tyreLife: parseInt(tyreLife),
            laps: []
          });
        }

        groups.get(key).laps.push({
          lapNumber: parseInt(lapNumber),
          lapTime: lapTime
        });
      });

      // Filter out groups with only one lap
      const filteredGroups = Array.from(groups.entries()).filter(([key, group]) => {
        return group.laps.length > 1;
      });

      // Sort groups by compound, driver, tyre life
      const sortedGroups = filteredGroups.sort((a, b) => {
        const [keyA, groupA] = a;
        const [keyB, groupB] = b;

        if (groupA.compound !== groupB.compound) {
          return groupA.compound.localeCompare(groupB.compound);
        }

        if (groupA.driver !== groupB.driver) {
          return groupA.driver.localeCompare(groupB.driver);
        }

        return groupA.tyreLife - groupB.tyreLife;
      });

      // Detect and auto-select newly visible rows (only on filter changes, not initial load)
      const currentKeys = sortedGroups.map(([key]) => key);
      const previousKeysSet = new Set(fuelEffectPreviousFilteredKeys || []);

      // Only auto-select new rows if this is a filter change (not initial load)
      // On initial load, selections come from URL or default to all (handled in initializePanel)
      if (fuelEffectPreviousFilteredKeys && fuelEffectPreviousFilteredKeys.length > 0) {
        currentKeys.forEach(key => {
          const isNew = !previousKeysSet.has(key);
          if (isNew && !appState.fuelEffect.selectedRows.has(key)) {
            // New row that just appeared because of filters -> auto-select it
            appState.fuelEffect.selectedRows.add(key);
          }
        });
      }

      // Store filtered groups
      fuelEffectFilteredGroups.clear();
      sortedGroups.forEach(([key, group]) => {
        fuelEffectFilteredGroups.set(key, group);
      });

      // Remove any selections that are no longer valid
      const validKeys = new Set(sortedGroups.map(([key]) => key));
      const staleKeys = [];
      appState.fuelEffect.selectedRows.forEach(key => {
        if (!validKeys.has(key)) {
          staleKeys.push(key);
        }
      });
      staleKeys.forEach(key => appState.fuelEffect.selectedRows.delete(key));

      // Remember current keys so we can detect new rows on the next render
      fuelEffectPreviousFilteredKeys = Array.from(validKeys);

      // Render scatter plot with selected rows
      renderFuelEffectScatterPlot(sortedGroups);

      // Build table with DOM
      const table = document.createElement('table');
      table.className = 'groups-table';
      table.id = 'fuelEffectGroupsTable';

      // Header row
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');

      const headers = [
        { text: 'Select', isCheckbox: true },
        { text: 'Driver', clickable: true, column: 'driver' },
        { text: 'Compound', clickable: true, column: 'compound' },
        { text: 'Tyre Life' },
        { text: 'Laps (Lap Number: Lap Time)' }
      ];

      headers.forEach(header => {
        const th = document.createElement('th');

        if (header.isCheckbox) {
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = 'fuelEffectSelectAllCheckbox';
          checkbox.className = 'stint-checkbox';
          th.appendChild(checkbox);
        } else if (header.clickable) {
          th.textContent = header.text;
          th.className = 'clickable-header';
          th.dataset.column = header.column;
        } else {
          th.textContent = header.text;
        }

        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Body
      const tbody = document.createElement('tbody');

      const tableSelectionItems = [];

      sortedGroups.forEach(([key, group]) => {
        const tr = document.createElement('tr');
        tr.classList.toggle('stint-selected', appState.fuelEffect.selectedRows.has(key));

        // Select checkbox
        const tdCheckbox = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'stint-checkbox';
        tdCheckbox.appendChild(checkbox);
        tr.appendChild(tdCheckbox);
        tableSelectionItems.push({ key, checkbox, rowElement: tr });

        // Driver
        const tdDriver = document.createElement('td');
        tdDriver.textContent = group.driver;
        tr.appendChild(tdDriver);

        // Compound
        const tdCompound = document.createElement('td');
        tdCompound.textContent = group.compound;
        tdCompound.style.color = getF1TireColor(group.compound);
        tdCompound.style.fontWeight = '600';
        tr.appendChild(tdCompound);

        // Tyre Life
        const tdTyreLife = document.createElement('td');
        tdTyreLife.textContent = group.tyreLife;
        tr.appendChild(tdTyreLife);

        // Laps
        const tdLaps = document.createElement('td');
        // Sort laps by lap number
        group.laps.sort((a, b) => a.lapNumber - b.lapNumber);
        const lapsText = group.laps.map(lap =>
          `${lap.lapNumber}: ${lap.lapTime.toFixed(3)}s`
        ).join(', ');
        tdLaps.textContent = lapsText;
        tr.appendChild(tdLaps);

        // Click row to toggle selection
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change', { bubbles: true }));
          }
        });

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      fuelEffectGroupsTableContainer.innerHTML = '';
      fuelEffectGroupsTableContainer.appendChild(table);

      const selectAllCheckbox = table.querySelector('#fuelEffectSelectAllCheckbox');
      if (!fuelEffectSelectionManager) {
        fuelEffectSelectionManager = new TableCheckboxManager({
          selectAllId: 'fuelEffectSelectAllCheckbox',
          getSelectionSet: () => appState.fuelEffect.selectedRows,
          selectionUpdater: (mutator) => mutator(appState.fuelEffect.selectedRows),
          selectedClass: 'stint-selected'
        });
      }
      fuelEffectSelectionManager.onSelectionChange = () => {
        renderFuelEffectScatterPlot(sortedGroups);
      };
      fuelEffectSelectionManager.setStructure({
        selectAllElement: selectAllCheckbox,
        items: tableSelectionItems
      });
      fuelEffectSelectionManager.render();

      // Attach clickable header listeners
      attachFuelEffectHeaderDropdownListeners();
    }

    function attachFuelEffectHeaderDropdownListeners() {
      attachHeaderDropdowns({
        tableSelector: '#fuelEffectGroupsTable',
        groupsMap: fuelEffectFilteredGroups,
        getColumnValue: (group, column) =>
          column === 'driver'   ? group.driver :
          column === 'compound' ? group.compound : null,
        onSelectByValue: selectFuelEffectByValue,
        activeDropdownRef: fuelEffectDropdownState
      });
    }

    function selectFuelEffectByValue(column, value, select) {
      fuelEffectFilteredGroups.forEach((group, key) => {
        let matches = false;

        if (column === 'driver' && group.driver === value) {
          matches = true;
        } else if (column === 'compound' && group.compound === value) {
          matches = true;
        }

        if (matches) {
          if (select) {
            appState.fuelEffect.selectedRows.add(key);
          } else {
            appState.fuelEffect.selectedRows.delete(key);
          }
        }
      });


      // Close the dropdown
      if (fuelEffectDropdownState.dropdown) {
        fuelEffectDropdownState.dropdown.remove();
        fuelEffectDropdownState.dropdown = null;
        fuelEffectDropdownState.column = null;
      }

      // Refresh table and chart
      if (currentSessionData && currentSessionData.length > 0) {
        processFuelEffectData(currentSessionData);
      }
    }

    function escapeHtml(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    // ============================================================================
    // CALCULATOR PANEL
    // ============================================================================

    const INF = 1e18;
    let calculatorStrategyChart = null;
    let calculatorLapTimeChart = null;
    // DP Core: Tyre Rules
    class TwoCompoundTyreRule {
      constructor(compoundIndices) {
        this.compoundIndices = compoundIndices;
      }
      allMetaNew() {
        const ans = [];
        ans.push({ meta: -1, compounds: Array.from(this.compoundIndices) });
        for (const c of this.compoundIndices) {
          ans.push({ meta: c, compounds: [c] });
        }
        return ans;
      }
      initMeta(startCompIdx) {
        return startCompIdx;
      }
      newCompoundsAllowed(meta) {
        return Array.from(this.compoundIndices);
      }
      nextMetaOnSc(meta) {
        return meta;
      }
      nextMetaOnPit(meta, newComp) {
        if (meta !== newComp) return -1;
        return meta;
      }
      terminalOk(meta) {
        return meta === -1;
      }
    }

    class PatternUnlessSCTyreRule {
      constructor(patternCompIndices, compoundIndices) {
        this.pattern = patternCompIndices;
        this.length = patternCompIndices.length;
        this.compoundIndices = compoundIndices;
      }
      allMetaNew() {
        const metas = [];
        for (let i = 1; i <= this.length; i++) {
          metas.push({
            meta: { sc: false, idx: i },
            compounds: [this.pattern[i - 1]]
          });
        }
        metas.push({
          meta: { sc: true, idx: -1 },
          compounds: Array.from(this.compoundIndices)
        });
        for (const c of this.compoundIndices) {
          metas.push({
            meta: { sc: true, idx: c },
            compounds: [c]
          });
        }
        return metas;
      }
      initMeta(startCompIdx) {
        if (startCompIdx !== this.pattern[0]) return null;
        return { sc: false, idx: 1 };
      }
      newCompoundsAllowed(meta) {
        if (meta.sc) {
          return Array.from(this.compoundIndices);
        } else {
          const idx = meta.idx;
          if (idx >= this.length) return [];
          return [this.pattern[idx]];
        }
      }
      nextMetaOnPit(meta, newComp) {
        if (meta.sc) {
          const idx = meta.idx;
          if (idx === -1) return { sc: true, idx: -1 };
          if (newComp === idx) return { sc: true, idx };
          return { sc: true, idx: -1 };
        } else {
          const idx = meta.idx;
          if (idx >= this.length || newComp !== this.pattern[idx]) return null;
          return { sc: false, idx: idx + 1 };
        }
      }
      nextMetaOnSc(meta) {
        if (meta.sc) return meta;
        const idx = meta.idx;
        const used = new Set(this.pattern.slice(0, idx));
        if (used.size >= 2) return { sc: true, idx: -1 };
        return { sc: true, idx: this.pattern[idx - 1] };
      }
      terminalOk(meta) {
        if (meta.sc) return meta.idx === -1;
        return meta.idx === this.length;
      }
    }

    // DP Helper Functions
    function calcGetScProb(lap, ranges) {
      for (const [mn, mx, p] of ranges) {
        if (mx === null && lap >= mn) return p;
        if (lap >= mn && lap <= mx) return p;
      }
      throw new Error("No SC probability defined for lap " + lap);
    }

    function calcLapTime(compIdx, age, lap, compounds, fuelEffect) {
      const base = compounds[compIdx].pace;
      const deg = compounds[compIdx].degradation;
      return base + deg * age - fuelEffect * (lap - 1);
    }

    function calcMetaToKey(meta) {
      if (meta === null || meta === undefined) return "null";
      const t = typeof meta;
      if (t === "number" || t === "string" || t === "boolean") return String(meta);
      if (meta && typeof meta === "object" && "sc" in meta && "idx" in meta) {
        return (meta.sc ? "1" : "0") + ":" + meta.idx;
      }
      return JSON.stringify(meta);
    }

    function calcStateKey(lap, compIdx, age, scStatus, meta) {
      return lap + "|" + compIdx + "|" + age + "|" + scStatus + "|" + calcMetaToKey(meta);
    }

    // Main DP Algorithm
    function calcComputePolicy(numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, rule) {
      const scProb = {};
      for (let lap = 1; lap <= numLaps; lap++) {
        scProb[lap] = calcGetScProb(lap, scProbRanges);
      }

      const dpExp = new Map();
      const policy = new Map();

      for (let lap = numLaps + 1; lap >= 1; lap--) {
        const metaList = rule.allMetaNew();
        for (const entry of metaList) {
          const meta = entry.meta;
          const metaCompounds = entry.compounds;
          for (const compIdx of metaCompounds) {
            for (let scStatus = 0; scStatus <= 1; scStatus++) {
              for (let age = 0; age < lap; age++) {
                const key = calcStateKey(lap, compIdx, age, scStatus, meta);

                if (lap === numLaps + 1) {
                  dpExp.set(key, rule.terminalOk(meta) ? 0 : INF);
                  policy.set(key, null);
                  continue;
                }

                let bestExp = INF;
                let bestAction = null;

                if (scStatus === 1) {
                  const options = [
                    {
                      compIdxOpt: compIdx,
                      ageOpt: age,
                      action: ["stay"],
                      metaOpt: meta,
                      pitLossOpt: 0
                    }
                  ];

                  const allowed = rule.newCompoundsAllowed(meta) || [];
                  for (const newC of allowed) {
                    const newMeta = rule.nextMetaOnPit(meta, newC);
                    if (newMeta == null) continue;
                    options.push({
                      compIdxOpt: newC,
                      ageOpt: 0,
                      action: ["pit", newC],
                      metaOpt: newMeta,
                      pitLossOpt: 0
                    });
                  }

                  for (const opt of options) {
                    const nextLap = Math.min(lap + scLength - 1, numLaps + 1);
                    const nextMetaAfterSc = rule.nextMetaOnSc(opt.metaOpt);
                    const nextKey = calcStateKey(
                      nextLap,
                      opt.compIdxOpt,
                      opt.ageOpt,
                      0,
                      nextMetaAfterSc
                    );
                    const nextVal = dpExp.get(nextKey);
                    const exp = opt.pitLossOpt + (nextVal !== undefined ? nextVal : INF);
                    if (exp < bestExp) {
                      bestExp = exp;
                      bestAction = opt.action;
                    }
                  }
                } else {
                  const options = [
                    {
                      compIdxOpt: compIdx,
                      ageOpt: age,
                      action: ["stay"],
                      metaOpt: meta,
                      pitLossOpt: 0
                    }
                  ];

                  const allowed = rule.newCompoundsAllowed(meta) || [];
                  for (const newC of allowed) {
                    const newMeta = rule.nextMetaOnPit(meta, newC);
                    if (newMeta == null) continue;
                    options.push({
                      compIdxOpt: newC,
                      ageOpt: 0,
                      action: ["pit", newC],
                      metaOpt: newMeta,
                      pitLossOpt: pitLoss
                    });
                  }

                  for (const opt of options) {
                    const lt = calcLapTime(
                      opt.compIdxOpt,
                      opt.ageOpt,
                      lap,
                      compounds,
                      fuelEffect
                    );

                    const nextLap = lap + 1;
                    const metaAfterSc = rule.nextMetaOnSc(opt.metaOpt);

                    const scKey = calcStateKey(
                      nextLap,
                      opt.compIdxOpt,
                      opt.ageOpt + 1,
                      1,
                      metaAfterSc
                    );
                    const greenKey = calcStateKey(
                      nextLap,
                      opt.compIdxOpt,
                      opt.ageOpt + 1,
                      0,
                      opt.metaOpt
                    );

                    const valSc = dpExp.get(scKey);
                    const valGreen = dpExp.get(greenKey);

                    const exp =
                      opt.pitLossOpt +
                      scProb[lap] * (valSc !== undefined ? valSc : INF) +
                      (1 - scProb[lap]) *
                        ((valGreen !== undefined ? valGreen : INF) + lt);

                    if (exp < bestExp) {
                      bestExp = exp;
                      bestAction = opt.action;
                    }
                  }
                }

                dpExp.set(key, bestExp);
                policy.set(key, bestAction);
              }
            }
          }
        }
      }

      return { dpExp, policy };
    }

    function calcExtractNoScStrategy(rule, startCompIdx, numLaps, policy) {
      let meta = rule.initMeta(startCompIdx);
      if (meta == null) return [];

      const stints = [];
      let compIdx = startCompIdx;
      let age = 0;
      let currentStintStart = 1;

      for (let lap = 1; lap <= numLaps; lap++) {
        const key = calcStateKey(lap, compIdx, age, 0, meta);
        const action = policy.get(key);
        if (!action) break;

        if (action[0] === "pit") {
          const newComp = action[1];
          if (lap - 1 >= currentStintStart) {
            stints.push([compIdx, currentStintStart, lap - 1]);
          }
          const newMeta = rule.nextMetaOnPit(meta, newComp);
          compIdx = newComp;
          meta = newMeta;
          currentStintStart = lap;
          age = 1;
        } else {
          age += 1;
        }
      }

      if (currentStintStart <= numLaps) {
        stints.push([compIdx, currentStintStart, numLaps]);
      }
      return stints;
    }

    function calcRaceTime(stints, compounds, fuelEffect, pitLoss) {
      let total = pitLoss * (stints.length - 1);
      for (const [ci, sLap, eLap] of stints) {
        for (let lap = sLap; lap <= eLap; lap++) {
          const age = lap - sLap;
          total += calcLapTime(ci, age, lap, compounds, fuelEffect);
        }
      }
      return total;
    }

    function calcSummarizeResults(numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, rule) {
      const { dpExp, policy } = calcComputePolicy(
        numLaps,
        compounds,
        fuelEffect,
        scProbRanges,
        scLength,
        pitLoss,
        rule
      );
      const results = {};
      for (let startIdx = 0; startIdx < compounds.length; startIdx++) {
        const meta0 = rule.initMeta(startIdx);
        if (meta0 == null) continue;
        const stints = calcExtractNoScStrategy(rule, startIdx, numLaps, policy);
        const key0 = calcStateKey(1, startIdx, 0, 0, meta0);
        const expectedTime = dpExp.get(key0);
        results[compounds[startIdx].type] = {
          expected_time: expectedTime,
          no_sc_stints: stints,
          no_sc_time: calcRaceTime(stints, compounds, fuelEffect, pitLoss)
        };
      }
      return { results };
    }

    function calcComputeFreePatterns(numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss) {
      const compoundIndices = compounds.map((_, i) => i);
      const rule = new TwoCompoundTyreRule(compoundIndices);
      const { dpExp, policy } = calcComputePolicy(
        numLaps,
        compounds,
        fuelEffect,
        scProbRanges,
        scLength,
        pitLoss,
        rule
      );

      const seen = new Set();
      const patterns = [];

      for (let startIdx = 0; startIdx < compounds.length; startIdx++) {
        const meta0 = rule.initMeta(startIdx);
        if (meta0 == null) continue;

        const stints = calcExtractNoScStrategy(rule, startIdx, numLaps, policy);
        if (!stints || !stints.length) continue;

        const seq = [];
        for (const [ci] of stints) {
          const t = compounds[ci].type;
          seq.push(t);
        }

        if (seq.length >= 2 && seq.length <= 4) {
          const key = seq.join(",");
          if (!seen.has(key)) {
            seen.add(key);
            patterns.push(seq);
          }
        }
      }

      return patterns;
    }

    function getCalculatorStrategyPatterns() {
      const strategies = Array.isArray(appState.calculator.strategies)
        ? appState.calculator.strategies
        : [];
      const parsed = [];
      strategies.forEach((raw) => {
        if (!raw) return;
        const tokens = raw
          .split(/[\,\s>\-]+/)
          .map((t) => t.trim().toUpperCase())
          .filter((t) => t);
        if (tokens.length < 2 || tokens.length > 4) return;
        if (!tokens.every((t) => t === 'S' || t === 'M' || t === 'H')) return;
        parsed.push(tokens);
      });
      return parsed.slice(0, 5);
    }

    // Chart Updates
    function updateCalculatorCombinedChartAndStints(combinedResults, compounds, baselineFree) {
      const chartDom = document.getElementById("calculatorStrategyChart");
      const stintsDom = document.getElementById("calculatorStrategyStints");

      if (!calculatorStrategyChart) {
        calculatorStrategyChart = echarts.init(chartDom);
      }

      if (!combinedResults || combinedResults.length === 0 || !Number.isFinite(baselineFree)) {
        calculatorStrategyChart.clear();
        calculatorStrategyChart.setOption({
          backgroundColor: "transparent",
          title: {
            text: "No valid fixed strategies (check inputs or strategies).",
            textStyle: { color: "#f56565", fontSize: 14 }
          }
        });
        stintsDom.innerHTML =
          '<h3>No-SC optimal stints</h3><div>No valid strategies to display.</div>';
        return;
      }

      const categories = combinedResults.map((r) => r.label);
      const deltas = combinedResults.map((r) =>
        +(r.expected_time - baselineFree).toFixed(3)
      );

      const option = {
        backgroundColor: "transparent",
        textStyle: { color: "#e2e8f0" },
        tooltip: {
          trigger: "axis",
          axisPointer: { type: "shadow" },
          formatter: (params) => {
            const p = params[0];
            const label = categories[p.dataIndex];
            const val = deltas[p.dataIndex];
            return `${label}<br/>Δt: ${val.toFixed(3)} s`;
          }
        },
        grid: { left: 80, right: 20, top: 40, bottom: 70 },
        xAxis: {
          type: "category",
          data: categories,
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: {
            color: "#cbd5f5",
            fontSize: 10,
            rotate: 20
          },
          axisTick: { show: false }
        },
        yAxis: {
          type: "value",
          name: "Δt (s)",
          nameTextStyle: { color: "#a0aec0", fontSize: 10, padding: [0, 0, 4, 0] },
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: { color: "#cbd5f5", fontSize: 10 },
          splitLine: { lineStyle: { color: "#1a202c" } }
        },
        series: [
          {
            type: "bar",
            data: deltas,
            barWidth: "55%",
            itemStyle: {
              borderRadius: [4, 4, 0, 0]
            }
          }
        ]
      };

      calculatorStrategyChart.setOption(option, true);

      let html = '<h3>Predicted pit stops</h3>';
      combinedResults.forEach((r, idx) => {
        const delta = deltas[idx];
        const label = r.isBaseline ? `${r.label} (optimal)` : r.label;
        const stintText = r.stints
          .slice(0, -1)
          .map(([ci, s, e]) => `${e}`)
          .join(", ");
        html += `
          <div class="calculator-stints-item">
            <span class="calculator-stints-label">${label}</span>
            <span> lap(s): ${stintText || "—"}</span>
          </div>`;
      });
      stintsDom.innerHTML = html;
    }

    function updateCalculatorLapTimeChart(combinedResults, compounds, numLaps, fuelEffect) {
      const dom = document.getElementById("calculatorLapTimeChart");
      if (!dom) return;

      if (!calculatorLapTimeChart) {
        calculatorLapTimeChart = echarts.init(dom);
      }

      if (!combinedResults || combinedResults.length === 0 || !Number.isFinite(numLaps)) {
        calculatorLapTimeChart.clear();
        calculatorLapTimeChart.setOption({
          backgroundColor: "transparent",
          title: {
            text: "No-SC lap time profiles",
            left: 10,
            top: 8,
            textStyle: { color: "#718096", fontSize: 12, fontWeight: 400 }
          }
        });
        return;
      }

      const series = [];

      combinedResults.forEach((r) => {
        const data = [];
        r.stints.forEach(([ci, sLap, eLap]) => {
          for (let lap = sLap; lap <= eLap; lap++) {
            const age = lap - sLap;
            const lt = calcLapTime(ci, age, lap, compounds, fuelEffect);
            data.push({
              value: [lap, lt],
              compIdx: ci
            });
          }
        });
        data.sort((a, b) => a[0] - b[0]);

        const isBaseline = r.isBaseline;
        series.push({
          name: isBaseline ? `${r.label} (optimal)` : r.label,
          type: "line",
          data,
          showSymbol: false,
          symbol: "circle",
          symbolSize: isBaseline ? 3 : 2,
          lineStyle: {
            width: isBaseline ? 2.2 : 1.7,
            type: isBaseline ? "solid" : "dashed"
          },
          emphasis: { focus: "series" }
        });
      });

      const option = {
        backgroundColor: "transparent",
        textStyle: { color: "#e2e8f0" },
        tooltip: {
          trigger: "axis",
          axisPointer: { type: "line" },
          formatter: (params) => {
            if (!params || !params.length) return "";
            const lap = params[0].value[0];
            let s = `Lap ${lap}<br/>`;
            params.forEach(p => {
              const t = p.value[1];
              const ci = p.data.compIdx;
              const comp = compounds[ci].type || ["S","M","H"][ci] || "";
              s += `${p.marker}${p.seriesName}: ${t.toFixed(3)} s (${comp})<br/>`;
            });
            return s;
          }
        },
        legend: {
          top: 22,
          right: 10,
          textStyle: { color: "#cbd5f5", fontSize: 8 }
        },
        grid: { left: 55, right: 18, top: 42, bottom: 40 },
        xAxis: {
          type: "value",
          name: "Lap",
          min: 1,
          max: numLaps,
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: { color: "#cbd5f5", fontSize: 9 },
          splitLine: { show: false }
        },
        yAxis: {
          type: "value",
          name: "Lap time (s)",
          scale: true,
          nameTextStyle: { color: "#a0aec0", fontSize: 10, padding: [0, 0, 4, 0] },
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: { color: "#cbd5f5", fontSize: 9 },
          splitLine: { lineStyle: { color: "#1a202c" } }
        },
        series
      };

      calculatorLapTimeChart.setOption(option, true);
    }

    // Main Calculator Run
    function runCalculatorSimulation() {
      const errorBox = document.getElementById("calculatorErrorBox");
      errorBox.textContent = "";

      try {
        const numLapsState = appState.calculator.numLaps;
        const numLaps = Number.isFinite(numLapsState)
          ? numLapsState
          : parseInt(document.getElementById("calculatorNumLaps").value, 10);
        const fuelEffect = appState.paceModel.fuelEffect;
        const scLength = appState.calculator.scLength;
        const pitLoss = appState.calculator.pitLoss;

        const compounds = [
          { type: "S", pace: appState.calculator.paceS, degradation: appState.paceModel.degSoft },
          { type: "M", pace: appState.calculator.paceM, degradation: appState.paceModel.degMedium },
          { type: "H", pace: appState.calculator.paceH, degradation: appState.paceModel.degHard }
        ];

        if (!Number.isFinite(numLaps) || numLaps <= 0) throw new Error("Num laps must be a positive integer.");
        if (!Number.isFinite(fuelEffect)) throw new Error("Fuel effect must be a number.");
        if (!Number.isFinite(scLength) || scLength <= 0) throw new Error("SC length must be a positive integer.");
        if (!Number.isFinite(pitLoss) || pitLoss < 0) throw new Error("Pit loss must be a non-negative number.");
        for (const c of compounds) {
          if (!Number.isFinite(c.pace) || !Number.isFinite(c.degradation)) {
            throw new Error("All compound pace and degradation values must be numbers.");
          }
        }

        const scProbRanges = getCalculatorScProbRangesFromState();

        const compoundIndices = compounds.map((_, i) => i);
        const typeToIdx = {};
        compounds.forEach((c, i) => { typeToIdx[c.type.toUpperCase()] = i; });

        // Baseline free rule (not plotted)
        const freeRule = new TwoCompoundTyreRule(compoundIndices);
        const freeSummary = calcSummarizeResults(
          numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, freeRule
        );

        const freeEntries = Object.entries(freeSummary.results)
          .filter(([, info]) => Number.isFinite(info.expected_time));

        if (freeEntries.length === 0) {
          throw new Error("No valid free strategies; check inputs.");
        }

        // Find globally optimal two-compound strategy
        let optimalEntry = null;
        let baselineFree = INF;

        for (const [startType, info] of freeEntries) {
          if (info.expected_time < baselineFree) {
            baselineFree = info.expected_time;
            optimalEntry = { startType, info };
          }
        }

        if (!optimalEntry || !optimalEntry.info.no_sc_stints || !optimalEntry.info.no_sc_stints.length) {
          throw new Error("Unable to compute an optimal two-compound strategy.");
        }

        // Tyre sequence of the optimal strategy under no SC
        const optimalStints = optimalEntry.info.no_sc_stints;
        const optimalTyreSeq = optimalStints
          .map(([ci]) => compounds[ci].type)
          .join("→");

        // Always include optimal two-compound strategy first
        const combinedResults = [];
        const seenLabels = new Set();

        combinedResults.push({
          label: optimalTyreSeq,
          expected_time: baselineFree,
          stints: optimalStints,
          isBaseline: true
        });
        seenLabels.add(optimalTyreSeq);

        // Fixed patterns from user input
        const patterns = getCalculatorStrategyPatterns();

        for (const pattern of patterns) {
          const patternIndices = [];
          let valid = true;
          for (const t of pattern) {
            const idx = typeToIdx[t];
            if (idx === undefined) { valid = false; break; }
            patternIndices.push(idx);
          }
          if (!valid) continue;

          const rule = new PatternUnlessSCTyreRule(patternIndices, compoundIndices);
          const summary = calcSummarizeResults(
            numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, rule
          );
          const entries = Object.entries(summary.results);
          if (entries.length === 0) continue;

          const [startType, info] = entries[0];
          if (!Number.isFinite(info.expected_time)) continue;

          const label = pattern.join("→");
          if (seenLabels.has(label)) continue; // don't duplicate optimal

          combinedResults.push({
            label,
            expected_time: info.expected_time,
            stints: info.no_sc_stints
          });
          seenLabels.add(label);
        }

        if (combinedResults.length === 0) {
          throw new Error("No valid fixed strategies from the current patterns.");
        }

        updateCalculatorCombinedChartAndStints(combinedResults, compounds, baselineFree);
        updateCalculatorLapTimeChart(combinedResults, compounds, numLaps, fuelEffect);
      } catch (e) {
        errorBox.textContent = e.message;
        updateCalculatorCombinedChartAndStints([], [], NaN);
        updateCalculatorLapTimeChart([], [], NaN, NaN);
      }
    }

    function seedCalculatorPatternsFromFree() {
      try {
        const numLapsState = appState.calculator.numLaps;
        const numLaps = Number.isFinite(numLapsState)
          ? numLapsState
          : parseInt(document.getElementById("calculatorNumLaps").value, 10);
        const fuelEffect = appState.paceModel.fuelEffect;
        const scLength = appState.calculator.scLength;
        const pitLoss = appState.calculator.pitLoss;

        const compounds = [
          { type: "S", pace: appState.calculator.paceS, degradation: appState.paceModel.degSoft },
          { type: "M", pace: appState.calculator.paceM, degradation: appState.paceModel.degMedium },
          { type: "H", pace: appState.calculator.paceH, degradation: appState.paceModel.degHard }
        ];

        if (!Number.isFinite(numLaps) || !Number.isFinite(fuelEffect) ||
            !Number.isFinite(scLength) || !Number.isFinite(pitLoss) ||
            compounds.some(c => !Number.isFinite(c.pace) || !Number.isFinite(c.degradation))) {
          return;
        }

        const scProbRanges = getCalculatorScProbRangesFromState();
        const patterns = calcComputeFreePatterns(
          numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss
        ).slice(0, 3);

        const strategyInputs = document.querySelectorAll('.calculatorStrategyInput');
        const nextStrategies = Array.from(strategyInputs, (_, idx) => patterns[idx] ? patterns[idx].join(',') : '');
        saveToState('calculator.strategies', nextStrategies);
        renderCalculatorStrategyInputsFromState();
      } catch (_) {
        // Leave as-is if seeding fails.
      }
    }

    // Initialize Calculator Panel
    function initializeCalculatorPanel(sessionData) {
      if (!sessionData || sessionData.length === 0) return;

      // Get circuit name from session data
      const circuitName = sessionData.length > 0 ? String(sessionData[0].circuit_name || "").trim() : "";

      // Get num laps from session data
      const isRestoringPermalink = window.permalinkSession && window.permalinkSession.isRestoring;
      const schedLaps = sessionData.length > 0 ? parseInt(sessionData[0].sched_laps) : 71;
      const defaultNumLaps = isNaN(schedLaps) ? 71 : schedLaps;
      if (!isRestoringPermalink || appState.calculator.numLaps === null || appState.calculator.numLaps === undefined) {
        saveToState('calculator.numLaps', defaultNumLaps);
      }

      configureCalculatorPanelFromCircuit(circuitName, { isRestoringPermalink });
    }

    // Set up calculator event listeners
    document.getElementById("calculatorAddRangeBtn")
      .addEventListener("click", () => addCalculatorScProbRow());

    document.getElementById("calculatorRunBtn").addEventListener("click", runCalculatorSimulation);

    // Add event listeners to save calculator inputs to state
    document.getElementById('calculatorNumLaps').addEventListener('input', function() {
      const text = this.value.trim();
      if (text === '') {
        saveToState('calculator.numLaps', null);
      } else {
        const value = parseInt(text, 10);
        if (!Number.isFinite(value) || value <= 0) return;
        saveToState('calculator.numLaps', value);
      }
      renderCalculatorInputsFromState({ skip: ['calculatorNumLaps'] });
    });
    document.getElementById('calculatorPitLoss').addEventListener('input', function() {
      const text = this.value.trim();
      if (text === '') {
        saveToState('calculator.pitLoss', null);
      } else {
        const value = parseFloat(text);
        if (!Number.isFinite(value)) return;
        saveToState('calculator.pitLoss', value);
      }
      renderCalculatorInputsFromState({ skip: ['calculatorPitLoss'] });
    });
    document.getElementById('calculatorScLength').addEventListener('input', function() {
      const text = this.value.trim();
      if (text === '') {
        saveToState('calculator.scLength', null);
      } else {
        const value = parseInt(text, 10);
        if (!Number.isFinite(value)) return;
        saveToState('calculator.scLength', value);
      }
      renderCalculatorInputsFromState({ skip: ['calculatorScLength'] });
    });
    document.getElementById('calculatorFuelEffect').addEventListener('input', function() {
      const value = parseFloat(this.value);
      if (!Number.isFinite(value)) return;
      saveToState('paceModel.fuelEffect', value);
      renderPaceModelInputsFromState({ skip: ['calculatorFuelEffect'] });
      onLapTimeAdjustmentChange();
    });
    document.getElementById('calculatorPaceS').addEventListener('input', function() {
      const text = this.value.trim();
      if (text === '') {
        saveToState('calculator.paceS', null);
      } else {
        const value = parseFloat(text);
        if (!Number.isFinite(value)) return;
        saveToState('calculator.paceS', value);
      }
      renderCalculatorInputsFromState({ skip: ['calculatorPaceS'] });
    });
    document.getElementById('calculatorPaceM').addEventListener('input', function() {
      const text = this.value.trim();
      if (text === '') {
        saveToState('calculator.paceM', null);
      } else {
        const value = parseFloat(text);
        if (!Number.isFinite(value)) return;
        saveToState('calculator.paceM', value);
      }
      renderCalculatorInputsFromState({ skip: ['calculatorPaceM'] });
    });
    document.getElementById('calculatorPaceH').addEventListener('input', function() {
      const text = this.value.trim();
      if (text === '') {
        saveToState('calculator.paceH', null);
      } else {
        const value = parseFloat(text);
        if (!Number.isFinite(value)) return;
        saveToState('calculator.paceH', value);
      }
      renderCalculatorInputsFromState({ skip: ['calculatorPaceH'] });
    });
    document.getElementById('calculatorDegS').addEventListener('input', function() {
      const value = parseFloat(this.value);
      if (!Number.isFinite(value)) return;
      saveToState('paceModel.degSoft', value);
      renderPaceModelInputsFromState({ skip: ['calculatorDegS'] });
      onLapTimeAdjustmentChange();
    });
    document.getElementById('calculatorDegM').addEventListener('input', function() {
      const value = parseFloat(this.value);
      if (!Number.isFinite(value)) return;
      saveToState('paceModel.degMedium', value);
      renderPaceModelInputsFromState({ skip: ['calculatorDegM'] });
      onLapTimeAdjustmentChange();
    });
    document.getElementById('calculatorDegH').addEventListener('input', function() {
      const value = parseFloat(this.value);
      if (!Number.isFinite(value)) return;
      saveToState('paceModel.degHard', value);
      renderPaceModelInputsFromState({ skip: ['calculatorDegH'] });
      onLapTimeAdjustmentChange();
    });

    // Save strategy inputs to state
    const calculatorStrategyInputs = document.querySelectorAll('.calculatorStrategyInput');
    calculatorStrategyInputs.forEach((input, idx) => {
      input.addEventListener('input', function() {
        const strategies = Array.isArray(appState.calculator.strategies)
          ? appState.calculator.strategies.slice()
          : new Array(calculatorStrategyInputs.length).fill('');
        strategies[idx] = this.value;
        saveToState('calculator.strategies', strategies);
      });
    });

    // Handle window resize for calculator charts
    window.addEventListener('resize', () => {
      if (calculatorStrategyChart) {
        calculatorStrategyChart.resize();
      }
      if (calculatorLapTimeChart) {
        calculatorLapTimeChart.resize();
      }
    });

    // ============================================================================
    // INITIALIZATION
    // ============================================================================

    init();
  </script>
</body>
</html>
