<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Gap to P1 by Lap — ECharts (Season → GP → Session + Colors)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root { --bg:#0f1115; --fg:#e8e8e8; --muted:#8b8b8b; --panel:#1a1d24; --border:#232833; }
    body { margin:0; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--fg); background:var(--bg); }
    header { padding:10px 14px; background:var(--panel); display:flex; gap:12px; align-items:center; flex-wrap:wrap; border-bottom:1px solid var(--border); }
    .title { font-weight:600; margin-right:auto; }
    label.small { color:var(--muted); font-size:12px; }
    select { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; min-width: 160px; }
    .small { color:var(--muted); font-size:12px; }
    .layout { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 56px); }
    #sidebar { background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; }
    #sidebar .section { padding:12px; border-bottom:1px solid var(--border); }
    #driverList { padding:10px; overflow:auto; }
    .driver { display:flex; align-items:center; gap:8px; padding:4px 2px; border-radius:6px; }
    .driver:hover { background:#141820; }
    #chart { width:100%; height:100%; }
    .buttons { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .buttons button { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; cursor:pointer; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
  </style>
</head>
<body>
  <header>
    <div class="title">ECharts — Step Lines with End Labels</div>
    <label class="small" for="seasonSel">Season</label>
    <select id="seasonSel" title="Season"></select>
    <label class="small" for="gpSel">GP</label>
    <select id="gpSel" title="Grand Prix"></select>
    <label class="small" for="sessionSel">Session</label>
    <select id="sessionSel" title="Session type"></select>
    <span id="meta" class="small"></span>
  </header>

  <div class="layout">
    <aside id="sidebar">
      <div class="section">
        <div class="small">Drivers / lines</div>
        <div class="buttons">
          <button id="btnAll"  type="button">Select all</button>
          <button id="btnNone" type="button">Clear all</button>
        </div>
        <div class="hint">Toggle lines; y-axis rescales to visible series.</div>
      </div>
      <div id="driverList" aria-label="Driver list"></div>
    </aside>
    <main id="chart"></main>
  </div>

  <script>
    // ---------------- Chart setup ----------------
    const chart = echarts.init(document.getElementById('chart'), null, { renderer: 'canvas' });
    window.addEventListener('resize', () => chart.resize());
    const hiddenLegend = { show: false, selected: {} };

    // DOM refs
    const seasonSel  = document.getElementById('seasonSel');
    const gpSel      = document.getElementById('gpSel');
    const sessionSel = document.getElementById('sessionSel');
    const meta       = document.getElementById('meta');
    const driverList = document.getElementById('driverList');
    const btnAll     = document.getElementById('btnAll');
    const btnNone    = document.getElementById('btnNone');

    // State
    let currentSeriesNames = [];
    let lastYFallback = { min: -100, max: 1 };
    let manifestItems = [];   // rows from driver_lines_filenames.csv
    // byYear: Map<year, Map<round_no, {race, circuit, sessions: [{type, filename}]}>>
    const byYear = new Map();

    // driverColors: Map("year|round" => Map(driver => hexColor))
    const driverColors = new Map();

    // ---------------- CSV helpers ----------------
    function splitCSVLine(line) {
      const out = []; let cur = ''; let inQ = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQ && line[i+1] === '"') { cur += '"'; i++; }
          else { inQ = !inQ; }
        } else if (ch === ',' && !inQ) { out.push(cur.trim()); cur = ''; }
        else { cur += ch; }
      }
      out.push(cur.trim());
      return out;
    }
    function parseCSVToObjects(text) {
      const lines = text.split(/\r?\n/).filter(s => s.trim().length);
      if (!lines.length) return [];
      const header = splitCSVLine(lines[0]).map(h => h.toLowerCase());
      return lines.slice(1).map(line => {
        const cells = splitCSVLine(line);
        const obj = {};
        for (let i = 0; i < header.length; i++) obj[header[i]] = cells[i] ?? '';
        return obj;
      });
    }
    function parseDriverLines(csvText) {
      const lines = csvText.split(/\r?\n/).filter(s => s.trim().length);
      const rows = []; let lapCount = 0; const allY = [];
      for (const line of lines) {
        const cells = splitCSVLine(line);
        if (!cells.length) continue;
        const label = (cells[0] || '').trim();
        const nums = [];
        for (let i = 1; i < cells.length; i++) {
          const v = parseFloat(cells[i]);
          if (Number.isFinite(v)) nums.push(v);
        }
        if (!label || nums.length === 0) continue;
        lapCount = Math.max(lapCount, nums.length);
        allY.push(...nums);
        rows.push({ label, values: nums });
      }
      const minY = allY.length ? Math.min(...allY) : -100;
      const maxY = allY.length ? Math.max(...allY) : 1;
      return { rows, lapCount, minY, maxY };
    }

    // ---------------- Colors ----------------
    async function loadDriverColors() {
      // expects driver_colors.csv with columns: year, round_no, driver, color
      const text = await fetch('driver_colors.csv', { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error('Failed to load driver_colors.csv');
        return r.text();
      });
      const rows = parseCSVToObjects(text);
      driverColors.clear();
      for (const r of rows) {
        const year = (r.year || '').trim();
        const round = parseInt(r.round_no, 10);
        const drv = (r.driver || '').trim();
        const col = (r.color || '').trim();
        if (!year || !Number.isFinite(round) || !drv || !/^#?[0-9a-f]{6}$/i.test(col.replace('#',''))) continue;
        const k = `${year}|${round}`;
        if (!driverColors.has(k)) driverColors.set(k, new Map());
        const hex = col.startsWith('#') ? col : ('#' + col);
        driverColors.get(k).set(drv, hex);
      }
    }
    function getColorFor(year, round, driver) {
      const k = `${year}|${Number(round)}`;
      return driverColors.get(k)?.get(driver) || null;
    }

    // ---------------- ECharts option builders ----------------
    function buildOption(parsed, titleText, colorLookup) {
      const { rows, lapCount, minY, maxY } = parsed;
      const rightX = lapCount + 1.2;

      const series = [];
      hiddenLegend.selected = {};

      for (const { label, values } of rows) {
        const data = [];
        for (let i = 0; i < values.length; i++) data.push([i + 1, values[i]]);
        if (values.length) data.push([rightX, values[values.length - 1]]);
        hiddenLegend.selected[label] = true;

        const col = colorLookup ? colorLookup(label) : null;

        series.push({
          name: label,
          type: 'line',
          data,
          step: 'end',
          showSymbol: false,
          color: col || undefined,                    // series color
          lineStyle: { width: 1.8, opacity: 0.95, color: col || undefined },
          emphasis: { focus: 'series', blurScope: 'global', lineStyle: { width: 3.2 } },
          blur: { lineStyle: { opacity: 0.15 } },     // dim other series on hover
          endLabel: { show: true, formatter: '{a}', position: 'right', offset: [6,0], color: col || 'inherit' },
          progressive: 2000,
          animation: false,
          clip: true
        });
      }

      lastYFallback = {
        min: Math.min(-100, Math.floor(minY - 2)),
        max: Math.max(  1, Math.ceil (maxY + 1))
      };

      return {
        backgroundColor: 'transparent',
        title: { text: titleText || 'Gap to P1 by Lap', left: 'center', top: 6, textStyle: { color: '#e8e8e8', fontSize: 16, fontWeight: 600 } },
        grid: { left: 56, right: 130, top: 42, bottom: 40 },
        tooltip: { show: false },
        legend: hiddenLegend,
        xAxis: {
          type: 'value',
          min: 1,
          max: rightX + 0.1,
          name: 'Lap',
          nameLocation: 'middle',
          nameGap: 28,
          axisLabel: { color: '#c8c8c8', formatter: v => Number.isInteger(v) ? v : '' },
          splitLine: { lineStyle: { color: '#2a2f3a' } },
          axisLine: { lineStyle: { color: '#6b6f7b' } },
        },
        yAxis: {
          type: 'value',
          min: lastYFallback.min,
          max: lastYFallback.max,
          name: 'Gap to P1 (s)',
          nameLocation: 'middle',
          nameGap: 40,
          axisLabel: { color: '#c8c8c8' },
          splitLine: { lineStyle: { color: '#2a2f3a' } },
          axisLine: { lineStyle: { color: '#6b6f7b' } },
        },
        series: [
          ...series,
          { // baseline y=0
            name: '__baseline__',
            type: 'line',
            data: [[1, 0], [lapCount + 1.3, 0]],
            showSymbol: false,
            lineStyle: { width: 1, opacity: 0.35, color: '#aaaaaa' },
            silent: true,
            z: -1
          }
        ]
      };
    }

    // Recompute y-axis to visible series
    function updateYAxisToVisible() {
      const opt = chart.getOption();
      const legendSel = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
      const series = (opt.series || []).filter(s =>
        s.type === 'line' && s.name !== '__baseline__' && (legendSel[s.name] !== false)
      );
      let min = Infinity, max = -Infinity;
      for (const s of series) {
        for (const pt of s.data) {
          const y = Array.isArray(pt) ? pt[1] : (pt && pt.value ? pt.value[1] : null);
          if (Number.isFinite(y)) { if (y < min) min = y; if (y > max) max = y; }
        }
      }
      if (!series.length || !Number.isFinite(min) || !Number.isFinite(max)) {
        chart.setOption({ yAxis: { min: lastYFallback.min, max: lastYFallback.max } });
        return;
      }
      const span = Math.max(1e-6, max - min);
      const pad  = Math.max(0.02 * span, 0.5);
      const yMin = Math.min(min - pad, 0);
      const yMax = Math.max(max + pad, 0.5);
      chart.setOption({ yAxis: { min: Math.floor(yMin), max: Math.ceil(yMax) } });
    }
    chart.on('legendselectchanged', updateYAxisToVisible);

    // ---------------- Sidebar: toggles ----------------
    function buildDriverList(names) {
      driverList.innerHTML = '';
      const sel = ((chart.getOption().legend || [])[0] || {}).selected || {};
      for (const name of names.slice().sort()) {
        const row = document.createElement('label');
        row.className = 'driver';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = sel[name] !== false;
        cb.addEventListener('change', () => {
          chart.dispatchAction({ type: cb.checked ? 'legendSelect' : 'legendUnSelect', name });
          updateYAxisToVisible();
        });
        row.appendChild(cb);
        row.appendChild(document.createTextNode(' ' + name));
        driverList.appendChild(row);
      }
    }
    function syncCheckboxes(val) {
      const boxes = driverList.querySelectorAll('input[type="checkbox"]');
      boxes.forEach(b => b.checked = val);
    }
    btnAll.addEventListener('click', () => {
      for (const name of currentSeriesNames) chart.dispatchAction({ type: 'legendSelect', name });
      updateYAxisToVisible(); syncCheckboxes(true);
    });
    btnNone.addEventListener('click', () => {
      for (const name of currentSeriesNames) chart.dispatchAction({ type: 'legendUnSelect', name });
      updateYAxisToVisible(); syncCheckboxes(false);
    });

    // ---------------- Manifest + 3-level selection ----------------
    function prettySession(typeRaw) {
      const t = (typeRaw || '').toString().trim().toUpperCase();
      if (t === 'R' || t === 'RACE')   return 'Race';
      if (t === 'S' || t === 'SPRINT') return 'Sprint';
      return t.charAt(0) + t.slice(1).toLowerCase();
    }

    function buildIndex() {
      byYear.clear();
      for (const o of manifestItems) {
        const year = (o.year || '').trim();
        const round = parseInt(o.round_no, 10);
        if (!year || !Number.isFinite(round)) continue;
        if (!byYear.has(year)) byYear.set(year, new Map());
        const yMap = byYear.get(year);
        if (!yMap.has(round)) yMap.set(round, { race: o.race || '', circuit: o.circuit || '', sessions: [] });
        yMap.get(round).sessions.push({ type: o.type || '', filename: (o.filename || '').trim() });
        if (o.race)    yMap.get(round).race = o.race;
        if (o.circuit) yMap.get(round).circuit = o.circuit;
      }
    }

    function populateSeasons() {
      seasonSel.innerHTML = '';
      const years = Array.from(byYear.keys()).sort((a,b) => Number(b) - Number(a));
      for (const y of years) {
        const opt = document.createElement('option');
        opt.value = y; opt.textContent = y;
        seasonSel.appendChild(opt);
      }
      seasonSel.disabled = years.length === 0;
    }

    function populateGPs(year) {
      gpSel.innerHTML = '';
      sessionSel.innerHTML = '';
      if (!byYear.has(year)) { gpSel.disabled = true; sessionSel.disabled = true; return; }
      const rounds = Array.from(byYear.get(year).keys()).sort((a,b) => a - b);
      for (const r of rounds) {
        const meta = byYear.get(year).get(r);
        const label = `Round ${r} — ${meta.race || meta.circuit || 'Grand Prix'}`;
        const opt = document.createElement('option');
        opt.value = String(r); opt.textContent = label;
        gpSel.appendChild(opt);
      }
      gpSel.disabled = rounds.length === 0;
    }

    function populateSessions(year, round) {
      sessionSel.innerHTML = '';
      const meta = byYear.get(year)?.get(Number(round));
      if (!meta) { sessionSel.disabled = true; return; }
      const seen = new Map();
      for (const s of meta.sessions) {
        const key = (s.type || '').toString();
        if (!seen.has(key) && s.filename) seen.set(key, s.filename);
      }
      const entries = Array.from(seen.entries());
      for (const [type, filename] of entries) {
        const opt = document.createElement('option');
        opt.value = type; opt.textContent = prettySession(type);
        opt.dataset.filename = filename;
        sessionSel.appendChild(opt);
      }
      sessionSel.disabled = entries.length === 0;
    }

    async function onSessionChange() {
      const year  = seasonSel.value;
      const round = gpSel.value;
      const opt   = sessionSel.options[sessionSel.selectedIndex];
      if (!opt) return;
      const type  = opt.value;
      const file  = opt.dataset.filename;
      const metaR = byYear.get(year)?.get(Number(round));
      const title = `${year}, Round ${round} (${prettySession(type)}) — ${metaR?.race || metaR?.circuit || ''}`;
      await loadCsvAndPlot(file, title, year, round);
    }

    async function loadManifest() {
      seasonSel.disabled = gpSel.disabled = sessionSel.disabled = true;
      try {
        const text = await fetch('driver_lines_filenames.csv', { cache: 'no-store' }).then(r => r.text());
        const objs = parseCSVToObjects(text);
        manifestItems = objs.filter(o => (o.filename || '').trim().length);
        buildIndex();
        populateSeasons();
        if (seasonSel.options.length) {
          seasonSel.selectedIndex = 0;
          populateGPs(seasonSel.value);
          if (gpSel.options.length) {
            gpSel.selectedIndex = 0;
            populateSessions(seasonSel.value, gpSel.value);
            if (sessionSel.options.length) {
              sessionSel.selectedIndex = 0;
              await onSessionChange(); // auto-plot first
            }
          }
        } else {
          meta.textContent = 'No entries in driver_lines_filenames.csv';
        }
      } catch (e) {
        console.error(e);
        meta.textContent = 'Failed to load driver_lines_filenames.csv';
      } finally {
        seasonSel.disabled = false;
        gpSel.disabled = false;
        sessionSel.disabled = false;
      }
    }

    seasonSel.addEventListener('change', () => {
      populateGPs(seasonSel.value);
      if (gpSel.options.length) gpSel.selectedIndex = 0;
      populateSessions(seasonSel.value, gpSel.value);
      if (sessionSel.options.length) { sessionSel.selectedIndex = 0; onSessionChange(); }
    });
    gpSel.addEventListener('change', () => {
      populateSessions(seasonSel.value, gpSel.value);
      if (sessionSel.options.length) { sessionSel.selectedIndex = 0; onSessionChange(); }
    });
    sessionSel.addEventListener('change', onSessionChange);

    // ---------------- Plotting ----------------
    async function loadCsvAndPlot(path, title, year, round) {
      const csv = await fetch(path, { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status} for ${path}`);
        return r.text();
      });
      const parsed = parseDriverLines(csv);

      // Build a per-driver color resolver for the active year/round
      const colorLookup = (driver) => getColorFor(year, round, driver);

      const option = buildOption(parsed, title, colorLookup);
      chart.setOption(option, true);
      currentSeriesNames = parsed.rows.map(r => r.label);
      buildDriverList(currentSeriesNames);
      meta.textContent = `Dataset: ${title} • Laps: ${parsed.lapCount} • Lines: ${currentSeriesNames.length}`;
      updateYAxisToVisible();
    }

    // ---------------- Boot ----------------
    chart.setOption({
      backgroundColor: 'transparent',
      title: { text: 'Loading datasets…', left: 'center', top: 'center', textStyle: { color: '#6b6f7b', fontWeight: 500 } },
      grid: { left: 56, right: 130, top: 42, bottom: 40 },
      xAxis: { type: 'value', min: 1, max: 10, axisLabel: { color: '#c8c8c8' } },
      yAxis: { type: 'value', min: -100, max: 1, axisLabel: { color: '#c8c8c8' } },
      legend: hiddenLegend
    });

    // Ensure colors are ready before first plot
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        await loadDriverColors();   // loads driver_colors.csv once
      } catch (e) {
        console.warn('No driver_colors.csv or failed to parse; falling back to default colors.', e);
      }
      await loadManifest();        // loads driver_lines_filenames.csv and kicks off first plot
    });
  </script>
</body>
</html>
