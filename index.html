<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Formula One Race Visualization</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <style>
    :root { --bg:#0f1115; --fg:#e8e8e8; --muted:#8b8b8b; --panel:#1a1d24; --border:#232833; }
    body { margin:0; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--fg); background:var(--bg); }
    header { padding:10px 14px; background:var(--panel); display:flex; gap:12px; align-items:center; flex-wrap:wrap; border-bottom:1px solid var(--border); }
    .title { font-weight:600; margin-right:auto; }
    label.small { color:var(--muted); font-size:12px; }
    select { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; min-width: 160px; }
    .small { color:var(--muted); font-size:12px; }
    .layout { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 56px); }
    #sidebar { background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; }
    #sidebar .section { padding:12px; border-bottom:1px solid var(--border); }
    #driverList { padding:10px; overflow:auto; }
    .driver { display:flex; align-items:center; gap:8px; padding:4px 2px; border-radius:6px; }
    .driver:hover { background:#141820; }
    #chart { width:100%; height:100%; }
    .buttons { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .buttons button { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; cursor:pointer; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
    .credit { position:fixed; left:12px; bottom:10px; z-index:9999; font-size:12px; color:var(--muted); text-decoration:none; opacity:0.9; }
    .credit:hover { text-decoration:underline; opacity:1; }
  </style>
</head>
<body>
  <header>
    <label class="small" for="seasonSel">Season</label>
    <select id="seasonSel" title="Season"></select>
    <label class="small" for="gpSel">GP</label>
    <select id="gpSel" title="Grand Prix"></select>
    <label class="small" for="sessionSel">Session</label>
    <select id="sessionSel" title="Session type"></select>
    <!-- <span id="meta" class="small"></span> -->
  </header>

  <div class="layout">
    <aside id="sidebar">
      <div class="section">
        <div class="buttons">
          <button id="btnAll"  type="button">Select all</button>
          <button id="btnNone" type="button">Clear all</button>
        </div>
      </div>
      <div id="driverList" aria-label="Driver list"></div>
    </aside>
    <main id="chart"></main>
  </div>

  <script>
    // ---------------- Chart setup ----------------
    const chart = echarts.init(document.getElementById('chart'), null, { renderer: 'canvas' });
    window.addEventListener('resize', () => chart.resize());
    const hiddenLegend = { show: false, selected: {} };

    // DOM refs
    const seasonSel  = document.getElementById('seasonSel');
    const gpSel      = document.getElementById('gpSel');
    const sessionSel = document.getElementById('sessionSel');
    const meta       = document.getElementById('meta');
    const driverList = document.getElementById('driverList');
    const btnAll     = document.getElementById('btnAll');
    const btnNone    = document.getElementById('btnNone');

    // State
    let currentSeriesNames = [];
    let lastYFallback = { min: -100, max: 1 };
    let manifestItems = [];   // rows from driver_lines_filenames.csv

    // NEW: current selection for tooltip context
    let currentSelection = { year: null, round: null, sessionType: null };

    // NEW: keep original unmodified series values by driver for dynamic re-baselining
    let originalValues = new Map();          // Map<driver, number[]> raw values per lap
    let originalLapCount = 0;                // total race laps
    let rightXGlobal = 0;                    // x for extended last point

    // byYear: Map<year, Map<round_no, {race, circuit, sessions: [{type, filename}]>>>
    const byYear = new Map();

    // driverInfo: Map(key => Map(driver => { color, fullName, teamName, headshotUrl }))
    // key can be `${year}|${round}` or `${year}|${round}|${SESSION}` (uppercased)
    const driverInfo = new Map();

    // ---------------- CSV helpers ----------------
    function splitCSVLine(line) {
      const out = []; let cur = ''; let inQ = false;
      for (let i = 0; i < line.length; i++) {
        const ch = line[i];
        if (ch === '"') {
          if (inQ && line[i+1] === '"') { cur += '"'; i++; }
          else { inQ = !inQ; }
        } else if (ch === ',' && !inQ) { out.push(cur.trim()); cur = ''; }
        else { cur += ch; }
      }
      out.push(cur.trim());
      return out;
    }
    function parseCSVToObjects(text) {
      const lines = text.split(/\r?\n/).filter(s => s.trim().length);
      if (!lines.length) return [];
      const header = splitCSVLine(lines[0]).map(h => h.toLowerCase());
      return lines.slice(1).map(line => {
        const cells = splitCSVLine(line);
        const obj = {};
        for (let i = 0; i < header.length; i++) obj[header[i]] = cells[i] ?? '';
        return obj;
      });
    }
    function parseDriverLines(csvText) {
      const lines = csvText.split(/\r?\n/).filter(s => s.trim().length);
      const rows = []; let lapCount = 0; const allY = [];
      for (const line of lines) {
        const cells = splitCSVLine(line);
        if (!cells.length) continue;
        const label = (cells[0] || '').trim();
        const nums = [];
        for (let i = 1; i < cells.length; i++) {
          const v = parseFloat(cells[i]);
          if (Number.isFinite(v)) nums.push(v);
        }
        if (!label || nums.length === 0) continue;
        lapCount = Math.max(lapCount, nums.length);
        allY.push(...nums);
        rows.push({ label, values: nums });
      }
      const minY = allY.length ? Math.min(...allY) : -100;
      const maxY = allY.length ? Math.max(...allY) : 1;
      return { rows, lapCount, minY, maxY };
    }

    // ---------------- Driver info ----------------
    async function loadDriverInfo() {
      // expects driver_info.csv with columns:
      // year, round_no, session_type, driver, color, TeamName, FullName, HeadshotUrl
      const text = await fetch('driver_info.csv', { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error('Failed to load driver_info.csv');
        return r.text();
      });
      const rows = parseCSVToObjects(text);
      driverInfo.clear();
      for (const r of rows) {
        const year = (r.year || '').trim();
        const round = parseInt(r.round_no, 10);
        const drv = (r.driver || '').trim();
        const sess = (r.session_type || '').trim().toUpperCase();
        const colRaw = (r.color || '').trim();
        const colOk = /^#?[0-9a-f]{6}$/i.test(colRaw.replace('#',''));
        const color = colOk ? (colRaw.startsWith('#') ? colRaw : ('#' + colRaw)) : null;
        const teamName = (r.teamname || '').trim();
        const fullName = (r.fullname || '').trim();
        const headshotUrl = (r.headshoturl || '').trim();
        if (!year || !Number.isFinite(round) || !drv) continue;

        const kBase = `${year}|${round}`;
        if (!driverInfo.has(kBase)) driverInfo.set(kBase, new Map());
        const baseMap = driverInfo.get(kBase);
        const existing = baseMap.get(drv) || {};
        baseMap.set(drv, {
          color: color ?? existing.color ?? null,
          fullName: fullName || existing.fullName || '',
          teamName: teamName || existing.teamName || '',
          headshotUrl: headshotUrl || existing.headshotUrl || ''
        });

        if (sess) {
          const kSess = `${kBase}|${sess}`;
          if (!driverInfo.has(kSess)) driverInfo.set(kSess, new Map());
          const sessMap = driverInfo.get(kSess);
          const ex2 = sessMap.get(drv) || {};
          sessMap.set(drv, {
            color: color ?? ex2.color ?? null,
            fullName: fullName || ex2.fullName || '',
            teamName: teamName || ex2.teamName || '',
            headshotUrl: headshotUrl || ex2.headshotUrl || ''
          });
        }
      }
    }
    function getInfoFor(year, round, driver, sessionType) {
      const baseKey = `${year}|${Number(round)}`;
      const sessKey = `${baseKey}|${(sessionType||'').toString().toUpperCase()}`;
      return driverInfo.get(sessKey)?.get(driver)
          || driverInfo.get(baseKey)?.get(driver)
          || null;
    }
    function getColorFor(year, round, driver, sessionType) {
      return getInfoFor(year, round, driver, sessionType)?.color || null;
    }

    // ---------------- ECharts option builders ----------------
    function buildOption(parsed, titleText, colorLookup) {
      const { rows, lapCount, minY, maxY } = parsed;
      const rightX = lapCount + 1.2;

      const series = [];
      hiddenLegend.selected = {};

      for (const { label, values } of rows) {
        const data = [];
        for (let i = 0; i < values.length; i++) data.push([i + 1, values[i]]);
        // Only extend to the right (dummy point) for drivers who completed the full lap count.
        const isFull = values.length === lapCount;
        if (isFull && values.length) {
          data.push({ value: [rightX, values[values.length - 1]], tooltip: { show: false }, emphasis: { disabled: true } });
        }
        hiddenLegend.selected[label] = true;

        const col = colorLookup ? colorLookup(label) : null;

        series.push({
          name: label,
          type: 'line',
          data,
          step: 'end',
          showSymbol: true,
          symbol: 'circle',
          symbolSize: 4,
          itemStyle: { borderWidth: 0 },
          color: col || undefined,                    // series color
          lineStyle: { width: 1.8, opacity: 0.95, color: col || undefined },
          emphasis: { focus: 'series', blurScope: 'global', lineStyle: { width: 3.2 } },
          blur: { lineStyle: { opacity: 0.5 } },     // dim other series on hover
          // Hide end label for DNFs (shorter series); keep for full-length finishers.
          endLabel: { show: isFull, formatter: '{a}', position: 'right', offset: [6,0], color: col || 'inherit' },
          progressive: 2000,
          animation: false,
          clip: true
        });
      }

      lastYFallback = {
        min: Math.min(-100, Math.floor(minY - 2)),
        max: Math.max(  1, Math.ceil (maxY + 1))
      };

      return {
        backgroundColor: 'transparent',
        title: { text: titleText || 'Gap by Lap', left: 'center', top: 6, textStyle: { color: '#e8e8e8', fontSize: 16, fontWeight: 600 } },
        grid: { left: 56, right: 130, top: 42, bottom: 40 },

        // UPDATED tooltip with driver headshot card
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          appendToBody: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const v = Array.isArray(p.value) ? p.value : p.data?.value || p.data;
            const lap = Array.isArray(v) ? v[0] : v?.[0];
            const gap = Array.isArray(v) ? v[1] : v?.[1];

            const code = p.seriesName; // driver code/label in CSV
            const sel  = currentSelection || {};
            const info = getInfoFor(sel.year, sel.round, code, sel.sessionType);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || code;
              const teamName = info.teamName || '';
              const gapLine  = (typeof lap === 'number' && typeof gap === 'number')
                ? `<div style="margin-top:4px">Lap ${lap}: ${gap.toFixed(3)} s</div>`
                : '';
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}"
                       alt="${fullName}"
                       width="50" height="50"
                       style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${code})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${gapLine}
                  </div>
                </div>
              `;
            }

            if (typeof lap === 'number' && typeof gap === 'number') {
              return `${p.marker}<b>${code}</b><br/>Lap ${lap}: ${gap.toFixed(3)} s`;
            }
            return `${p.marker}<b>${code}</b>`;
          }
        },

        legend: hiddenLegend,
        xAxis: {
          type: 'value',
          min: 1,
          max: rightX + 0.1,
          name: 'Lap',
          nameLocation: 'middle',
          nameGap: 28,
          axisLabel: { color: '#c8c8c8', formatter: v => Number.isInteger(v) ? v : '' },
          splitLine: { lineStyle: { color: '#2a2f3a' } },
          axisLine: { lineStyle: { color: '#6b6f7b' } },
        },
        yAxis: {
          type: 'value',
          min: lastYFallback.min,
          max: lastYFallback.max,
          name: 'Gap to Driver in Front (secs)',
          nameLocation: 'middle',
          nameGap: 40,
          axisLabel: { color: '#c8c8c8' },
          splitLine: { lineStyle: { color: '#2a2f3a' } },
          axisLine: { lineStyle: { color: '#6b6f7b' } },
        },
        series: [
          ...series,
          { // baseline y=0
            name: '__baseline__',
            type: 'line',
            data: [[1, 0], [lapCount + 1.3, 0]],
            showSymbol: false,
            lineStyle: { width: 1, opacity: 0.35, color: '#aaaaaa' },
            silent: true,
            z: -1
          }
        ]
      };
    }

    // Recompute y-axis to visible series
    function updateYAxisToVisible() {
      const opt = chart.getOption();
      const legendSel = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
      const series = (opt.series || []).filter(s =>
        s.type === 'line' && s.name !== '__baseline__' && (legendSel[s.name] !== false)
      );
      let min = Infinity, max = -Infinity;
      for (const s of series) {
        for (const pt of s.data) {
          const y = Array.isArray(pt) ? pt[1] : (pt && pt.value ? pt.value[1] : null);
          if (Number.isFinite(y)) { if (y < min) min = y; if (y > max) max = y; }
        }
      }
      if (!series.length || !Number.isFinite(min) || !Number.isFinite(max)) {
        chart.setOption({ yAxis: { min: lastYFallback.min, max: lastYFallback.max } });
        return;
      }
      const span = Math.max(1e-6, max - min);
      const pad  = Math.max(0.02 * span, 0.5);
      const yMin = Math.min(min - pad, 0);
      const yMax = Math.max(max + pad, 0.5);
      chart.setOption({ yAxis: { min: Math.floor(yMin), max: Math.ceil(yMax) } });
    }

    // NEW: recompute displayed series so each lap is relative to the max value among SELECTED drivers
    function recomputeSeriesRelativeToSelection() {
      if (!originalLapCount) return; // not ready
      const opt = chart.getOption();
      const legendSel = (opt.legend && opt.legend[0] && opt.legend[0].selected) || {};
      const selected = currentSeriesNames.filter(n => legendSel[n] !== false);

      // For each lap i, compute max over selected drivers that have that lap
      const lapMax = new Array(originalLapCount);
      for (let i = 0; i < originalLapCount; i++) {
        let any = false, m = -Infinity;
        for (const name of selected) {
          const arr = originalValues.get(name);
          if (arr && arr.length > i) { any = true; if (arr[i] > m) m = arr[i]; }
        }
        lapMax[i] = any ? m : 0; // if no selected drivers have this lap, subtract 0
      }

      // Build series updates using ORIGINAL values, without mutating them
      const updates = [];
      for (const name of currentSeriesNames) {
        const arr = originalValues.get(name) || [];
        const adjusted = arr.map((v, i) => v - lapMax[i]);
        const isFull = arr.length === originalLapCount;
        const data = adjusted.map((y, i) => [i + 1, y]);
        if (isFull && adjusted.length) {
          data.push({ value: [rightXGlobal, adjusted[adjusted.length - 1]], tooltip: { show: false }, emphasis: { disabled: true } });
        }
        updates.push({ name, data });
      }
      chart.setOption({ series: updates.map(u => ({ name: u.name, data: u.data })) });
    }

    // doesn't get called because the legend is hidden, but kept for reference
    // chart.on('legendselectchanged', () => {
    //   recomputeSeriesRelativeToSelection();
    //   updateYAxisToVisible();
    // });

    // ---------------- Sidebar: toggles ----------------
    function buildDriverList(names) {
      driverList.innerHTML = '';
      const sel = ((chart.getOption().legend || [])[0] || {}).selected || {};
      const year = seasonSel.value;
      const round = gpSel.value;
      const sessionType = (sessionSel.value || '').toString();
      for (const name of names) {
        const info = getInfoFor(year, round, name, sessionType);
        const labelText = info
          ? `${info.fullName || name} (${name})`
          : name;

        const row = document.createElement('label');
        row.className = 'driver';
        const cb = document.createElement('input');
        cb.type = 'checkbox';
        cb.checked = sel[name] !== false;

        // Create a colored name span using per-driver color for the current selection
        const nameSpan = document.createElement('span');
        nameSpan.textContent = ' ' + labelText;
        const col = getColorFor(year, round, name, sessionType);
        if (col) {
          nameSpan.style.color = col;            // color the driver display text
          try { cb.style.accentColor = col; }    // modern browsers: tint the checkbox
          catch (e) { /* noop if unsupported */ }
        }

        cb.addEventListener('change', () => {
          chart.dispatchAction({ type: cb.checked ? 'legendSelect' : 'legendUnSelect', name });
          // recompute + axis handled by legendselectchanged listener
          recomputeSeriesRelativeToSelection();
          updateYAxisToVisible();
        });
        row.appendChild(cb);
        row.appendChild(nameSpan);
        driverList.appendChild(row);
      }
    }
    function syncCheckboxes(val) {
      const boxes = driverList.querySelectorAll('input[type="checkbox"]');
      boxes.forEach(b => b.checked = val);
    }
    btnAll.addEventListener('click', () => {
      for (const name of currentSeriesNames) chart.dispatchAction({ type: 'legendSelect', name });
      recomputeSeriesRelativeToSelection();
      updateYAxisToVisible();
      syncCheckboxes(true);
    });
    btnNone.addEventListener('click', () => {
      for (const name of currentSeriesNames) chart.dispatchAction({ type: 'legendUnSelect', name });
      recomputeSeriesRelativeToSelection();
      updateYAxisToVisible();
      syncCheckboxes(false);
    });

    // ---------------- Manifest + 3-level selection ----------------
    function prettySession(typeRaw) {
      const t = (typeRaw || '').toString().trim().toUpperCase();
      if (t === 'R' || t === 'RACE')   return 'Race';
      if (t === 'S' || t === 'SPRINT') return 'Sprint';
      return t.charAt(0) + t.slice(1).toLowerCase();
    }

    function buildIndex() {
      byYear.clear();
      for (const o of manifestItems) {
        const year = (o.year || '').trim();
        const round = parseInt(o.round_no, 10);
        if (!year || !Number.isFinite(round)) continue;
        if (!byYear.has(year)) byYear.set(year, new Map());
        const yMap = byYear.get(year);
        if (!yMap.has(round)) yMap.set(round, { race: o.race || '', circuit: o.circuit || '', sessions: [] });
        yMap.get(round).sessions.push({ type: o.type || '', filename: (o.filename || '').trim() });
        if (o.race)    yMap.get(round).race = o.race;
        if (o.circuit) yMap.get(round).circuit = o.circuit;
      }
    }

    function populateSeasons() {
      seasonSel.innerHTML = '';
      const years = Array.from(byYear.keys()).sort((a,b) => Number(b) - Number(a));
      for (const y of years) {
        const opt = document.createElement('option');
        opt.value = y; opt.textContent = y;
        seasonSel.appendChild(opt);
      }
      seasonSel.disabled = years.length === 0;
    }

    function populateGPs(year) {
      gpSel.innerHTML = '';
      sessionSel.innerHTML = '';
      if (!byYear.has(year)) { gpSel.disabled = true; sessionSel.disabled = true; return; }
      const rounds = Array.from(byYear.get(year).keys()).sort((a,b) => a - b);
      for (const r of rounds) {
        const meta = byYear.get(year).get(r);
        const label = `Round ${r}. ${meta.race || meta.circuit || 'Grand Prix'}`;
        const opt = document.createElement('option');
        opt.value = String(r); opt.textContent = label;
        gpSel.appendChild(opt);
      }
      gpSel.disabled = rounds.length === 0;
    }

    function populateSessions(year, round) {
      sessionSel.innerHTML = '';
      const meta = byYear.get(year)?.get(Number(round));
      if (!meta) { sessionSel.disabled = true; return; }
      const seen = new Map();
      for (const s of meta.sessions) {
        const key = (s.type || '').toString();
        if (!seen.has(key) && s.filename) seen.set(key, s.filename);
      }
      const entries = Array.from(seen.entries());
      for (const [type, filename] of entries) {
        const opt = document.createElement('option');
        opt.value = type; opt.textContent = prettySession(type);
        opt.dataset.filename = filename;
        sessionSel.appendChild(opt);
      }
      sessionSel.disabled = entries.length === 0;
    }

    async function onSessionChange() {
      const year  = seasonSel.value;
      const round = gpSel.value;
      const opt   = sessionSel.options[sessionSel.selectedIndex];
      if (!opt) return;
      const type  = opt.value;
      const file  = opt.dataset.filename;
      const metaR = byYear.get(year)?.get(Number(round));
      const title = `${year} Round ${round}. ${metaR?.race || metaR?.circuit || ''} (${prettySession(type)})`;
      await loadCsvAndPlot(file, title, year, round, type);
    }

    async function loadManifest() {
      seasonSel.disabled = gpSel.disabled = sessionSel.disabled = true;
      try {
        const text = await fetch('driver_lines_filenames.csv', { cache: 'no-store' }).then(r => r.text());
        const objs = parseCSVToObjects(text);
        manifestItems = objs.filter(o => (o.filename || '').trim().length);
        buildIndex();
        populateSeasons();
        if (seasonSel.options.length) {
          seasonSel.selectedIndex = 0;
          populateGPs(seasonSel.value);
          if (gpSel.options.length) {
            gpSel.selectedIndex = gpSel.options.length - 1; // latest GP
            populateSessions(seasonSel.value, gpSel.value);
            if (sessionSel.options.length) {
              sessionSel.selectedIndex = 0;
              await onSessionChange(); // auto-plot first
            }
          }
        } else {
          if (meta) meta.textContent = 'No entries in driver_lines_filenames.csv';
        }
      } catch (e) {
        console.error(e);
        if (meta) meta.textContent = 'Failed to load driver_lines_filenames.csv';
      } finally {
        seasonSel.disabled = false;
        gpSel.disabled = false;
        sessionSel.disabled = false;
      }
    }

    seasonSel.addEventListener('change', () => {
      populateGPs(seasonSel.value);
      if (gpSel.options.length) gpSel.selectedIndex = 0;
      populateSessions(seasonSel.value, gpSel.value);
      if (sessionSel.options.length) { sessionSel.selectedIndex = 0; onSessionChange(); }
    });
    gpSel.addEventListener('change', () => {
      populateSessions(seasonSel.value, gpSel.value);
      if (sessionSel.options.length) { sessionSel.selectedIndex = 0; onSessionChange(); }
    });
    sessionSel.addEventListener('change', onSessionChange);

    // ---------------- Plotting ----------------
    // Compute checkbox order: finishers by final gap asc, then DNFs by laps desc, then gap on their last lap asc.
    function computeDriverOrder(parsed) {
      const { rows, lapCount } = parsed;
      const entries = rows.map(r => {
        const laps = r.values.length;
        const isFull = laps === lapCount;
        const lastGap = r.values[laps - 1];
        return { name: r.label, isFull, laps, lastGap };
      });
      const finishers = entries.filter(e => e.isFull)
        .sort((a, b) => (b.lastGap - a.lastGap) || a.name.localeCompare(b.name));
      const dnfs = entries.filter(e => !e.isFull)
        .sort((a, b) => (b.laps - a.laps) || (a.lastGap - b.lastGap) || a.name.localeCompare(b.name));
      return [...finishers, ...dnfs].map(e => e.name);
    }

    async function loadCsvAndPlot(path, title, year, round, sessionType) {
      // NEW: keep track of current selection for tooltip lookups
      currentSelection = { year, round, sessionType };

      const csv = await fetch(path, { cache: 'no-store' }).then(r => {
        if (!r.ok) throw new Error(`HTTP ${r.status} for ${path}`);
        return r.text();
      });
      const parsed = parseDriverLines(csv);

      // Save ORIGINAL values for dynamic re-baselining later
      originalValues.clear();
      for (const row of parsed.rows) originalValues.set(row.label, row.values.slice());
      originalLapCount = parsed.lapCount;
      rightXGlobal = parsed.lapCount + 1.2;

      // Order driver checkboxes as requested
      const orderedNames = computeDriverOrder(parsed);

      // Build a per-driver color resolver for the active selection
      const colorLookup = (driver) => getColorFor(year, round, driver, sessionType);
      const option = buildOption(parsed, title, colorLookup);
      chart.setOption(option, true);
      currentSeriesNames = orderedNames;

      // DEFAULT SELECTION: only the top 5 drivers (by finishing order / smallest gap to P1) selected
      const TOP_N = 5;
      const topSet = new Set(orderedNames.slice(0, TOP_N));
      for (const name of orderedNames) {
        chart.dispatchAction({ type: topSet.has(name) ? 'legendSelect' : 'legendUnSelect', name });
      }

      // Build sidebar to reflect the selection state, rebase to selection, and fit axes
      buildDriverList(currentSeriesNames);
      recomputeSeriesRelativeToSelection();
      updateYAxisToVisible();
    }

    // ---------------- Boot ----------------
    chart.setOption({
      backgroundColor: 'transparent',
      title: { text: 'Loading datasetsâ€¦', left: 'center', top: 'center', textStyle: { color: '#6b6f7b', fontWeight: 500 } },
      grid: { left: 56, right: 130, top: 42, bottom: 40 },
      xAxis: { type: 'value', min: 1, max: 10, axisLabel: { color: '#c8c8c8' } },
      yAxis: { type: 'value', min: -100, max: 1, axisLabel: { color: '#c8c8c8' } },
      legend: hiddenLegend
    });

    // Ensure driver info is ready before first plot
    window.addEventListener('DOMContentLoaded', async () => {
      try {
        await loadDriverInfo();   // loads driver_info.csv (colors + names/teams/headshots)
      } catch (e) {
        console.warn('No driver_info.csv or failed to parse; falling back to default labels/colors.', e);
      }
      await loadManifest();        // loads driver_lines_filenames.csv and kicks off first plot
    });
  </script>
  <a class="credit" href="https://docs.fastf1.dev/index.html" target="_blank" rel="noopener">Source Data: FastF1</a>
</body>
</html>
