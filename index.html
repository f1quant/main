<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Race Visualization v2</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>
  <style>
    :root { --bg:#0f1115; --fg:#e8e8e8; --muted:#8b8b8b; --panel:#1a1d24; --border:#232833; --accent:#00e0ff; }
    body { margin:0; font:14px/1.4 system-ui,-apple-system,Segoe UI,Roboto,Helvetica,Arial,sans-serif; color:var(--fg); background:var(--bg); }

    .top-nav {
      background: #0a0c14;
      border-bottom: 1px solid var(--border);
      padding: 0;
      display: flex;
      justify-content: flex-start;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .top-nav a {
      color: var(--muted);
      text-decoration: none;
      padding: 12px 24px;
      font-size: 13px;
      font-weight: 500;
      transition: all 0.18s ease-out;
      border-bottom: 2px solid transparent;
    }

    .top-nav a:hover {
      color: var(--fg);
      background: rgba(0, 224, 255, 0.05);
    }

    .top-nav a.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    header { padding:10px 14px; background:var(--panel); display:flex; gap:12px; align-items:center; flex-wrap:wrap; border-bottom:1px solid var(--border); }
    .title { font-weight:600; margin-right:auto; }
    label.small { color:var(--muted); font-size:12px; }
    select { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; min-width: 160px; }
    select:disabled { opacity: 0.5; cursor: not-allowed; }
    .small { color:var(--muted); font-size:12px; }
    .layout { display:grid; grid-template-columns: 280px 1fr; min-height: calc(100vh - 56px - 45px); }
    #sidebar { background:var(--panel); border-right:1px solid var(--border); display:flex; flex-direction:column; }
    #sidebar .section { padding:12px; border-bottom:1px solid var(--border); }
    #driverList { padding:10px; overflow:auto; }
    .driver { display:flex; align-items:center; gap:8px; padding:4px 2px; border-radius:6px; }
    .driver:hover { background:#141820; }
    #chart { width:100%; height:100%; }
    .buttons { display:flex; gap:8px; flex-wrap:wrap; margin-top:6px; }
    .buttons button { background:#11141a; color:var(--fg); border:1px solid #2a2f3a; padding:6px 8px; border-radius:8px; cursor:pointer; }
    .hint { color:var(--muted); font-size:12px; margin-top:6px; }
    .credit { position:fixed; left:12px; bottom:10px; z-index:9999; font-size:12px; color:var(--muted); text-decoration:none; opacity:0.9; }
    .credit:hover { text-decoration:underline; opacity:1; }

    input[type="number"]{
      background:#11141a; color:var(--fg);
      border:1px solid #2a2f3a; padding:6px 8px;
      border-radius:8px; width:90px;
    }

    .status-message {
      color: var(--muted);
      font-size: 12px;
      margin-left: auto;
    }

    .debug-info {
      padding: 20px;
      color: var(--fg);
      font-size: 14px;
    }

    input[type="checkbox"] { cursor:pointer; }
    .driver label { cursor:pointer; user-select:none; }
  </style>
</head>
<body>
  <nav class="top-nav">
    <a href="show_strategy.html">Strategy Chart</a>
    <a href="index.html" class="active">Gaps</a>
    <a href="stints.html">Stints</a>
    <a href="strat_calc.html">Strategy Calculator</a>
  </nav>
  <header>
    <label class="small" for="seasonSel">Season</label>
    <select id="seasonSel" title="Season">
      <option value=""></option>
    </select>
    <label class="small" for="gpSel">GP</label>
    <select id="gpSel" title="Grand Prix" disabled>
      <option value=""></option>
    </select>
    <label class="small" for="sessionSel">Session</label>
    <select id="sessionSel" title="Session type" disabled>
      <option value=""></option>
    </select>
    <label class="small" for="lapMin">Lap min</label>
    <input id="lapMin" type="number" min="1" step="1" value="1" title="Min lap" />
    <label class="small" for="lapMax">Lap max</label>
    <input id="lapMax" type="number" min="1" step="1" value="1" title="Max lap" />
    <span class="status-message" id="statusMessage">Loading...</span>
  </header>

  <div class="layout">
    <aside id="sidebar">
      <div class="section">
        <div class="buttons">
          <button id="btnAll"  type="button">Select all</button>
          <button id="btnNone" type="button">Clear all</button>
        </div>
      </div>
      <div id="driverList" aria-label="Driver list"></div>
    </aside>
    <main id="chart">
      <div class="debug-info" id="debugInfo">
        Waiting for data...
      </div>
    </main>
  </div>

  <!-- Papa Parse from CDN -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <script>
    const seasonSel = document.getElementById("seasonSel");
    const gpSel = document.getElementById("gpSel");
    const sessionSel = document.getElementById("sessionSel");
    const lapMin = document.getElementById("lapMin");
    const lapMax = document.getElementById("lapMax");
    const statusMessage = document.getElementById("statusMessage");
    const debugInfo = document.getElementById("debugInfo");
    const driverList = document.getElementById("driverList");
    const btnAll = document.getElementById("btnAll");
    const btnNone = document.getElementById("btnNone");

    let allRows = [];
    let sessionsByKey = new Map();
    let driverLines = {}; // {driver: {laps: [lap#], gaps: [gap in seconds]}}
    let selectedDrivers = new Set();
    let myChart = null;
    let driverInfoBySession = new Map(); // key: "year|round|session" -> Map(driver -> {fullName, color, teamName})

    init();

    function init() {
      loadDriverInfo();
      setupEventListeners();
    }

    function setupEventListeners() {
      btnAll.addEventListener("click", () => {
        selectedDrivers = new Set(Object.keys(driverLines));
        updateDriverCheckboxes();
        renderChart();
      });

      btnNone.addEventListener("click", () => {
        selectedDrivers.clear();
        updateDriverCheckboxes();
        renderChart();
      });

      lapMin.addEventListener("change", renderChart);
      lapMax.addEventListener("change", renderChart);
    }

    function getDriverInfo(driver) {
      // Get driver info for current session
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) {
        return { fullName: driver, color: '#888888', teamName: '', headshotUrl: '' };
      }

      const [round] = selectedGP.split('||');
      const sessionUpper = selectedSession.toUpperCase();

      // Try session-specific key first
      const kSess = `${selectedSeason}|${round}|${sessionUpper}`;
      if (driverInfoBySession.has(kSess)) {
        const sessMap = driverInfoBySession.get(kSess);
        if (sessMap.has(driver)) {
          const info = sessMap.get(driver);
          return {
            fullName: info.fullName || driver,
            color: info.color || '#888888',
            teamName: info.teamName || '',
            headshotUrl: info.headshotUrl || ''
          };
        }
      }

      // Fall back to base key (year|round)
      const kBase = `${selectedSeason}|${round}`;
      if (driverInfoBySession.has(kBase)) {
        const baseMap = driverInfoBySession.get(kBase);
        if (baseMap.has(driver)) {
          const info = baseMap.get(driver);
          return {
            fullName: info.fullName || driver,
            color: info.color || '#888888',
            teamName: info.teamName || '',
            headshotUrl: info.headshotUrl || ''
          };
        }
      }

      // Final fallback
      return { fullName: driver, color: '#888888', teamName: '', headshotUrl: '' };
    }

    function loadDriverInfo() {
      Papa.parse(DataCache.getCSVUrl("driver_info.csv"), {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.data) {
            driverInfoBySession.clear();

            results.data.forEach(row => {
              const year = String(row.year || "").trim();
              const round = parseInt(row.round_no, 10);
              const driver = String(row.driver || "").trim();
              const session = String(row.session_type || "").trim().toUpperCase();
              const colorRaw = String(row.color || "").trim();
              const colorOk = /^#?[0-9a-f]{6}$/i.test(colorRaw.replace('#',''));
              const color = colorOk ? (colorRaw.startsWith('#') ? colorRaw : ('#' + colorRaw)) : null;
              const teamName = String(row.TeamName || "").trim();
              const fullName = String(row.FullName || "").trim();
              const headshotUrl = String(row.HeadshotUrl || "").trim();

              if (!year || !Number.isFinite(round) || !driver) return;

              // Store by base key (year|round)
              const kBase = `${year}|${round}`;
              if (!driverInfoBySession.has(kBase)) {
                driverInfoBySession.set(kBase, new Map());
              }
              const baseMap = driverInfoBySession.get(kBase);
              const existing = baseMap.get(driver) || {};
              baseMap.set(driver, {
                color: color ?? existing.color ?? null,
                fullName: fullName || existing.fullName || '',
                teamName: teamName || existing.teamName || '',
                headshotUrl: headshotUrl || existing.headshotUrl || ''
              });

              // Also store by session-specific key (year|round|session)
              if (session) {
                const kSess = `${kBase}|${session}`;
                if (!driverInfoBySession.has(kSess)) {
                  driverInfoBySession.set(kSess, new Map());
                }
                const sessMap = driverInfoBySession.get(kSess);
                const ex2 = sessMap.get(driver) || {};
                sessMap.set(driver, {
                  color: color ?? ex2.color ?? null,
                  fullName: fullName || ex2.fullName || '',
                  teamName: teamName || ex2.teamName || '',
                  headshotUrl: headshotUrl || ex2.headshotUrl || ''
                });
              }
            });
          }
          // After driver info is loaded, load CSV
          loadCSV();
        },
        error: function (err) {
          console.error("Error loading driver_info.csv:", err);
          // Continue anyway
          loadCSV();
        }
      });
    }

    function loadCSV() {
      Papa.parse(DataCache.getCSVUrl("all_df.csv"), {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRows = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.session_type !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRows.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          indexSessions(allRows);
          buildSeasonDropdown();
          statusMessage.textContent = `${allRows.length} laps loaded`;
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      seasonSel.addEventListener("change", onSeasonChange);
      gpSel.addEventListener("change", onGPChange);
      sessionSel.addEventListener("change", onSessionChange);
    }

    function indexSessions(rows) {
      sessionsByKey.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const session = String(r.session_type || "").trim();

        if (!year || !round || !meeting || !session) return;

        const key = `${year}||${round}||${meeting}||${session}`;
        if (!sessionsByKey.has(key)) {
          sessionsByKey.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            session_type: session
          });
        }
      });
    }

    function buildSeasonDropdown() {
      const seasons = new Set();
      sessionsByKey.forEach(val => {
        seasons.add(val.year);
      });

      const sortedSeasons = Array.from(seasons).sort((a, b) => {
        const ya = parseInt(a, 10) || 0;
        const yb = parseInt(b, 10) || 0;
        return yb - ya; // Descending order
      });

      sortedSeasons.forEach(year => {
        const opt = document.createElement("option");
        opt.value = year;
        opt.textContent = year;
        seasonSel.appendChild(opt);
      });

      // Select most recent season by default
      if (sortedSeasons.length > 0) {
        seasonSel.value = sortedSeasons[0];
        onSeasonChange();
      }
    }

    function onSeasonChange() {
      const selectedSeason = seasonSel.value;
      gpSel.innerHTML = '<option value=""></option>';
      sessionSel.innerHTML = '<option value=""></option>';
      gpSel.disabled = true;
      sessionSel.disabled = true;
      debugInfo.textContent = "Select a GP";

      if (!selectedSeason) return;

      const gps = new Map();
      sessionsByKey.forEach((val, key) => {
        if (val.year === selectedSeason) {
          const gpKey = `${val.round_no}||${val.meeting_name}`;
          if (!gps.has(gpKey)) {
            gps.set(gpKey, {
              round_no: val.round_no,
              meeting_name: val.meeting_name
            });
          }
        }
      });

      const sortedGPs = Array.from(gps.values()).sort((a, b) => {
        const ra = parseInt(a.round_no, 10) || 0;
        const rb = parseInt(b.round_no, 10) || 0;
        return ra - rb; // Ascending order
      });

      sortedGPs.forEach(gp => {
        const opt = document.createElement("option");
        opt.value = `${gp.round_no}||${gp.meeting_name}`;
        opt.textContent = `${gp.round_no}. ${gp.meeting_name}`;
        gpSel.appendChild(opt);
      });

      gpSel.disabled = false;

      // Select last GP by default
      if (sortedGPs.length > 0) {
        const lastGP = sortedGPs[sortedGPs.length - 1];
        gpSel.value = `${lastGP.round_no}||${lastGP.meeting_name}`;
        onGPChange();
      }
    }

    function onGPChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      sessionSel.innerHTML = '<option value=""></option>';
      sessionSel.disabled = true;
      debugInfo.textContent = "Select a session";

      if (!selectedGP) return;

      const [round, meeting] = selectedGP.split('||');

      const sessions = [];
      sessionsByKey.forEach((val, key) => {
        if (val.year === selectedSeason && val.round_no === round && val.meeting_name === meeting) {
          sessions.push(val.session_type);
        }
      });

      const uniqueSessions = [...new Set(sessions)];
      uniqueSessions.forEach(session => {
        const opt = document.createElement("option");
        opt.value = session;
        opt.textContent = session;
        sessionSel.appendChild(opt);
      });

      sessionSel.disabled = false;

      // Select R by default if available, otherwise first session
      if (uniqueSessions.includes('R')) {
        sessionSel.value = 'R';
        onSessionChange();
      } else if (uniqueSessions.length > 0) {
        sessionSel.value = uniqueSessions[0];
        onSessionChange();
      }
    }

    function onSessionChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) {
        debugInfo.textContent = "Select season, GP, and session";
        return;
      }

      const [round, meeting] = selectedGP.split('||');

      // Filter rows for this session
      const sessionRows = allRows.filter(r => {
        return String(r.year || "").trim() === selectedSeason &&
               String(r.round_no || "").trim() === round &&
               String(r.meeting_name || "").trim() === meeting &&
               String(r.session_type || "").trim() === selectedSession;
      });

      if (sessionRows.length === 0) {
        debugInfo.textContent = "No data for this session";
        return;
      }

      // Update lap min/max based on data
      const lapNumbers = sessionRows.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n));
      const minLapNum = Math.min(...lapNumbers);
      const maxLapNum = Math.max(...lapNumbers);

      lapMin.value = minLapNum;
      lapMax.value = maxLapNum;
      lapMin.min = minLapNum;
      lapMax.max = maxLapNum;

      // Clear selected drivers for new session
      selectedDrivers.clear();

      // Calculate gaps
      calculateGaps(sessionRows);

      // Build driver list
      buildDriverList();

      // Render chart
      renderChart();

      statusMessage.textContent = `${sessionRows.length} rows loaded`;
    }

    function calculateGaps(rows) {
      // Group rows by lap number
      const lapData = new Map(); // lap# -> array of {driver, position, time}

      rows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        const driver = String(r.lap_Driver || "").trim();
        const position = parseInt(r.lap_Position);
        const lapTime = parseFloat(r.lap_Time);

        if (isNaN(lapNum) || !driver || isNaN(lapTime) || isNaN(position)) return;

        if (!lapData.has(lapNum)) {
          lapData.set(lapNum, []);
        }

        lapData.get(lapNum).push({
          driver,
          position,
          lapTime
        });
      });

      // For each lap, calculate gaps
      driverLines = {};

      lapData.forEach((driversInLap, lapNum) => {
        // Sort by position (lower is better)
        driversInLap.sort((a, b) => a.position - b.position);

        // Find minimum lap time (P1 driver)
        const minTime = Math.min(...driversInLap.map(d => d.lapTime));

        // Calculate gap for each driver (minTime - driverTime, so gaps are negative)
        driversInLap.forEach(d => {
          const gap = minTime - d.lapTime;

          if (!driverLines[d.driver]) {
            driverLines[d.driver] = {
              laps: [],
              gaps: [],
              positions: []
            };
          }

          driverLines[d.driver].laps.push(lapNum);
          driverLines[d.driver].gaps.push(gap);
          driverLines[d.driver].positions.push(d.position);
        });
      });

      // Don't auto-select here - will be done in buildDriverList based on finishing position
    }

    function buildDriverList() {
      driverList.innerHTML = '';

      // Sort drivers by finishing position
      const drivers = Object.keys(driverLines);

      // Calculate finishing position for each driver
      const driverFinishInfo = drivers.map(driver => {
        const data = driverLines[driver];
        const maxLapNum = Math.max(...data.laps);
        const lastLapIndex = data.laps.indexOf(maxLapNum);
        const lastPosition = data.positions[lastLapIndex];

        return {
          driver: driver,
          maxLapNum: maxLapNum,
          lastPosition: lastPosition
        };
      });

      // Sort by finishing position:
      // 1. More laps completed = better (descending)
      // 2. If same laps, use lap_Position (lower is better)
      driverFinishInfo.sort((a, b) => {
        if (a.maxLapNum !== b.maxLapNum) {
          return b.maxLapNum - a.maxLapNum; // More laps = finished higher
        }
        return a.lastPosition - b.lastPosition; // Lower position number = better
      });

      // Auto-select top 5 drivers if this is a new session (selectedDrivers is empty)
      const isNewSession = selectedDrivers.size === 0;
      if (isNewSession) {
        selectedDrivers.clear();
        driverFinishInfo.slice(0, 5).forEach(({ driver }) => {
          selectedDrivers.add(driver);
        });
      }

      // Build the list in finishing order
      driverFinishInfo.forEach(({ driver }) => {
        const div = document.createElement('div');
        div.className = 'driver';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `driver-${driver}`;
        checkbox.checked = selectedDrivers.has(driver);
        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedDrivers.add(driver);
          } else {
            selectedDrivers.delete(driver);
          }
          renderChart();
        });

        const label = document.createElement('label');
        label.htmlFor = `driver-${driver}`;

        // Format: "Full Name (ABB)"
        const info = getDriverInfo(driver);
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        label.textContent = displayName;

        // Set label color
        label.style.color = info.color;

        div.appendChild(checkbox);
        div.appendChild(label);
        driverList.appendChild(div);
      });
    }

    function updateDriverCheckboxes() {
      Object.keys(driverLines).forEach(driver => {
        const checkbox = document.getElementById(`driver-${driver}`);
        if (checkbox) {
          checkbox.checked = selectedDrivers.has(driver);
        }
      });
    }

    function renderChart() {
      if (Object.keys(driverLines).length === 0) return;

      const chartContainer = document.getElementById('chart');

      // Remove debug info if it exists
      const debugDiv = document.getElementById('debugInfo');
      if (debugDiv) {
        debugDiv.remove();
      }

      // Initialize chart if needed
      if (!myChart) {
        myChart = echarts.init(chartContainer);
      }

      const minLap = parseInt(lapMin.value);
      const maxLap = parseInt(lapMax.value);

      // Calculate rightX for anchor point (similar to gaps.html)
      const lapCount = Object.keys(driverLines).length > 0
        ? Math.max(...Object.values(driverLines).map(d => Math.max(...d.laps)))
        : maxLap;
      const rightX = (maxLap === lapCount) ? (maxLap + 0.5) : (maxLap + 0.1);

      // First pass: collect all raw gaps for selected drivers by lap
      const gapsByLap = new Map(); // lap# -> array of gaps from selected drivers

      selectedDrivers.forEach(driver => {
        const data = driverLines[driver];
        if (!data) return;

        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            if (!gapsByLap.has(lap)) {
              gapsByLap.set(lap, []);
            }
            gapsByLap.get(lap).push(data.gaps[i]);
          }
        }
      });

      // Calculate max gap for each lap (among selected drivers only)
      const maxGapByLap = new Map();
      gapsByLap.forEach((gaps, lap) => {
        maxGapByLap.set(lap, Math.max(...gaps));
      });

      // Prepare series data
      const series = [];

      selectedDrivers.forEach(driver => {
        const data = driverLines[driver];
        if (!data) return;

        // Filter by lap range and adjust gaps
        const points = [];
        let lastGap = null;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            const rawGap = data.gaps[i];
            const maxGap = maxGapByLap.get(lap) || 0;
            const adjustedGap = rawGap - maxGap;
            points.push([lap, adjustedGap]);
            lastGap = adjustedGap;
          }
        }

        if (points.length > 0) {
          const info = getDriverInfo(driver);

          // Check if driver completed all laps in range
          const completedAllLaps = data.laps.some(lap => lap === maxLap);

          // Add anchor point for label positioning (like gaps.html)
          if (completedAllLaps && lastGap !== null) {
            points.push({
              value: [rightX, lastGap],
              tooltip: { show: false },
              emphasis: { disabled: true }
            });
          }

          series.push({
            name: driver,
            type: 'line',
            data: points,
            step: 'end',
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: {
              width: 2,
              color: info.color
            },
            itemStyle: {
              color: info.color,
              borderWidth: 0
            },
            emphasis: {
              focus: 'series',
              blurScope: 'global',
              lineStyle: { width: 3.5 }
            },
            blur: {
              lineStyle: { opacity: 0.15 }
            },
            endLabel: {
              show: completedAllLaps,
              formatter: '{a}',
              position: 'right',
              offset: [6, 0],
              color: info.color
            },
            animation: false
          });
        }
      });

      const option = {
        backgroundColor: 'transparent',
        grid: {
          left: 60,
          right: 120,
          top: 20,
          bottom: 60
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          appendToBody: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const v = Array.isArray(p.value) ? p.value : p.data?.value || p.data;
            const lap = Array.isArray(v) ? v[0] : v?.[0];
            const gap = Array.isArray(v) ? v[1] : v?.[1];
            const code = p.seriesName;
            const info = getDriverInfo(code);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || code;
              const teamName = info.teamName || '';
              const gapLine = (typeof lap === 'number' && typeof gap === 'number')
                ? `<div style="margin-top:4px">Lap ${lap}: ${gap.toFixed(3)} s</div>`
                : '';
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${code})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${gapLine}
                  </div>
                </div>
              `;
            }

            if (typeof lap === 'number' && typeof gap === 'number') {
              return `${p.marker}<b>${code}</b><br/>Lap ${lap}: ${gap.toFixed(3)} s`;
            }
            return `${p.marker}<b>${code}</b>`;
          }
        },
        legend: {
          show: false
        },
        xAxis: {
          type: 'value',
          name: 'Lap',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#8b8b8b', fontSize: 12 },
          axisLine: { lineStyle: { color: '#2a2f3a' } },
          axisLabel: { color: '#8b8b8b' },
          splitLine: { lineStyle: { color: '#232833' } },
          min: minLap,
          max: rightX
        },
        yAxis: {
          type: 'value',
          name: 'Gap (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#8b8b8b', fontSize: 12 },
          axisLine: { lineStyle: { color: '#2a2f3a' } },
          axisLabel: { color: '#8b8b8b' },
          splitLine: { lineStyle: { color: '#232833' } }
        },
        series: series
      };

      myChart.setOption(option, true);
    }
  </script>
</body>
</html>
