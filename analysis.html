<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>F1 Race Analysis</title>
  <link rel="stylesheet" href="common.css">
  <style>
    /* Page-specific styles */
    .page-content {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 16px 16px;
    }

    .container {
      max-width: 1400px;
      width: 100%;
    }

    /* Tab Navigation */
    .tab-navigation {
      display: flex;
      gap: 0;
      margin-bottom: 16px;
      border-bottom: 2px solid var(--border-color);
      align-items: center;
    }

    .tab-button {
      padding: 12px 24px;
      background: transparent;
      border: none;
      border-bottom: 3px solid transparent;
      color: var(--muted-color);
      font-size: 14px;
      font-weight: 600;
      cursor: pointer;
      transition: all 0.2s ease;
      margin-bottom: -2px;
    }

    .tab-button:hover {
      color: var(--text-color);
      background: rgba(255, 255, 255, 0.03);
    }

    .tab-button.active {
      color: var(--primary-color);
      border-bottom-color: var(--primary-color);
    }

    .tab-navigation .status-message {
      margin-left: auto;
      font-size: 12px;
      color: var(--muted-color);
      padding: 0 12px;
    }

    .tab-navigation #reloadDataBtn {
      margin-bottom: -2px;
      padding: 8px 16px;
      font-size: 12px;
    }

    /* Session Selector */
    .session-selector {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 16px;
      margin-bottom: 16px;
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 8px;
      border: 1px solid var(--border-color);
    }

    .small {
      color: var(--muted-color);
      font-size: 12px;
    }

    select {
      min-width: 160px;
      width: auto;
    }

    #sessionSel {
      min-width: 120px;
    }

    /* Content Panels */
    .content-panel {
      display: none;
    }

    .content-panel.active {
      display: block;
    }

    /* ========================================================================
       STRATEGY PANEL STYLES
       ======================================================================== */

    #strategy-panel {
      display: flex;
      justify-content: center;
    }

    .strategy-container {
      max-width: 900px;
      width: 100%;
      margin-top: 20px;
      padding: 20px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      display: none;
    }

    .strategy-container.show {
      display: block;
    }

    .driver-row {
      display: flex;
      align-items: center;
      margin-bottom: 8px;
      position: relative;
    }

    .driver-label {
      width: 80px;
      font-size: 12px;
      font-weight: 600;
      color: var(--text-color);
      text-align: right;
      padding-right: 12px;
      flex-shrink: 0;
    }

    .strategy-bar {
      flex: 1;
      height: 24px;
      display: flex;
      position: relative;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 4px;
      overflow: hidden;
    }

    .stint-segment {
      height: 100%;
      position: relative;
      border-right: 3px solid #000;
      box-shadow: 2px 0 0 rgba(0, 0, 0, 0.8);
    }

    .stint-segment:last-child {
      border-right: none;
      box-shadow: none;
    }

    .missing-laps {
      height: 100%;
      background: repeating-linear-gradient(
        45deg,
        #333,
        #333 4px,
        #222 4px,
        #222 8px
      );
      opacity: 0.5;
    }

    .lap-axis {
      display: flex;
      align-items: center;
      position: relative;
    }

    .lap-axis.top {
      margin-bottom: 8px;
    }

    .lap-axis.bottom {
      margin-top: 16px;
    }

    .lap-axis-spacer {
      width: 80px;
      flex-shrink: 0;
    }

    .lap-axis-track {
      flex: 1;
      height: 30px;
      position: relative;
      border-top: 1px solid var(--border-color);
    }

    .lap-axis.bottom .lap-axis-track {
      border-top: 1px solid var(--border-color);
      border-bottom: none;
    }

    .lap-axis.top .lap-axis-track {
      border-top: none;
      border-bottom: 1px solid var(--border-color);
    }

    .lap-tick {
      position: absolute;
      width: 1px;
      background: var(--muted-color);
    }

    .lap-axis.bottom .lap-tick {
      top: 0;
      height: 8px;
    }

    .lap-axis.top .lap-tick {
      bottom: 0;
      height: 8px;
    }

    .lap-label {
      position: absolute;
      font-size: 10px;
      color: var(--muted-color);
      transform: translateX(-50%);
    }

    .lap-axis.bottom .lap-label {
      top: 10px;
    }

    .lap-axis.top .lap-label {
      bottom: 10px;
    }

    .tooltip {
      position: absolute;
      background: rgba(26, 29, 36, 0.96);
      border: 1px solid var(--accent-color);
      border-radius: 8px;
      padding: 8px 12px;
      font-size: 11px;
      color: var(--text-color);
      pointer-events: none;
      z-index: 1000;
      display: none;
      white-space: nowrap;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    }

    .tooltip.show {
      display: block;
    }

    /* Hide the common.js navigation since we have our own tabs */
    nav {
      display: none !important;
    }

    /* ========================================================================
       RACE TRACE PANEL STYLES
       ======================================================================== */

    .race-trace-controls {
      padding: 12px 16px;
      background: rgba(255, 255, 255, 0.02);
      border-radius: 6px;
      border: 1px solid var(--border-color);
      display: flex;
      gap: 12px;
      align-items: center;
      margin-bottom: 16px;
    }

    .race-trace-controls-row {
      display: flex;
      gap: 12px;
      margin-bottom: 16px;
      align-items: center;
    }

    .race-trace-controls-box {
      display: flex;
      gap: 8px;
      padding: 10px 14px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      align-items: center;
    }

    .race-trace-controls input[type="number"] {
      width: 90px;
    }

    .race-trace-controls-box input[type="number"] {
      width: 90px;
    }

    .race-trace-layout {
      display: grid;
      grid-template-columns: 280px 1fr;
      min-height: 600px;
      border: 1px solid var(--border-color);
      border-radius: 8px;
      overflow: hidden;
    }

    .race-trace-sidebar {
      background: rgba(0, 224, 255, 0.03);
      border-right: 1px solid var(--border-color);
      display: flex;
      flex-direction: column;
    }

    .race-trace-sidebar .section {
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
    }

    .race-trace-sidebar .buttons {
      display: flex;
      gap: 8px;
      flex-wrap: wrap;
    }

    #raceTraceDriverList {
      padding: 10px;
      overflow: auto;
    }

    .race-trace-driver {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.2s;
    }

    .race-trace-driver:hover {
      background: rgba(0, 224, 255, 0.1);
    }

    .race-trace-driver input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .race-trace-driver label {
      cursor: pointer;
      flex: 1;
    }

    #raceTraceChart {
      width: 100%;
      height: 100%;
      min-height: 600px;
    }

    .race-trace-debug-info {
      padding: 20px;
      color: var(--text-color);
      font-size: 14px;
    }

    /* ========================================================================
       LAP TIME PANEL STYLES
       ======================================================================== */

    .lap-time-layout {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
    }

    .lap-time-sidebar {
      width: 200px;
      padding: 12px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      max-height: 610px;
      overflow-y: auto;
    }

    .lap-time-chart-wrapper {
      flex: 1;
    }

    .lap-time-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .toggle-button {
      padding: 4px 12px;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .toggle-button.active {
      background: var(--accent-color);
      color: #000;
      border-color: var(--accent-color);
    }

    .toggle-button:hover {
      border-color: var(--accent-color);
    }

    #lapTimeChart {
      width: 100%;
      height: 610px;
    }

    .lap-time-filters {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
    }

    .filter-panel {
      padding: 16px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .filters-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .drivers-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .filters-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .filter-item {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .filter-item.vertical {
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
    }

    .filter-label {
      font-size: 10px;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    .filter-item input[type="number"] {
      width: 100px;
    }

    .exclude-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .checkbox-group label {
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
    }

    .lap-time-driver-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.2s;
    }

    .lap-time-driver-item:hover {
      background: rgba(0, 224, 255, 0.1);
    }

    .lap-time-driver-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .lap-time-driver-item label {
      cursor: pointer;
      flex: 1;
    }

    /* ========================================================================
       TYRE DEGRADATION PANEL STYLES
       ======================================================================== */

    .tyre-choices-display {
      display: flex;
      align-items: center;
      gap: 8px;
      margin-bottom: 16px;
      padding: 10px 14px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      font-size: 14px;
    }

    .tyre-choices-label {
      font-weight: 600;
      color: var(--accent-color);
      font-size: 11px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #tyreDegTyreChoicesText {
      color: var(--text-color);
      font-size: 12px;
    }

    .tyre-deg-charts-wrapper {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .tyre-deg-chart-container {
      padding: 20px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .chart-title {
      font-size: 12px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    #tyreDegScatterChart, #tyreDegLapTimeChart {
      width: 100%;
      height: 400px;
    }

    .tyre-deg-chart-controls {
      margin-bottom: 8px;
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .equations-section {
      margin-top: 12px;
      padding: 12px 16px;
      background: rgba(0, 224, 255, 0.05);
      border-radius: 12px;
      border: 1px solid rgba(148, 163, 253, 0.15);
    }

    .equations-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .equations-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
      gap: 8px;
    }

    .equation-item {
      font-size: 11px;
      color: var(--text-color);
      font-family: 'Courier New', monospace;
      padding: 4px 8px;
      background: rgba(0, 0, 0, 0.3);
      border-radius: 6px;
      border-left: 3px solid;
    }

    .tyre-deg-filters {
      display: grid;
      grid-template-columns: 1.5fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .slider-container {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .slider-value {
      font-size: 11px;
      color: var(--accent-color);
      font-weight: 600;
    }

    input[type="range"] {
      width: 100%;
      height: 6px;
      border-radius: 3px;
      background: var(--border-color);
      outline: none;
      -webkit-appearance: none;
    }

    input[type="range"]::-webkit-slider-thumb {
      -webkit-appearance: none;
      appearance: none;
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      box-shadow: 0 0 8px var(--accent-soft);
    }

    input[type="range"]::-moz-range-thumb {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      background: var(--accent-color);
      cursor: pointer;
      border: none;
      box-shadow: 0 0 8px var(--accent-soft);
    }

    .stint-checkbox {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    #tyreDegStintsTable {
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
      margin-top: 16px;
    }

    #tyreDegStintsTable th {
      background: rgba(0, 224, 255, 0.1);
      color: var(--accent-color);
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 10px;
      border: 1px solid var(--border-color);
      cursor: pointer;
      user-select: none;
    }

    #tyreDegStintsTable th:hover {
      color: #fff;
    }

    #tyreDegStintsTable td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    #tyreDegStintsTable tr:hover {
      background: rgba(0, 224, 255, 0.05);
    }

    .stint-selected {
      background: rgba(0, 224, 255, 0.15) !important;
    }

    .clickable-header {
      cursor: pointer;
      user-select: none;
      position: relative;
    }

    .clickable-header::after {
      content: " ▾";
      font-size: 10px;
      opacity: 0.6;
    }

    .header-dropdown {
      position: absolute;
      background: #0a0c14;
      border: 1px solid var(--accent-color);
      border-radius: 8px;
      padding: 8px;
      min-width: 200px;
      max-height: 300px;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.8), 0 0 16px var(--accent-soft);
      z-index: 1000;
      display: none;
    }

    #tyreDegStintsTable {
      position: relative;
    }

    .header-dropdown.show {
      display: block;
    }

    .dropdown-option {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 6px 8px;
      font-size: 11px;
      color: var(--text-color);
      border-bottom: 1px solid rgba(148, 163, 253, 0.1);
    }

    .dropdown-option:last-child {
      border-bottom: none;
    }

    .dropdown-option-label {
      flex: 1;
    }

    .dropdown-option-buttons {
      display: flex;
      gap: 4px;
    }

    .dropdown-btn {
      padding: 2px 8px;
      font-size: 9px;
      border-radius: 4px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .dropdown-btn:hover {
      border-color: var(--accent-color);
      background: rgba(0, 224, 255, 0.15);
    }
  </style>
</head>
<body>
  <div class="page-content">
  <div class="container">
    <!-- Tab Navigation -->
    <div class="tab-navigation">
      <button class="tab-button active" data-tab="strategy">Strategy</button>
      <button class="tab-button" data-tab="race-trace">Race Trace</button>
      <button class="tab-button" data-tab="lap-time">Lap Time</button>
      <button class="tab-button" data-tab="tyre-deg">Tyre Degradation</button>
      <button class="tab-button" data-tab="fuel-effect">Fuel Effect</button>
      <span class="status-message" id="statusMessage">Loading...</span>
      <button id="reloadDataBtn" type="button" title="Reload data from server">Reload Data</button>
    </div>

    <!-- Session Selector (shared across all tabs) -->
    <div class="session-selector">
      <label class="small" for="seasonSel">Season</label>
      <select id="seasonSel" title="Season">
        <option value=""></option>
      </select>
      <label class="small" for="gpSel">GP</label>
      <select id="gpSel" title="Grand Prix" disabled>
        <option value=""></option>
      </select>
      <label class="small" for="sessionSel">Session</label>
      <select id="sessionSel" title="Session type" disabled>
        <option value=""></option>
      </select>
    </div>

    <!-- Strategy Panel -->
    <div id="strategy-panel" class="content-panel active">
      <div id="strategyContainer" class="strategy-container">
        <div class="lap-axis top">
          <div class="lap-axis-spacer"></div>
          <div class="lap-axis-track" id="lapAxisTop"></div>
        </div>
        <div id="strategyChart"></div>
        <div class="lap-axis bottom">
          <div class="lap-axis-spacer"></div>
          <div class="lap-axis-track" id="lapAxisBottom"></div>
        </div>
      </div>
    </div>

    <!-- Race Trace Panel -->
    <div id="race-trace-panel" class="content-panel">
      <div class="race-trace-controls-row">
        <div class="race-trace-controls-box">
          <button id="raceTraceBtnAll" type="button">Select all</button>
          <button id="raceTraceBtnNone" type="button">Clear all</button>
        </div>
        <div class="race-trace-controls-box">
          <label class="small" for="raceTraceLapMin">Lap min</label>
          <input id="raceTraceLapMin" type="number" min="1" step="1" value="1" title="Min lap" />
          <label class="small" for="raceTraceLapMax">Lap max</label>
          <input id="raceTraceLapMax" type="number" min="1" step="1" value="1" title="Max lap" />
        </div>
      </div>

      <div class="race-trace-layout">
        <aside class="race-trace-sidebar">
          <div id="raceTraceDriverList" aria-label="Driver list"></div>
        </aside>
        <main id="raceTraceChart">
          <div class="race-trace-debug-info" id="raceTraceDebugInfo">
            Waiting for data...
          </div>
        </main>
      </div>
    </div>

    <!-- Lap Time Panel -->
    <div id="lap-time-panel" class="content-panel">
      <div class="lap-time-layout">
        <div class="lap-time-sidebar">
          <div id="lapTimeDriversList"></div>
        </div>
        <div class="lap-time-chart-wrapper">
          <div class="lap-time-controls">
            <button id="fuelAdjustToggle" class="toggle-button">Fuel Adjusted</button>
            <button id="tyreLifeAdjustToggle" class="toggle-button">Tyre Life Adjusted</button>
          </div>
          <div id="lapTimeChart"></div>
        </div>
      </div>

      <div class="lap-time-filters">
        <div class="filter-panel">
          <div class="filters-title">Adjustments</div>
          <div class="filters-grid">
            <div class="filter-item">
              <div class="filter-label">Hard Deg (sec/lap)</div>
              <input type="number" id="degHard" value="0.05" min="0" step="0.01">
            </div>
            <div class="filter-item">
              <div class="filter-label">Medium Deg (sec/lap)</div>
              <input type="number" id="degMedium" value="0.08" min="0" step="0.01">
            </div>
            <div class="filter-item">
              <div class="filter-label">Soft Deg (sec/lap)</div>
              <input type="number" id="degSoft" value="0.12" min="0" step="0.01">
            </div>
            <div class="filter-item">
              <div class="filter-label">Fuel Effect (sec/lap)</div>
              <input type="number" id="fuelEffect" value="0.03" min="0" step="0.01">
            </div>
          </div>
        </div>

        <div class="filter-panel">
          <div class="filters-title">Lap Filters</div>
          <div class="filters-grid">
            <div class="filter-item">
              <div class="filter-label">Laps to Discard at Start</div>
              <input type="number" id="filterMinLap" value="2" min="0">
            </div>
            <div class="filter-item">
              <div class="filter-label">Laps to Discard at End</div>
              <input type="number" id="filterEndLaps" value="0" min="0">
            </div>
            <div class="filter-item">
              <div class="filter-label">Min Distance to Car Ahead</div>
              <input type="number" id="filterMinDist" value="0" min="0" step="0.1">
            </div>
          </div>
        </div>

        <div class="filter-panel">
          <div class="filters-title">Include</div>
          <div class="exclude-checkboxes">
            <div class="checkbox-group">
              <input type="checkbox" id="filterIncludeLapped" checked>
              <label for="filterIncludeLapped">Lapped</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterIncludeRetired" checked>
              <label for="filterIncludeRetired">Retired</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterRainfall" checked>
              <label for="filterRainfall">Rainfall</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterSafetyCar">
              <label for="filterSafetyCar">Safety Car</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="filterPitLaps">
              <label for="filterPitLaps">Pit Laps</label>
            </div>
          </div>
        </div>
      </div>
    </div>

    <!-- Tyre Degradation Panel -->
    <div id="tyre-deg-panel" class="content-panel">
      <div id="tyreDegTyreChoicesDisplay" class="tyre-choices-display" style="display: none;">
        <div class="tyre-choices-label">Tyre Choices:</div>
        <div id="tyreDegTyreChoicesText"></div>
      </div>

      <div id="tyreDegChartsWrapper" class="tyre-deg-charts-wrapper" style="display: none;">
        <div class="tyre-deg-chart-container">
          <div class="chart-title">Tire Degradation Analysis: Deg vs Pace</div>
          <div id="tyreDegScatterChart"></div>
          <div id="tyreDegEquationsSection" class="equations-section" style="display: none;">
            <div class="equations-title">Best Fit Equations (Deg = m × Pace + b)</div>
            <div id="tyreDegEquationsGrid" class="equations-grid"></div>
          </div>
        </div>

        <div class="tyre-deg-chart-container">
          <div class="chart-title">Lap Time vs Tyre Age</div>
          <div class="tyre-deg-chart-controls">
            <button id="tyreDegFuelAdjustToggle" class="toggle-button active">Fuel Adjusted</button>
            <span style="font-size: 10px; color: var(--muted-color);" id="tyreDegSelectedStintCount">No stints selected</span>
          </div>
          <div id="tyreDegLapTimeChart"></div>
        </div>
      </div>

      <div class="tyre-deg-filters">
        <div class="filter-panel">
          <div class="filters-grid">
            <div class="filter-item vertical">
              <div class="filter-label">Fuel Effect (s/lap)</div>
              <div class="slider-container">
                <input type="range" id="tyreDegFuelEffectSlider" min="0" max="0.1" step="0.001" value="0.025">
                <div class="slider-value" id="tyreDegFuelEffectValue">0.025</div>
              </div>
            </div>
            <div class="filter-item">
              <div class="filter-label">Laps to Discard at Start</div>
              <input type="number" id="tyreDegFilterMinLap" value="1" min="0">
            </div>
            <div class="filter-item">
              <div class="filter-label">Laps to Discard at End</div>
              <input type="number" id="tyreDegFilterEndLaps" value="1" min="0">
            </div>
            <div class="filter-item">
              <div class="filter-label">Min Distance to Car Ahead</div>
              <input type="number" id="tyreDegFilterMinDist" value="3" min="0" step="0.1">
            </div>
            <div class="filter-item">
              <div class="filter-label">Min Rows Per Stint</div>
              <input type="number" id="tyreDegFilterMinRows" value="5" min="1">
            </div>
            <div class="filter-item">
              <div class="filter-label">Min Correlation</div>
              <input type="number" id="tyreDegFilterMinCorr" value="-1.0" min="-1" max="1" step="0.1">
            </div>
          </div>
        </div>

        <div class="filter-panel">
          <div class="filters-title">Include</div>
          <div class="exclude-checkboxes">
            <div class="checkbox-group">
              <input type="checkbox" id="tyreDegFilterIncludeLapped" checked>
              <label for="tyreDegFilterIncludeLapped">Lapped</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="tyreDegFilterIncludeRetired" checked>
              <label for="tyreDegFilterIncludeRetired">Retired</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="tyreDegFilterRainfall">
              <label for="tyreDegFilterRainfall">Rainfall</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="tyreDegFilterSafetyCar">
              <label for="tyreDegFilterSafetyCar">Safety Car</label>
            </div>
            <div class="checkbox-group">
              <input type="checkbox" id="tyreDegFilterPitLaps">
              <label for="tyreDegFilterPitLaps">Pit Laps</label>
            </div>
          </div>
        </div>
      </div>

      <div id="tyreDegStintsTableContainer"></div>
    </div>

    <!-- Fuel Effect Panel -->
    <div id="fuel-effect-panel" class="content-panel">
      <h2>Fuel Effect Panel</h2>
      <p>Fuel effect content will go here...</p>
    </div>

  </div>
  </div>

  <div id="tooltip" class="tooltip"></div>

  <script src="https://cdn.jsdelivr.net/npm/papaparse@5/papaparse.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>

  <script>
    // ============================================================================
    // SHARED STATE AND ELEMENTS
    // ============================================================================

    const seasonSel = document.getElementById("seasonSel");
    const gpSel = document.getElementById("gpSel");
    const sessionSel = document.getElementById("sessionSel");
    const statusMessage = document.getElementById("statusMessage");
    const reloadDataBtn = document.getElementById("reloadDataBtn");

    let allRows = [];
    let sessionsByKey = new Map();
    let currentSessionData = null; // Stores filtered data for current session
    let currentActiveTab = 'strategy';
    let selectedDrivers = new Set(); // Shared driver selection across race trace and lap time panels

    // ============================================================================
    // TAB SWITCHING
    // ============================================================================

    function initTabNavigation() {
      const tabButtons = document.querySelectorAll('.tab-button');

      tabButtons.forEach(button => {
        button.addEventListener('click', () => {
          const tabName = button.dataset.tab;
          switchTab(tabName);
        });
      });
    }

    function switchTab(tabName) {
      // Update tab buttons
      document.querySelectorAll('.tab-button').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.tab === tabName);
      });

      // Update panels
      document.querySelectorAll('.content-panel').forEach(panel => {
        panel.classList.remove('active');
      });
      document.getElementById(`${tabName}-panel`).classList.add('active');

      // Hide strategy container when switching away from strategy
      if (tabName !== 'strategy') {
        strategyContainer.classList.remove('show');
      }

      currentActiveTab = tabName;

      // Initialize panel if data is available
      if (currentSessionData) {
        initializePanel(tabName, currentSessionData);
      }
    }

    function initializePanel(panelName, sessionData) {
      if (!sessionData || sessionData.length === 0) return;

      console.log(`Initializing ${panelName} panel with ${sessionData.length} rows`);

      // Get current session info
      const year = seasonSel.value;
      const [round, meeting] = gpSel.value.split('||');
      const sessionType = sessionSel.value;

      switch(panelName) {
        case 'strategy':
          renderStrategyChart(sessionData, year, round, sessionType);
          break;
        case 'race-trace':
          raceTraceCurrentSessionRows = sessionData;
          raceTraceYear = year;
          raceTraceRound = round;
          raceTraceSessionType = sessionType;
          raceTraceDriverColors = DriverInfo.getDriverColors(year, round, sessionType);
          const lapNumbers = sessionData.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n));
          const minLapNum = Math.min(...lapNumbers);
          const maxLapNum = Math.max(...lapNumbers);
          raceTraceLapMin.value = minLapNum;
          raceTraceLapMax.value = maxLapNum;
          raceTraceLapMin.min = minLapNum;
          raceTraceLapMax.max = maxLapNum;
          calculateRaceTraceGaps(sessionData);
          buildRaceTraceDriverList();

          // Auto-select top 5 drivers for new session
          if (selectedDrivers.size === 0) {
            const drivers = Object.keys(raceTraceDriverLines);
            const driverFinishInfo = drivers.map(driver => {
              const data = raceTraceDriverLines[driver];
              const maxLapNum = Math.max(...data.laps);
              const lastLapIndex = data.laps.indexOf(maxLapNum);
              const lastPosition = data.positions[lastLapIndex];
              return { driver, maxLapNum, lastPosition };
            });
            const sortedDrivers = sortDriversByFinishingOrder(driverFinishInfo);
            sortedDrivers.slice(0, 5).forEach(({ driver }) => {
              selectedDrivers.add(driver);
            });
          }

          // Update checkboxes to reflect current selection
          updateRaceTraceDriverCheckboxes();
          renderRaceTraceChart();
          break;
        case 'lap-time':
          // Initialize lap time panel
          lapTimeCurrentSessionRows = sessionData;
          lapTimeYear = year;
          lapTimeRound = round;
          lapTimeSessionType = sessionType;
          lapTimeDriverColors = DriverInfo.getDriverColors(year, round, sessionType);
          lapTimeScheduledLaps = sessionData.length > 0 ? parseInt(sessionData[0].sched_laps) : null;
          if (isNaN(lapTimeScheduledLaps)) {
            lapTimeScheduledLaps = null;
          }

          // Update adjustment inputs from circuit config if available
          const circuitName = sessionData.length > 0 ? String(sessionData[0].circuit_name || "").trim() : "";
          if (circuitName && circuitConfig[circuitName]) {
            const config = circuitConfig[circuitName];
            if (config["Hard Deg"] !== undefined) {
              document.getElementById('degHard').value = config["Hard Deg"];
            }
            if (config["Medium Deg"] !== undefined) {
              document.getElementById('degMedium').value = config["Medium Deg"];
            }
            if (config["Soft Deg"] !== undefined) {
              document.getElementById('degSoft').value = config["Soft Deg"];
            }
            if (config["Fuel Effect"] !== undefined) {
              document.getElementById('fuelEffect').value = config["Fuel Effect"];
            }
          }

          const filteredRows = applyLapTimeFilters(sessionData);
          processLapTimeData(filteredRows);

          // Auto-select top 5 drivers for new session (if not already selected)
          if (selectedDrivers.size === 0 && lapTimeCurrentGroups.size > 0) {
            const drivers = Array.from(lapTimeCurrentGroups.keys());
            const top5 = drivers.slice(0, Math.min(5, drivers.length));
            top5.forEach(driver => selectedDrivers.add(driver));
            // Re-render to show the selected drivers
            buildLapTimeDriversList(drivers);
            renderLapTimeChart();
          }
          break;
        case 'tyre-deg':
          // Initialize tyre deg panel
          // Clear previous stints tracker for event change detection
          tyreDegSelectedStints.clear();
          window.tyreDegPreviousFilteredStints = [];

          // Display tyre choices for the selected event
          const tyreKey = `${year}||${round}`;
          const tyres = tyreDegTyreChoices.get(tyreKey);
          if (tyres && tyres.hard && tyres.medium && tyres.soft) {
            tyreDegTyreChoicesText.textContent = `${tyres.hard}-${tyres.medium}-${tyres.soft}`;
            tyreDegTyreChoicesDisplay.style.display = 'flex';
          } else {
            tyreDegTyreChoicesDisplay.style.display = 'none';
          }

          // Set fuel effect from circuit config if available
          const tyreDegCircuitName = sessionData.length > 0 ? String(sessionData[0].circuit_name || "").trim() : "";
          if (tyreDegCircuitName && circuitConfig[tyreDegCircuitName] && circuitConfig[tyreDegCircuitName]["Fuel Effect"] !== undefined) {
            const fuelEffect = circuitConfig[tyreDegCircuitName]["Fuel Effect"];
            const slider = document.getElementById('tyreDegFuelEffectSlider');
            const value = document.getElementById('tyreDegFuelEffectValue');
            slider.value = fuelEffect;
            value.textContent = fuelEffect.toFixed(3);
          }

          processTyreDegData(sessionData);
          break;
        case 'fuel-effect':
          // Initialize fuel effect panel
          break;
      }
    }

    // ============================================================================
    // SHARED DATA LOADING
    // ============================================================================

    function init() {
      initTabNavigation();

      // Set up reload data button
      reloadDataBtn.addEventListener('click', () => {
        DataCache.reloadData();
      });

      DriverInfo.load(loadMainCSV);
    }

    function loadMainCSV() {
      ParsedDataCache.loadCSV("all_df.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRows = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.session_type !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRows.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          indexSessions(allRows);
          buildSeasonDropdown();
          statusMessage.textContent = `${allRows.length} laps loaded`;
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      seasonSel.addEventListener("change", onSeasonChange);
      gpSel.addEventListener("change", onGPChange);
      sessionSel.addEventListener("change", onSessionChange);
    }

    function indexSessions(rows) {
      sessionsByKey.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const sessionType = String(r.session_type || "").trim();
        const circuit = String(r.circuit_name || "").trim();
        if (!year || !round || !meeting || !sessionType || !circuit) return;

        const key = `${year}||${round}||${meeting}||${sessionType}`;
        if (!sessionsByKey.has(key)) {
          sessionsByKey.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            session_type: sessionType,
            circuit_name: circuit
          });
        }
      });
    }

    function buildSeasonDropdown() {
      UIHelpers.populateSeasons(seasonSel, sessionsByKey, {
        onChange: onSeasonChange
      });
    }

    function onSeasonChange() {
      const selectedSeason = seasonSel.value;
      sessionSel.innerHTML = '';
      sessionSel.disabled = true;

      currentSessionData = null;

      UIHelpers.populateGPs(gpSel, sessionsByKey, selectedSeason, {
        onChange: onGPChange
      });
    }

    function onGPChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;

      currentSessionData = null;

      UIHelpers.populateSessions(sessionSel, sessionsByKey, selectedSeason, selectedGP, {
        onChange: onSessionChange
      });
    }

    function onSessionChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) {
        currentSessionData = null;
        return;
      }

      const [round, meeting] = selectedGP.split('||');

      // Filter data for this session (shared across all tabs)
      currentSessionData = allRows.filter(r => {
        return String(r.year || "").trim() === selectedSeason &&
               String(r.round_no || "").trim() === round &&
               String(r.meeting_name || "").trim() === meeting &&
               String(r.session_type || "").trim() === selectedSession;
      });

      // Clear selected drivers when a new session is selected
      selectedDrivers.clear();

      // Initialize the currently active panel with new data
      if (currentSessionData.length > 0) {
        initializePanel(currentActiveTab, currentSessionData);
      }
    }

    // ============================================================================
    // PANEL-SPECIFIC CODE SECTIONS
    // ============================================================================

    // Strategy Panel
    const strategyChart = document.getElementById('strategyChart');
    const strategyContainer = document.getElementById('strategyContainer');
    const lapAxisTop = document.getElementById('lapAxisTop');
    const lapAxisBottom = document.getElementById('lapAxisBottom');
    const tooltip = document.getElementById('tooltip');

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();
      const colorMap = {
        'soft': '#FF0000',
        'medium': '#FFF200',
        'hard': '#FFFFFF',
        'intermediate': '#00FF00',
        'wet': '#0000FF'
      };
      return colorMap[compoundLower] || '#999999';
    }

    function updateTooltipPosition(e) {
      const x = e.clientX;
      const y = e.clientY;
      tooltip.style.left = `${x + 15}px`;
      tooltip.style.top = `${y + 15}px`;
    }

    function renderStrategyChart(rows, year, round, sessionType) {
      // Get driver colors for this specific session
      const driverColors = DriverInfo.getDriverColors(year, round, sessionType);

      // Group by driver
      const driverData = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNum = parseInt(r.lap_LapNumber);
        const stint = parseInt(r.lap_Stint);
        const compound = String(r.lap_Compound || "").trim();
        const gridPos = parseInt(r.grid_position);
        const tyreLife = parseInt(r.lap_TyreLife);
        const position = parseInt(r.lap_Position);

        if (!driver || isNaN(lapNum)) return;

        if (!driverData.has(driver)) {
          driverData.set(driver, {
            driver: driver,
            gridPosition: gridPos,
            laps: new Map(),
            stints: new Map(),
            maxLapNum: 0,
            lastPosition: null
          });
        }

        const data = driverData.get(driver);
        data.laps.set(lapNum, { compound, stint, tyreLife, position });

        // Track max lap number and position on that lap
        if (lapNum > data.maxLapNum) {
          data.maxLapNum = lapNum;
          data.lastPosition = position;
        }

        if (!data.stints.has(stint)) {
          data.stints.set(stint, {
            compound: compound,
            startLap: lapNum,
            endLap: lapNum,
            startTyreLife: tyreLife
          });
        } else {
          const stintData = data.stints.get(stint);
          if (lapNum < stintData.startLap) {
            stintData.startLap = lapNum;
            stintData.startTyreLife = tyreLife;
          }
          if (lapNum > stintData.endLap) {
            stintData.endLap = lapNum;
          }
        }
      });

      // Get max lap number (scheduled laps)
      const schedLaps = parseInt(rows[0]?.sched_laps || 0);
      const maxLap = schedLaps > 0 ? schedLaps : Math.max(...Array.from(driverData.values()).flatMap(d => Array.from(d.laps.keys())));

      // Sort drivers by finishing position using shared utility
      const sortedDrivers = sortDriversByFinishingOrder(Array.from(driverData.values()));

      // Clear chart
      strategyChart.innerHTML = '';

      // Render driver rows
      sortedDrivers.forEach(data => {
        const row = document.createElement('div');
        row.className = 'driver-row';

        const label = document.createElement('div');
        label.className = 'driver-label';
        label.textContent = data.driver;

        // Apply driver color if available
        const driverColor = driverColors.get(data.driver);
        if (driverColor) {
          label.style.color = driverColor;
        }

        const bar = document.createElement('div');
        bar.className = 'strategy-bar';

        // Build stint segments
        const sortedStints = Array.from(data.stints.values()).sort((a, b) => a.startLap - b.startLap);

        sortedStints.forEach((stint, idx) => {
          const segment = document.createElement('div');
          segment.className = 'stint-segment';
          const stintLaps = stint.endLap - stint.startLap + 1;
          const widthPercent = (stintLaps / maxLap) * 100;
          segment.style.width = `${widthPercent}%`;
          segment.style.backgroundColor = getF1TireColor(stint.compound);

          // Add tooltip
          segment.addEventListener('mouseenter', (e) => {
            const info = DriverInfo.getDriverInfo(data.driver, year, round, sessionType);
            const tyreAgeText = !isNaN(stint.startTyreLife) ? `Tyre age at start: ${stint.startTyreLife} laps` : '';

            if (info && info.headshotUrl) {
              const fullName = info.fullName || data.driver;
              const teamName = info.teamName || '';
              const stintInfo = `
                <div style="margin-top:4px">Stint ${idx + 1}: ${stint.compound}</div>
                <div>Laps ${stint.startLap}-${stint.endLap} (${stintLaps} laps)</div>
                ${tyreAgeText ? `<div>${tyreAgeText}</div>` : ''}
              `;
              tooltip.innerHTML = `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${data.driver})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${stintInfo}
                  </div>
                </div>
              `;
            } else {
              tooltip.innerHTML = `
                <strong>${data.driver}</strong><br/>
                Stint ${idx + 1}: ${stint.compound}<br/>
                Laps ${stint.startLap}-${stint.endLap} (${stintLaps} laps)${tyreAgeText ? `<br/>${tyreAgeText}` : ''}
              `;
            }
            tooltip.classList.add('show');
            updateTooltipPosition(e);
          });

          segment.addEventListener('mousemove', updateTooltipPosition);

          segment.addEventListener('mouseleave', () => {
            tooltip.classList.remove('show');
          });

          bar.appendChild(segment);
        });

        // Add missing laps if driver didn't complete all laps
        const lastLap = Math.max(...Array.from(data.laps.keys()));
        if (lastLap < maxLap) {
          const missingLaps = maxLap - lastLap;
          const widthPercent = (missingLaps / maxLap) * 100;
          const missing = document.createElement('div');
          missing.className = 'missing-laps';
          missing.style.width = `${widthPercent}%`;
          bar.appendChild(missing);
        }

        row.appendChild(label);
        row.appendChild(bar);
        strategyChart.appendChild(row);
      });

      // Render lap axes
      renderLapAxis(maxLap);

      // Show the container
      strategyContainer.classList.add('show');
    }

    function renderLapAxis(maxLap) {
      lapAxisTop.innerHTML = '';
      lapAxisBottom.innerHTML = '';

      // Create tick marks at intervals
      const interval = maxLap > 50 ? 10 : 5;

      for (let lap = 0; lap <= maxLap; lap += interval) {
        // Top axis
        const tickTop = document.createElement('div');
        tickTop.className = 'lap-tick';
        const position = (lap / maxLap) * 100;
        tickTop.style.left = `${position}%`;
        lapAxisTop.appendChild(tickTop);

        const labelTop = document.createElement('div');
        labelTop.className = 'lap-label';
        labelTop.textContent = lap;
        labelTop.style.left = `${position}%`;
        lapAxisTop.appendChild(labelTop);

        // Bottom axis
        const tickBottom = document.createElement('div');
        tickBottom.className = 'lap-tick';
        tickBottom.style.left = `${position}%`;
        lapAxisBottom.appendChild(tickBottom);

        const labelBottom = document.createElement('div');
        labelBottom.className = 'lap-label';
        labelBottom.textContent = lap;
        labelBottom.style.left = `${position}%`;
        lapAxisBottom.appendChild(labelBottom);
      }
    }

    // Race Trace Panel
    const raceTraceLapMin = document.getElementById('raceTraceLapMin');
    const raceTraceLapMax = document.getElementById('raceTraceLapMax');
    const raceTraceDriverList = document.getElementById('raceTraceDriverList');
    const raceTraceBtnAll = document.getElementById('raceTraceBtnAll');
    const raceTraceBtnNone = document.getElementById('raceTraceBtnNone');
    const raceTraceDebugInfo = document.getElementById('raceTraceDebugInfo');

    let raceTraceDriverLines = {};
    let raceTraceChart = null;
    let raceTraceCurrentSessionRows = [];
    let raceTraceDriverColors = new Map();
    let raceTraceYear = '';
    let raceTraceRound = '';
    let raceTraceSessionType = '';

    // Set up race trace event listeners
    raceTraceBtnAll.addEventListener('click', () => {
      selectedDrivers.clear();
      Object.keys(raceTraceDriverLines).forEach(d => selectedDrivers.add(d));
      updateRaceTraceDriverCheckboxes();
      renderRaceTraceChart();
    });

    raceTraceBtnNone.addEventListener('click', () => {
      selectedDrivers.clear();
      updateRaceTraceDriverCheckboxes();
      renderRaceTraceChart();
    });

    raceTraceLapMin.addEventListener('input', () => renderRaceTraceChart());
    raceTraceLapMax.addEventListener('input', () => renderRaceTraceChart());

    function getDriverInfo(code) {
      // Get driver info for current session with proper parameters
      if (!raceTraceYear || !raceTraceRound || !raceTraceSessionType) {
        return { fullName: code, color: '#888888', teamName: '', headshotUrl: '' };
      }

      return DriverInfo.getDriverInfo(code, raceTraceYear, raceTraceRound, raceTraceSessionType);
    }

    function calculateRaceTraceGaps(rows) {
      const lapData = new Map();

      rows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        const driver = String(r.lap_Driver || "").trim();
        const position = parseInt(r.lap_Position);
        const lapTime = parseFloat(r.lap_Time);

        if (isNaN(lapNum) || !driver || isNaN(lapTime) || isNaN(position)) return;

        if (!lapData.has(lapNum)) {
          lapData.set(lapNum, []);
        }

        lapData.get(lapNum).push({ driver, position, lapTime });
      });

      raceTraceDriverLines = {};

      lapData.forEach((driversInLap, lapNum) => {
        driversInLap.sort((a, b) => a.position - b.position);
        const minTime = Math.min(...driversInLap.map(d => d.lapTime));

        driversInLap.forEach(d => {
          const gap = minTime - d.lapTime;

          if (!raceTraceDriverLines[d.driver]) {
            raceTraceDriverLines[d.driver] = {
              laps: [],
              gaps: [],
              positions: []
            };
          }

          raceTraceDriverLines[d.driver].laps.push(lapNum);
          raceTraceDriverLines[d.driver].gaps.push(gap);
          raceTraceDriverLines[d.driver].positions.push(d.position);
        });
      });
    }

    function buildRaceTraceDriverList() {
      raceTraceDriverList.innerHTML = '';

      const drivers = Object.keys(raceTraceDriverLines);
      const driverFinishInfo = drivers.map(driver => {
        const data = raceTraceDriverLines[driver];
        const maxLapNum = Math.max(...data.laps);
        const lastLapIndex = data.laps.indexOf(maxLapNum);
        const lastPosition = data.positions[lastLapIndex];

        return { driver, maxLapNum, lastPosition };
      });

      const sortedDriverFinishInfo = sortDriversByFinishingOrder(driverFinishInfo);

      sortedDriverFinishInfo.forEach(({ driver }) => {
        const div = document.createElement('div');
        div.className = 'race-trace-driver';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.id = `race-trace-driver-${driver}`;
        checkbox.checked = selectedDrivers.has(driver);

        const info = getDriverInfo(driver);
        checkbox.style.accentColor = info.color;

        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedDrivers.add(driver);
          } else {
            selectedDrivers.delete(driver);
          }
          renderRaceTraceChart();
          // Also update lap time chart if it has data
          if (lapTimeCurrentGroups.size > 0) {
            renderLapTimeChart();
          }
        });

        const label = document.createElement('label');
        label.htmlFor = `race-trace-driver-${driver}`;

        // Format: "Full Name (ABB)"
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        label.textContent = displayName;
        label.style.color = info.color;

        div.appendChild(checkbox);
        div.appendChild(label);
        raceTraceDriverList.appendChild(div);
      });
    }

    function updateRaceTraceDriverCheckboxes() {
      Object.keys(raceTraceDriverLines).forEach(driver => {
        const checkbox = document.getElementById(`race-trace-driver-${driver}`);
        if (checkbox) {
          checkbox.checked = selectedDrivers.has(driver);
        }
      });
    }

    // Shared detection functions that work with any session rows
    function detectRainfallLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapRainfall = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRainfall.has(lapNum)) {
          lapRainfall.set(lapNum, { total: 0, rainfall: 0 });
        }

        const lapData = lapRainfall.get(lapNum);
        lapData.total++;

        const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
        if (rainfall === 'true' || rainfall === '1') {
          lapData.rainfall++;
        }
      });

      const rainfallLaps = [];
      lapRainfall.forEach((data, lapNum) => {
        if (data.rainfall / data.total >= 0.5) {
          rainfallLaps.push(lapNum);
        }
      });

      if (rainfallLaps.length === 0) return [];

      rainfallLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = rainfallLaps[0];
      let end = rainfallLaps[0];

      for (let i = 1; i < rainfallLaps.length; i++) {
        if (rainfallLaps[i] === end + 1) {
          end = rainfallLaps[i];
        } else {
          ranges.push({ start, end });
          start = rainfallLaps[i];
          end = rainfallLaps[i];
        }
      }
      ranges.push({ start, end });
      return ranges;
    }

    function detectSafetyCarLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapSafetyCar = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapSafetyCar.has(lapNum)) {
          lapSafetyCar.set(lapNum, { total: 0, safetyCar: 0 });
        }

        const lapData = lapSafetyCar.get(lapNum);
        lapData.total++;

        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('4') || trackStatus.includes('6') || trackStatus.includes('7')) {
          if (!trackStatus.includes('5')) {
            lapData.safetyCar++;
          }
        }
      });

      const safetyCarLaps = [];
      lapSafetyCar.forEach((data, lapNum) => {
        if (data.safetyCar / data.total >= 0.5) {
          safetyCarLaps.push(lapNum);
        }
      });

      if (safetyCarLaps.length === 0) return [];

      safetyCarLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = safetyCarLaps[0];
      let end = safetyCarLaps[0];

      for (let i = 1; i < safetyCarLaps.length; i++) {
        if (safetyCarLaps[i] === end + 1) {
          end = safetyCarLaps[i];
        } else {
          ranges.push({ start, end });
          start = safetyCarLaps[i];
          end = safetyCarLaps[i];
        }
      }
      ranges.push({ start, end });
      return ranges;
    }

    function detectRedFlagLaps(sessionRows, minLap, maxLap) {
      if (!sessionRows || sessionRows.length === 0) return [];

      const lapRedFlag = new Map();
      sessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRedFlag.has(lapNum)) {
          lapRedFlag.set(lapNum, { total: 0, redFlag: 0 });
        }

        const lapData = lapRedFlag.get(lapNum);
        lapData.total++;

        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('5')) {
          lapData.redFlag++;
        }
      });

      const redFlagLaps = [];
      lapRedFlag.forEach((data, lapNum) => {
        if (data.redFlag / data.total >= 0.5) {
          redFlagLaps.push(lapNum);
        }
      });

      return redFlagLaps.sort((a, b) => a - b);
    }

    function renderRaceTraceChart() {
      if (Object.keys(raceTraceDriverLines).length === 0) return;

      const chartContainer = document.getElementById('raceTraceChart');
      const debugDiv = document.getElementById('raceTraceDebugInfo');
      if (debugDiv) debugDiv.remove();

      if (!raceTraceChart) {
        raceTraceChart = echarts.init(chartContainer);
      }

      const minLap = parseInt(raceTraceLapMin.value);
      const maxLap = parseInt(raceTraceLapMax.value);

      // Detect rainfall, safety car, and red flag laps using unfiltered session data
      const rainfallRanges = detectRainfallLaps(raceTraceCurrentSessionRows, minLap, maxLap);
      const safetyCarRanges = detectSafetyCarLaps(raceTraceCurrentSessionRows, minLap, maxLap);
      const redFlagLaps = detectRedFlagLaps(raceTraceCurrentSessionRows, minLap, maxLap);

      // Calculate gaps by lap for scaling
      const gapsByLap = new Map();
      selectedDrivers.forEach(driver => {
        const data = raceTraceDriverLines[driver];
        if (!data) return;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            if (!gapsByLap.has(lap)) gapsByLap.set(lap, []);
            gapsByLap.get(lap).push(data.gaps[i]);
          }
        }
      });

      const maxGapByLap = new Map();
      gapsByLap.forEach((gaps, lap) => {
        maxGapByLap.set(lap, Math.max(...gaps));
      });

      const series = [];
      const lapCount = Math.max(...Object.values(raceTraceDriverLines).map(d => Math.max(...d.laps)));
      const rightX = (maxLap === lapCount) ? (maxLap + 0.5) : (maxLap + 0.1);

      selectedDrivers.forEach(driver => {
        const data = raceTraceDriverLines[driver];
        if (!data) return;

        const points = [];
        let lastGap = null;
        for (let i = 0; i < data.laps.length; i++) {
          const lap = data.laps[i];
          if (lap >= minLap && lap <= maxLap) {
            const rawGap = data.gaps[i];
            const maxGap = maxGapByLap.get(lap) || 0;
            const adjustedGap = rawGap - maxGap;
            points.push([lap, adjustedGap]);
            lastGap = adjustedGap;
          }
        }

        if (points.length > 0) {
          const info = getDriverInfo(driver);
          const completedAllLaps = data.laps.some(lap => lap === maxLap);

          if (completedAllLaps && lastGap !== null) {
            points.push({
              value: [rightX, lastGap],
              tooltip: { show: false },
              emphasis: { disabled: true }
            });
          }

          series.push({
            name: driver,
            type: 'line',
            data: points,
            step: 'end',
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: info.color },
            itemStyle: { color: info.color, borderWidth: 0 },
            emphasis: { focus: 'series', blurScope: 'global', lineStyle: { width: 3.5 } },
            blur: { lineStyle: { opacity: 0.15 } },
            endLabel: {
              show: completedAllLaps,
              formatter: '{a}',
              position: 'right',
              offset: [6, 0],
              color: info.color
            },
            animation: false
          });
        }
      });

      // Add rainfall shading
      if (rainfallRanges.length > 0) {
        const markAreaData = rainfallRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end ? `Rainfall (Lap ${range.start})` : `Rainfall (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Rainfall',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: { color: 'rgba(30, 144, 255, 0.1)' },
            data: markAreaData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      // Add safety car shading
      if (safetyCarRanges.length > 0) {
        const markAreaData = safetyCarRanges.map(range => [
          {
            xAxis: range.start - 0.5,
            name: range.start === range.end ? `Safety Car (Lap ${range.start})` : `Safety Car (Laps ${range.start}-${range.end})`
          },
          { xAxis: range.end + 0.5 }
        ]);

        series.push({
          name: 'Safety Car',
          type: 'line',
          data: [],
          markArea: {
            silent: false,
            itemStyle: { color: 'rgba(150, 150, 7, 0.15)' },
            data: markAreaData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      // Add red flag lines
      if (redFlagLaps.length > 0) {
        const markLineData = redFlagLaps.map(lap => ({
          xAxis: lap,
          name: `Red Flag (Lap ${lap})`,
          label: { show: false }
        }));

        series.push({
          name: 'Red Flag',
          type: 'line',
          data: [],
          markLine: {
            silent: false,
            symbol: 'none',
            lineStyle: {
              color: 'rgba(255, 0, 0, 0.5)',
              width: 2,
              type: 'dashed'
            },
            data: markLineData,
            label: { show: false },
            tooltip: { formatter: (params) => params.name }
          },
          animation: false
        });
      }

      const option = {
        backgroundColor: 'transparent',
        grid: {
          left: 60,
          right: 120,
          top: 40,
          bottom: 60,
          containLabel: false
        },
        xAxis: [
          {
            type: 'value',
            name: 'Lap',
            min: minLap,
            max: rightX,
            minInterval: 1,
            nameLocation: 'middle',
            nameGap: 35,
            position: 'bottom',
            axisLine: { lineStyle: { color: '#555' } },
            axisLabel: {
              color: '#aaa',
              formatter: function(value) {
                // Only show label if it's an integer
                return Number.isInteger(value) ? value : '';
              }
            },
            splitLine: {
              show: true,
              lineStyle: { color: '#333', type: 'solid', width: 1 }
            }
          },
          {
            type: 'value',
            min: minLap,
            max: rightX,
            minInterval: 1,
            position: 'top',
            axisLine: { lineStyle: { color: '#555' } },
            axisLabel: {
              color: '#aaa',
              formatter: function(value) {
                // Only show label if it's an integer
                return Number.isInteger(value) ? value : '';
              }
            },
            splitLine: { show: false }
          }
        ],
        yAxis: {
          type: 'value',
          name: 'Gap (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameRotate: 90,
          nameTextStyle: { color: '#aaa', fontSize: 12 },
          minInterval: 1,
          axisLine: { lineStyle: { color: '#555' } },
          axisLabel: { color: '#aaa' },
          splitLine: {
            show: true,
            lineStyle: { color: '#333', type: 'solid', width: 1 }
          }
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          appendToBody: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const v = Array.isArray(p.value) ? p.value : p.data?.value || p.data;
            const lap = Array.isArray(v) ? v[0] : v?.[0];
            const gap = Array.isArray(v) ? v[1] : v?.[1];
            const code = p.seriesName;
            const info = getDriverInfo(code);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || code;
              const teamName = info.teamName || '';
              const gapLine = (typeof lap === 'number' && typeof gap === 'number')
                ? `<div style="margin-top:4px">Lap ${lap}: ${gap.toFixed(3)} s</div>`
                : '';
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${code})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${gapLine}
                  </div>
                </div>
              `;
            }

            if (typeof lap === 'number' && typeof gap === 'number') {
              return `${p.marker}<b>${code}</b><br/>Lap ${lap}: ${gap.toFixed(3)} s`;
            }
            return `${p.marker}<b>${code}</b>`;
          }
        },
        series: series
      };

      raceTraceChart.setOption(option, true); // true = notMerge, completely replace the option
    }

    // Lap Time Panel
    const lapTimeDriversList = document.getElementById('lapTimeDriversList');
    const lapTimeChart = document.getElementById('lapTimeChart');
    const fuelAdjustToggle = document.getElementById('fuelAdjustToggle');
    const tyreLifeAdjustToggle = document.getElementById('tyreLifeAdjustToggle');

    let lapTimeChartInstance = null;
    let lapTimeCurrentGroups = new Map();
    let lapTimeDriverColors = new Map();
    let lapTimeScheduledLaps = null;
    let lapTimeCurrentSessionRows = [];
    let lapTimeYear = '';
    let lapTimeRound = '';
    let lapTimeSessionType = '';
    let circuitConfig = {};

    // Load circuit config
    function loadCircuitConfig() {
      fetch('strat_calc_config.json')
        .then(response => response.json())
        .then(data => {
          circuitConfig = data;
        })
        .catch(err => {
          console.error("Error loading strat_calc_config.json:", err);
        });
    }

    loadCircuitConfig();

    function getLapTimeDriverInfo(code) {
      // Get driver info for current session with proper parameters
      if (!lapTimeYear || !lapTimeRound || !lapTimeSessionType) {
        return { fullName: code, color: '#888888', teamName: '', headshotUrl: '' };
      }

      return DriverInfo.getDriverInfo(code, lapTimeYear, lapTimeRound, lapTimeSessionType);
    }

    // Set up lap time filter listeners
    function setupLapTimeFilterListeners() {
      document.getElementById("filterMinLap").addEventListener("input", onLapTimeFilterChange);
      document.getElementById("filterEndLaps").addEventListener("input", onLapTimeFilterChange);
      document.getElementById("filterMinDist").addEventListener("input", onLapTimeFilterChange);
      document.getElementById("filterRainfall").addEventListener("change", onLapTimeFilterChange);
      document.getElementById("filterSafetyCar").addEventListener("change", onLapTimeFilterChange);
      document.getElementById("filterPitLaps").addEventListener("change", onLapTimeFilterChange);
      document.getElementById('filterIncludeLapped').addEventListener('change', onLapTimeFilterChange);
      document.getElementById('filterIncludeRetired').addEventListener('change', onLapTimeFilterChange);
      document.getElementById('degHard').addEventListener('input', onLapTimeAdjustmentChange);
      document.getElementById('degMedium').addEventListener('input', onLapTimeAdjustmentChange);
      document.getElementById('degSoft').addEventListener('input', onLapTimeAdjustmentChange);
      document.getElementById('fuelEffect').addEventListener('input', onLapTimeAdjustmentChange);

      fuelAdjustToggle.addEventListener('click', function() {
        this.classList.toggle('active');
        renderLapTimeChart();
      });

      tyreLifeAdjustToggle.addEventListener('click', function() {
        this.classList.toggle('active');
        renderLapTimeChart();
      });
    }

    setupLapTimeFilterListeners();

    function onLapTimeFilterChange() {
      if (!currentSessionData || currentSessionData.length === 0) return;
      const filteredRows = applyLapTimeFilters(currentSessionData);
      processLapTimeData(filteredRows);
    }

    function onLapTimeAdjustmentChange() {
      if (lapTimeCurrentGroups.size > 0) {
        renderLapTimeChart();
      }
    }

    function applyLapTimeFilters(rows) {
      const lapsToDiscard = parseInt(document.getElementById("filterMinLap").value) || 0;
      const minLap = lapsToDiscard + 1;
      const endLaps = parseInt(document.getElementById("filterEndLaps").value) || 0;
      const minDist = parseFloat(document.getElementById("filterMinDist").value) || 0;
      const includeRainfall = document.getElementById("filterRainfall").checked;
      const includeSafetyCar = document.getElementById("filterSafetyCar").checked;
      const includePitLaps = document.getElementById("filterPitLaps").checked;
      const includeLapped = document.getElementById('filterIncludeLapped').checked;
      const includeRetired = document.getElementById('filterIncludeRetired').checked;

      return rows.filter(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap) return false;

        const schedLaps = parseInt(r.sched_laps);
        if (!isNaN(schedLaps)) {
          const maxLap = schedLaps - endLaps;
          if (lapNum > maxLap) return false;
        }

        const status = String(r.finish_status ?? "").trim();
        const plusLapsMatch = status.match(/^\+(\d+)\sLaps$/);
        const lapsBehind = plusLapsMatch ? Number(plusLapsMatch[1]) : 0;
        if (lapsBehind > 1) return false;

        const isLapped = status === "Lapped" || status === "+1 Lap";
        if (!includeLapped && isLapped) return false;

        const isFinished = status === "Finished" || isLapped;
        const isRetired = !isFinished;
        if (!includeRetired && isRetired) return false;

        if (!includeRainfall) {
          const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
          if (rainfall === "true" || rainfall === "1") return false;
        }

        if (!includeSafetyCar) {
          const trackStatus = String(r.lap_TrackStatus || "").trim();
          if (trackStatus.includes("4") || trackStatus.includes("5") ||
              trackStatus.includes("6") || trackStatus.includes("7")) {
            return false;
          }
        }

        if (!includePitLaps) {
          const pitIn = String(r.lap_PitInTime || "").trim();
          const pitOut = String(r.lap_PitOutTime || "").trim();
          if ((pitIn && pitIn.toLowerCase() !== "na" && pitIn !== "") ||
              (pitOut && pitOut.toLowerCase() !== "na" && pitOut !== "")) {
            return false;
          }
        }

        const dist = parseFloat(r.min_dist);
        if (!isNaN(dist) && dist < minDist) return false;

        return true;
      });
    }

    function processLapTimeData(rows) {
      if (!rows || rows.length === 0) {
        lapTimeCurrentGroups = new Map();
        lapTimeSelectedDrivers.clear();
        buildLapTimeDriversList([]);
        renderLapTimeChart();
        return;
      }

      const driverData = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNumber = parseInt(r.lap_LapNumber);
        const lapTime = parseFloat(r.lap_LapTime);
        const compound = String(r.lap_Compound || "").trim();
        const stint = String(r.lap_Stint || "").trim();
        const position = parseInt(r.lap_Position);
        const tyreLife = parseInt(r.lap_TyreLife);
        const schedLaps = parseInt(r.sched_laps);

        if (!driver || isNaN(lapNumber) || isNaN(lapTime) || !stint) return;

        if (!driverData.has(driver)) {
          driverData.set(driver, {
            driver: driver,
            stints: new Map(),
            maxLapNum: 0,
            lastPosition: null
          });
        }

        const data = driverData.get(driver);
        const driverStints = data.stints;

        if (!driverStints.has(stint)) {
          driverStints.set(stint, {
            compound: compound,
            laps: []
          });
        }

        driverStints.get(stint).laps.push({
          lapNumber: lapNumber,
          lapTime: lapTime,
          compound: compound,
          tyreLife: tyreLife,
          schedLaps: schedLaps
        });

        if (lapNumber > data.maxLapNum) {
          data.maxLapNum = lapNumber;
          data.lastPosition = position;
        }
      });

      const sortedDrivers = sortDriversByFinishingOrder(Array.from(driverData.values()));

      const sortedDriverData = new Map();
      sortedDrivers.forEach(d => {
        sortedDriverData.set(d.driver, d.stints);
      });
      lapTimeCurrentGroups = sortedDriverData;

      const drivers = sortedDrivers.map(d => d.driver);

      buildLapTimeDriversList(drivers);
      renderLapTimeChart();
    }

    function buildLapTimeDriversList(drivers) {
      lapTimeDriversList.innerHTML = '';

      if (drivers.length === 0) return;

      drivers.forEach(driver => {
        const wrapper = document.createElement('label');
        wrapper.className = 'lap-time-driver-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = driver;
        checkbox.checked = selectedDrivers.has(driver);

        const info = getLapTimeDriverInfo(driver);
        checkbox.style.accentColor = info.color;

        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedDrivers.add(driver);
          } else {
            selectedDrivers.delete(driver);
          }
          renderLapTimeChart();
          // Also update race trace chart if it has data
          if (Object.keys(raceTraceDriverLines).length > 0) {
            renderRaceTraceChart();
          }
        });

        const label = document.createElement('label');

        // Format: "Full Name (ABB)"
        const displayName = info.fullName ? `${info.fullName} (${driver})` : driver;
        label.textContent = displayName;
        label.style.cursor = 'pointer';
        label.style.color = info.color;

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        lapTimeDriversList.appendChild(wrapper);
      });
    }

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();
      const colorMap = {
        'soft': '#FF0000',
        'medium': '#FFF200',
        'hard': '#FFFFFF',
        'intermediate': '#00FF00',
        'wet': '#0000FF'
      };
      return colorMap[compoundLower] || '#999999';
    }

    function renderLapTimeChart() {
      if (lapTimeCurrentGroups.size === 0) {
        if (lapTimeChartInstance) {
          lapTimeChartInstance.clear();
        }
        return;
      }

      if (!lapTimeChartInstance) {
        lapTimeChartInstance = echarts.init(lapTimeChart);
      }

      const fuelAdjusted = fuelAdjustToggle.classList.contains('active');
      const tyreLifeAdjusted = tyreLifeAdjustToggle.classList.contains('active');
      const fuelEffect = parseFloat(document.getElementById('fuelEffect').value) || 0;
      const degHard = parseFloat(document.getElementById('degHard').value) || 0;
      const degMedium = parseFloat(document.getElementById('degMedium').value) || 0;
      const degSoft = parseFloat(document.getElementById('degSoft').value) || 0;

      const degradationMap = {
        'HARD': degHard,
        'MEDIUM': degMedium,
        'SOFT': degSoft
      };

      const series = [];
      const seriesIndexByDriver = new Map();
      let seriesIdx = 0;

      lapTimeCurrentGroups.forEach((stints, driver) => {
        if (!selectedDrivers.has(driver)) return;

        const stintArray = Array.from(stints.entries()).sort((a, b) => {
          return parseInt(a[0]) - parseInt(b[0]);
        });

        const lastStintIndex = stintArray.length - 1;

        stintArray.forEach(([stintNumber, stintData], stintIndex) => {
          const isLastStint = stintIndex === lastStintIndex;
          const sortedLaps = stintData.laps.slice().sort((a, b) => a.lapNumber - b.lapNumber);

          const data = sortedLaps.map(lap => {
            let adjustedLapTime = lap.lapTime;

            if (fuelAdjusted && !isNaN(lap.schedLaps)) {
              adjustedLapTime -= (lap.schedLaps - lap.lapNumber) * fuelEffect;
            }

            if (tyreLifeAdjusted && !isNaN(lap.tyreLife)) {
              const tyreDeg = degradationMap[lap.compound.toUpperCase()] || 0;
              adjustedLapTime -= lap.tyreLife * tyreDeg;
            }

            return {
              value: [lap.lapNumber, adjustedLapTime],
              driver: driver,
              compound: lap.compound,
              stint: stintNumber,
              originalLapTime: lap.lapTime
            };
          });

          const compound = stintData.compound;
          const compoundColor = getF1TireColor(compound);
          const driverColor = lapTimeDriverColors.get(driver) || '#888888';

          if (!seriesIndexByDriver.has(driver)) {
            seriesIndexByDriver.set(driver, []);
          }
          seriesIndexByDriver.get(driver).push(seriesIdx);

          series.push({
            name: `${driver} - Stint ${stintNumber}`,
            type: 'line',
            data: data,
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: compoundColor },
            triggerLineEvent: true,
            itemStyle: {
              color: driverColor,
              borderColor: driverColor,
              borderWidth: 2
            },
            emphasis: {
              focus: 'none',
              lineStyle: { width: 3 },
              scale: true
            },
            blur: {
              lineStyle: { opacity: 0.05 },
              itemStyle: { opacity: 0.05 }
            },
            endLabel: {
              show: isLastStint,
              formatter: driver,
              position: 'right',
              offset: [6, 0],
              color: driverColor,
              fontSize: 11
            },
            animation: false,
            driver: driver
          });

          seriesIdx++;
        });
      });

      const driverSeriesCount = series.length;

      // Detect rainfall, safety car, and red flag laps for the entire session range
      if (lapTimeCurrentSessionRows.length > 0) {
        // Use the full session lap range (1 to scheduled laps, or max lap in data)
        const minLap = 1;
        const maxLap = lapTimeScheduledLaps || Math.max(...lapTimeCurrentSessionRows.map(r => parseInt(r.lap_LapNumber)).filter(n => !isNaN(n)));

        const rainfallRanges = detectRainfallLaps(lapTimeCurrentSessionRows, minLap, maxLap);
        const safetyCarRanges = detectSafetyCarLaps(lapTimeCurrentSessionRows, minLap, maxLap);
        const redFlagLaps = detectRedFlagLaps(lapTimeCurrentSessionRows, minLap, maxLap);

        if (rainfallRanges.length > 0) {
          const markAreaData = rainfallRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Rainfall (Lap ${range.start})`
                : `Rainfall (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Rainfall',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: { color: 'rgba(30, 144, 255, 0.1)' },
              data: markAreaData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }

        if (safetyCarRanges.length > 0) {
          const markAreaData = safetyCarRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Safety Car (Lap ${range.start})`
                : `Safety Car (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Safety Car',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: { color: 'rgba(150, 150, 7, 0.15)' },
              data: markAreaData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }

        if (redFlagLaps.length > 0) {
          const markLineData = redFlagLaps.map(lap => ({
            xAxis: lap,
            name: `Red Flag (Lap ${lap})`,
            label: { show: false }
          }));

          series.push({
            name: 'Red Flag',
            type: 'line',
            data: [],
            markLine: {
              silent: false,
              symbol: 'none',
              lineStyle: {
                color: 'rgba(255, 0, 0, 0.5)',
                width: 2,
                type: 'dotted'
              },
              data: markLineData,
              label: { show: false },
              tooltip: { formatter: (params) => params.name }
            },
            animation: false
          });
        }
      }

      if (series.length === 0) {
        lapTimeChartInstance.clear();
        return;
      }

      lapTimeChartInstance.setOption({
        backgroundColor: 'transparent',
        grid: { left: 60, right: 100, top: 20, bottom: 60 },
        legend: { show: false },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const data = p.data;
            const lapNumber = data.value[0];
            const lapTime = data.value[1];
            const info = getLapTimeDriverInfo(data.driver);

            if (info && info.headshotUrl) {
              const fullName = info.fullName || data.driver;
              const teamName = info.teamName || '';
              const lapInfo = `
                <div style="margin-top:4px">Lap ${lapNumber}: ${lapTime.toFixed(3)}s</div>
                <div>Compound: ${data.compound}</div>
                <div>Stint: ${data.stint}</div>
              `;
              return `
                <div style="display:flex;align-items:center;gap:10px;min-width:220px;">
                  <img src="${info.headshotUrl}" alt="${fullName}" width="50" height="50" style="border-radius:50%;object-fit:cover;border:1px solid #2a2f3a;flex:0 0 auto" />
                  <div style="line-height:1.25">
                    <div style="font-weight:600">${fullName} <span style="color:#8b8b8b">(${data.driver})</span></div>
                    ${teamName ? `<div style="color:#8b8b8b;font-size:12px">${teamName}</div>` : ''}
                    ${lapInfo}
                  </div>
                </div>
              `;
            }

            return `
              <strong>${data.driver}</strong><br/>
              Lap: ${lapNumber}<br/>
              Time: ${lapTime.toFixed(3)}s<br/>
              Compound: ${data.compound}<br/>
              Stint: ${data.stint}
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Lap Number',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          min: 1,
          max: lapTimeScheduledLaps || 'dataMax'
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true
        },
        series: series
      }, true);

      lapTimeChartInstance.resize();

      // Custom hover behavior
      lapTimeChartInstance.off('mouseover');
      lapTimeChartInstance.off('mouseout');

      let currentHoveredDriver = null;

      lapTimeChartInstance.on('mouseover', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          const hoveredDriver = params.seriesName.split(' - ')[0];

          if (currentHoveredDriver === hoveredDriver) return;
          currentHoveredDriver = hoveredDriver;

          const driverSeriesIndices = seriesIndexByDriver.get(hoveredDriver) || [];

          const updatedSeries = series.map((s, idx) => {
            if (idx >= driverSeriesCount) return {};

            if (driverSeriesIndices.includes(idx)) {
              return {
                lineStyle: { width: 3, color: s.lineStyle.color, opacity: 1 },
                itemStyle: { ...s.itemStyle, opacity: 1 },
                endLabel: { ...s.endLabel, opacity: 1 }
              };
            } else {
              return {
                lineStyle: { width: 2, color: s.lineStyle.color, opacity: 0.15 },
                itemStyle: { ...s.itemStyle, opacity: 0.05 },
                endLabel: { ...s.endLabel, opacity: 0.15 }
              };
            }
          });

          lapTimeChartInstance.setOption({ series: updatedSeries });
        }
      });

      lapTimeChartInstance.on('mouseout', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          currentHoveredDriver = null;

          const resetSeries = series.map((s, idx) => {
            if (idx >= driverSeriesCount) return {};
            return {
              lineStyle: { width: 2, color: s.lineStyle.color, opacity: 1 },
              itemStyle: { ...s.itemStyle, opacity: 1 },
              endLabel: { ...s.endLabel, opacity: 1 }
            };
          });

          lapTimeChartInstance.setOption({ series: resetSeries });
        }
      });
    }

    // Handle window resize for lap time chart
    window.addEventListener('resize', () => {
      if (lapTimeChartInstance) {
        lapTimeChartInstance.resize();
      }
      if (tyreDegScatterChartInstance) {
        tyreDegScatterChartInstance.resize();
      }
      if (tyreDegLapTimeChartInstance) {
        tyreDegLapTimeChartInstance.resize();
      }
    });

    // Tyre Degradation Panel
    const tyreDegTyreChoicesDisplay = document.getElementById('tyreDegTyreChoicesDisplay');
    const tyreDegTyreChoicesText = document.getElementById('tyreDegTyreChoicesText');
    const tyreDegChartsWrapper = document.getElementById('tyreDegChartsWrapper');
    const tyreDegScatterChart = document.getElementById('tyreDegScatterChart');
    const tyreDegLapTimeChart = document.getElementById('tyreDegLapTimeChart');
    const tyreDegEquationsSection = document.getElementById('tyreDegEquationsSection');
    const tyreDegEquationsGrid = document.getElementById('tyreDegEquationsGrid');
    const tyreDegFuelAdjustToggle = document.getElementById('tyreDegFuelAdjustToggle');
    const tyreDegSelectedStintCount = document.getElementById('tyreDegSelectedStintCount');
    const tyreDegStintsTableContainer = document.getElementById('tyreDegStintsTableContainer');

    let tyreDegScatterChartInstance = null;
    let tyreDegLapTimeChartInstance = null;
    let tyreDegSelectedStints = new Set();
    let tyreDegFilteredGroups = new Map();
    let tyreDegTyreChoices = new Map();

    // Mappings for synchronized hover between charts
    let scatterStintToPoint = new Map(); // stint key -> {seriesIndex, dataIndex} in scatter chart
    let lapTimeStintToSeriesIndex = new Map(); // stint key -> series index in lap time chart

    // Dropdown menu tracking
    let activeTyreDegDropdown = null;
    let activeTyreDegDropdownColumn = null;

    // Load tyre choices
    function loadTyreDegTyreChoices() {
      ParsedDataCache.loadCSV("tyre_choices.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.data) {
            results.data.forEach(row => {
              const year = String(row.year || "").trim();
              const round = String(row.round_no || "").trim();
              if (year && round) {
                const key = `${year}||${round}`;
                tyreDegTyreChoices.set(key, {
                  hard: String(row.hard || "").trim(),
                  medium: String(row.medium || "").trim(),
                  soft: String(row.soft || "").trim()
                });
              }
            });
          }
        },
        error: function (err) {
          console.error("Error loading tyre_choices.csv:", err);
        }
      });
    }

    loadTyreDegTyreChoices();

    // Set up filter listeners for tyre deg panel
    function setupTyreDegFilterListeners() {
      const filterIds = [
        'tyreDegFilterMinLap', 'tyreDegFilterEndLaps', 'tyreDegFilterMinDist',
        'tyreDegFilterMinRows', 'tyreDegFilterMinCorr', 'tyreDegFilterRainfall',
        'tyreDegFilterSafetyCar', 'tyreDegFilterPitLaps', 'tyreDegFilterIncludeLapped',
        'tyreDegFilterIncludeRetired'
      ];

      filterIds.forEach(id => {
        const el = document.getElementById(id);
        if (el) {
          const eventType = el.type === 'checkbox' ? 'change' : 'input';
          el.addEventListener(eventType, () => {
            if (currentSessionData && currentSessionData.length > 0) {
              processTyreDegData(currentSessionData);
            }
          });
        }
      });

      // Fuel effect slider
      const slider = document.getElementById('tyreDegFuelEffectSlider');
      const value = document.getElementById('tyreDegFuelEffectValue');
      slider.addEventListener('input', function() {
        value.textContent = parseFloat(this.value).toFixed(3);
        if (currentSessionData && currentSessionData.length > 0) {
          processTyreDegData(currentSessionData);
        }
      });

      // Fuel adjust toggle for lap time chart
      tyreDegFuelAdjustToggle.addEventListener('click', function() {
        this.classList.toggle('active');
        renderTyreDegLapTimeChart();
      });
    }

    setupTyreDegFilterListeners();

    // Set up document-level click listener for closing dropdowns
    document.addEventListener('click', function(e) {
      if (activeTyreDegDropdown && !e.target.closest('.clickable-header') && !e.target.closest('.header-dropdown')) {
        activeTyreDegDropdown.remove();
        activeTyreDegDropdown = null;
        activeTyreDegDropdownColumn = null;
      }
    });

    function applyTyreDegFilters(rows) {
      const lapsToDiscard = parseInt(document.getElementById('tyreDegFilterMinLap').value) || 0;
      const minLap = lapsToDiscard + 1;
      const endLaps = parseInt(document.getElementById('tyreDegFilterEndLaps').value) || 0;
      const minDist = parseFloat(document.getElementById('tyreDegFilterMinDist').value) || 0;
      const includeRainfall = document.getElementById('tyreDegFilterRainfall').checked;
      const includeSafetyCar = document.getElementById('tyreDegFilterSafetyCar').checked;
      const includePitLaps = document.getElementById('tyreDegFilterPitLaps').checked;
      const includeLapped = document.getElementById('tyreDegFilterIncludeLapped').checked;
      const includeRetired = document.getElementById('tyreDegFilterIncludeRetired').checked;

      return rows.filter(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap) return false;

        const schedLaps = parseInt(r.sched_laps);
        if (!isNaN(schedLaps)) {
          const maxLap = schedLaps - endLaps;
          if (lapNum > maxLap) return false;
        }

        const status = String(r.finish_status ?? "").trim();
        const plusLapsMatch = status.match(/^\+(\d+)\sLaps$/);
        const lapsBehind = plusLapsMatch ? Number(plusLapsMatch[1]) : 0;
        if (lapsBehind > 1) return false;

        const isLapped = status === "Lapped" || status === "+1 Lap";
        if (!includeLapped && isLapped) return false;

        const isFinished = status === "Finished" || isLapped;
        const isRetired = !isFinished;
        if (!includeRetired && isRetired) return false;

        if (!includeRainfall) {
          const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
          if (rainfall === "true" || rainfall === "1") return false;
        }

        if (!includeSafetyCar) {
          const trackStatus = String(r.lap_TrackStatus || "").trim();
          if (trackStatus.includes("4") || trackStatus.includes("5") ||
              trackStatus.includes("6") || trackStatus.includes("7")) {
            return false;
          }
        }

        if (!includePitLaps) {
          const pitIn = String(r.lap_PitInTime || "").trim();
          const pitOut = String(r.lap_PitOutTime || "").trim();
          if ((pitIn && pitIn.toLowerCase() !== "na" && pitIn !== "") ||
              (pitOut && pitOut.toLowerCase() !== "na" && pitOut !== "")) {
            return false;
          }
        }

        const dist = parseFloat(r.min_dist);
        if (!isNaN(dist) && dist < minDist) return false;

        return true;
      });
    }

    function processTyreDegData(sessionData) {
      const filteredRows = applyTyreDegFilters(sessionData);

      // Group by driver and stint
      const groups = new Map();

      filteredRows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const stint = String(r.lap_Stint || "").trim();
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const sessionType = String(r.session_type || "").trim();

        if (!driver || !stint) return;

        const key = `${year}||${round}||${meeting}||${driver}||${sessionType}||${stint}`;

        if (!groups.has(key)) {
          groups.set(key, {
            lap_Driver: driver,
            event: `${year} - ${round}. ${meeting}`,
            session_type: sessionType,
            lap_Stint: stint,
            rows: []
          });
        }

        groups.get(key).rows.push(r);
      });

      // Calculate regression for each group
      const minRows = parseInt(document.getElementById('tyreDegFilterMinRows').value) || 5;
      const minCorr = parseFloat(document.getElementById('tyreDegFilterMinCorr').value) || -1.0;

      // Track previous stints
      const previousStints = new Set(window.tyreDegPreviousFilteredStints || []);
      const isEventChange = previousStints.size === 0 && groups.size > 0;

      tyreDegFilteredGroups = new Map();

      groups.forEach((group, key) => {
        if (group.rows.length >= minRows) {
          group.regressionStats = calculateRegressionStats(group.rows);

          if (group.regressionStats.correlation >= minCorr) {
            // Calculate additional fields
            const tyreLifeValues = group.rows.map(r => parseFloat(r.lap_TyreLife)).filter(v => !isNaN(v));
            const lapNumberValues = group.rows.map(r => parseFloat(r.lap_LapNumber)).filter(v => !isNaN(v));
            const schedLapsValue = parseInt(group.rows[0]?.sched_laps);

            group.minTyreLife = tyreLifeValues.length > 0 ? Math.min(...tyreLifeValues) : 0;
            const minLapNum = lapNumberValues.length > 0 ? Math.min(...lapNumberValues) : 0;
            group.lapsToGo = !isNaN(schedLapsValue) && schedLapsValue > 0 ? schedLapsValue - minLapNum : 0;
            group.compound = group.rows[0]?.lap_Compound || '-';
            group.finishStatus = group.rows[0]?.finish_status || '-';
            group.schedLaps = schedLapsValue || '-';

            tyreDegFilteredGroups.set(key, group);
          }
        }
      });

      // Handle stint selection on event change
      if (isEventChange) {
        // Event changed - select all stints
        tyreDegSelectedStints.clear();
        tyreDegFilteredGroups.forEach((group, key) => {
          tyreDegSelectedStints.add(key);
        });
      } else {
        // Filter changed - maintain selection only for stints that were in previous view
        const stintsToKeep = new Set();
        tyreDegSelectedStints.forEach(key => {
          if (tyreDegFilteredGroups.has(key) && previousStints.has(key)) {
            stintsToKeep.add(key);
          }
        });
        tyreDegSelectedStints.clear();
        stintsToKeep.forEach(key => tyreDegSelectedStints.add(key));
      }

      // Store current stints for next comparison
      window.tyreDegPreviousFilteredStints = Array.from(tyreDegFilteredGroups.keys());

      // Render table and charts
      renderTyreDegStintsTable();
      renderTyreDegScatterChart();
      renderTyreDegLapTimeChart();
    }

    function calculateRegressionStats(rows) {
      // Simplified regression calculation
      // In production, would use simple-statistics library
      const pairs = rows.map(r => {
        const tyreLife = parseInt(r.lap_TyreLife);
        const lapTime = parseFloat(r.lap_LapTime);
        return { x: tyreLife, y: lapTime };
      }).filter(p => !isNaN(p.x) && !isNaN(p.y));

      if (pairs.length < 2) {
        return { slope: '-', intercept: '-', correlation: 0, rmse: '-' };
      }

      // Simple linear regression calculation
      const n = pairs.length;
      const sumX = pairs.reduce((sum, p) => sum + p.x, 0);
      const sumY = pairs.reduce((sum, p) => sum + p.y, 0);
      const sumXY = pairs.reduce((sum, p) => sum + p.x * p.y, 0);
      const sumX2 = pairs.reduce((sum, p) => sum + p.x * p.x, 0);
      const sumY2 = pairs.reduce((sum, p) => sum + p.y * p.y, 0);

      const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
      const intercept = (sumY - slope * sumX) / n;

      const correlation = (n * sumXY - sumX * sumY) /
        Math.sqrt((n * sumX2 - sumX * sumX) * (n * sumY2 - sumY * sumY));

      // Calculate RMSE (Root Mean Square Error)
      let sumSquaredErrors = 0;
      pairs.forEach(p => {
        const predicted = slope * p.x + intercept;
        const error = p.y - predicted;
        sumSquaredErrors += error * error;
      });
      const rmse = Math.sqrt(sumSquaredErrors / n);

      return {
        slope: isFinite(slope) ? slope.toFixed(4) : '-',
        intercept: isFinite(intercept) ? intercept.toFixed(3) : '-',
        correlation: isFinite(correlation) ? correlation : 0,
        rmse: isFinite(rmse) ? rmse.toFixed(4) : '-'
      };
    }

    function renderTyreDegStintsTable() {
      if (tyreDegFilteredGroups.size === 0) {
        tyreDegStintsTableContainer.innerHTML = `
          <p style="color: var(--muted-color); padding: 20px; text-align: center;">
            No stints match the current filters
          </p>
        `;
        tyreDegChartsWrapper.style.display = 'none';
        return;
      }

      tyreDegChartsWrapper.style.display = 'grid';

      const fuelEffect = parseFloat(document.getElementById('tyreDegFuelEffectSlider').value) || 0;

      const table = document.createElement('table');
      table.id = 'tyreDegStintsTable';

      // Header row
      const thead = document.createElement('thead');
      const headerRow = document.createElement('tr');

      const headers = [
        { text: 'Select', isCheckbox: true },
        { text: 'Event' },
        { text: 'Driver', clickable: true, column: 'driver' },
        { text: 'Session Type', clickable: true, column: 'session_type' },
        { text: 'Stint' },
        { text: 'Lap Count' },
        { text: 'Sched Laps' },
        { text: 'Compound', clickable: true, column: 'compound' },
        { text: 'Finish Status' },
        { text: 'Min Tyre Life' },
        { text: 'Laps to Go' },
        { text: 'Deg' },
        { text: 'Pace' },
        { text: 'Correlation' },
        { text: 'RMSE' }
      ];

      headers.forEach(header => {
        const th = document.createElement('th');

        if (header.isCheckbox) {
          const checkbox = document.createElement('input');
          checkbox.type = 'checkbox';
          checkbox.id = 'tyreDegSelectAllCheckbox';
          checkbox.className = 'stint-checkbox';
          th.appendChild(checkbox);
        } else if (header.clickable) {
          th.textContent = header.text;
          th.className = 'clickable-header';
          th.dataset.column = header.column;
        } else {
          th.textContent = header.text;
        }

        headerRow.appendChild(th);
      });

      thead.appendChild(headerRow);
      table.appendChild(thead);

      // Body
      const tbody = document.createElement('tbody');

      // Sort by compound, then driver, then session type, then stint
      const sortedGroups = Array.from(tyreDegFilteredGroups.entries()).sort((a, b) => {
        const [keyA, groupA] = a;
        const [keyB, groupB] = b;

        // Sort by compound first
        if (groupA.compound !== groupB.compound) {
          return groupA.compound.localeCompare(groupB.compound);
        }

        // Then by driver
        if (groupA.lap_Driver !== groupB.lap_Driver) {
          return groupA.lap_Driver.localeCompare(groupB.lap_Driver);
        }

        // Then by session type
        if (groupA.session_type !== groupB.session_type) {
          return groupA.session_type.localeCompare(groupB.session_type);
        }

        // Finally by stint
        return parseInt(groupA.lap_Stint) - parseInt(groupB.lap_Stint);
      });

      sortedGroups.forEach(([key, group]) => {
        const tr = document.createElement('tr');
        if (tyreDegSelectedStints.has(key)) {
          tr.classList.add('stint-selected');
        }

        // Select checkbox
        const tdCheckbox = document.createElement('td');
        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.className = 'stint-checkbox';
        checkbox.checked = tyreDegSelectedStints.has(key);
        checkbox.addEventListener('change', () => {
          if (checkbox.checked) {
            tyreDegSelectedStints.add(key);
            tr.classList.add('stint-selected');
          } else {
            tyreDegSelectedStints.delete(key);
            tr.classList.remove('stint-selected');
          }
          renderTyreDegScatterChart();
          renderTyreDegLapTimeChart();
        });
        tdCheckbox.appendChild(checkbox);
        tr.appendChild(tdCheckbox);

        // Event
        const tdEvent = document.createElement('td');
        tdEvent.textContent = group.event;
        tr.appendChild(tdEvent);

        // Driver
        const tdDriver = document.createElement('td');
        tdDriver.textContent = group.lap_Driver;
        tr.appendChild(tdDriver);

        // Session Type
        const tdSessionType = document.createElement('td');
        tdSessionType.textContent = group.session_type;
        tr.appendChild(tdSessionType);

        // Stint
        const tdStint = document.createElement('td');
        tdStint.textContent = group.lap_Stint;
        tr.appendChild(tdStint);

        // Lap Count
        const tdLapCount = document.createElement('td');
        tdLapCount.textContent = group.rows.length;
        tr.appendChild(tdLapCount);

        // Sched Laps
        const tdSchedLaps = document.createElement('td');
        tdSchedLaps.textContent = group.schedLaps;
        tr.appendChild(tdSchedLaps);

        // Compound
        const tdCompound = document.createElement('td');
        tdCompound.textContent = group.compound;
        tdCompound.style.color = getF1TireColor(group.compound);
        tdCompound.style.fontWeight = '600';
        tr.appendChild(tdCompound);

        // Finish Status
        const tdFinishStatus = document.createElement('td');
        tdFinishStatus.textContent = group.finishStatus;
        tr.appendChild(tdFinishStatus);

        // Min Tyre Life
        const tdMinTyreLife = document.createElement('td');
        tdMinTyreLife.textContent = group.minTyreLife;
        tr.appendChild(tdMinTyreLife);

        // Laps to Go
        const tdLapsToGo = document.createElement('td');
        tdLapsToGo.textContent = group.lapsToGo;
        tr.appendChild(tdLapsToGo);

        // Deg (with fuel effect adjustment)
        const tdDeg = document.createElement('td');
        const deg = parseFloat(group.regressionStats.slope);
        const degAdj = deg + fuelEffect;
        tdDeg.textContent = isNaN(degAdj) ? group.regressionStats.slope : degAdj.toFixed(4);
        tr.appendChild(tdDeg);

        // Pace (with fuel effect adjustment)
        const tdPace = document.createElement('td');
        const pace = parseFloat(group.regressionStats.intercept);
        const minTyreLife = group.minTyreLife || 0;
        const lapsToGo = group.lapsToGo || 0;
        const paceAdj = pace - (minTyreLife + lapsToGo) * fuelEffect;
        tdPace.textContent = isNaN(paceAdj) ? group.regressionStats.intercept : paceAdj.toFixed(4);
        tr.appendChild(tdPace);

        // Correlation
        const tdCorrelation = document.createElement('td');
        tdCorrelation.textContent = typeof group.regressionStats.correlation === 'number'
          ? group.regressionStats.correlation.toFixed(3)
          : group.regressionStats.correlation;
        tr.appendChild(tdCorrelation);

        // RMSE
        const tdRMSE = document.createElement('td');
        tdRMSE.textContent = group.regressionStats.rmse;
        tr.appendChild(tdRMSE);

        // Click row to toggle selection
        tr.style.cursor = 'pointer';
        tr.addEventListener('click', (e) => {
          if (e.target !== checkbox) {
            checkbox.checked = !checkbox.checked;
            checkbox.dispatchEvent(new Event('change'));
          }
        });

        tbody.appendChild(tr);
      });

      table.appendChild(tbody);
      tyreDegStintsTableContainer.innerHTML = '';
      tyreDegStintsTableContainer.appendChild(table);

      // Attach select all checkbox listener
      const selectAllCheckbox = document.getElementById('tyreDegSelectAllCheckbox');
      if (selectAllCheckbox) {
        selectAllCheckbox.addEventListener('change', function() {
          if (this.checked) {
            // Select all visible stints
            tyreDegFilteredGroups.forEach((group, key) => {
              tyreDegSelectedStints.add(key);
            });
          } else {
            // Deselect all visible stints
            tyreDegFilteredGroups.forEach((group, key) => {
              tyreDegSelectedStints.delete(key);
            });
          }
          renderTyreDegStintsTable();
          renderTyreDegScatterChart();
          renderTyreDegLapTimeChart();
        });

        // Update select all checkbox state
        let visibleSelectedCount = 0;
        tyreDegFilteredGroups.forEach((group, key) => {
          if (tyreDegSelectedStints.has(key)) visibleSelectedCount++;
        });

        selectAllCheckbox.checked = tyreDegFilteredGroups.size > 0 &&
          visibleSelectedCount === tyreDegFilteredGroups.size;
        selectAllCheckbox.indeterminate = visibleSelectedCount > 0 &&
          visibleSelectedCount < tyreDegFilteredGroups.size;
      }

      // Attach clickable header listeners
      attachTyreDegHeaderDropdownListeners();
    }

    function attachTyreDegHeaderDropdownListeners() {
      document.querySelectorAll('#tyreDegStintsTable .clickable-header').forEach(header => {
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);

        newHeader.addEventListener('click', function(e) {
          e.stopPropagation();

          const column = this.dataset.column;

          // Toggle: if clicking same header, close dropdown
          if (activeTyreDegDropdown && activeTyreDegDropdownColumn === column) {
            activeTyreDegDropdown.remove();
            activeTyreDegDropdown = null;
            activeTyreDegDropdownColumn = null;
            return;
          }

          // Close any existing dropdown
          if (activeTyreDegDropdown) {
            activeTyreDegDropdown.remove();
            activeTyreDegDropdown = null;
          }

          const table = this.closest('table');
          const tableRect = table.getBoundingClientRect();
          const headerRect = this.getBoundingClientRect();

          // Get unique values for this column
          const uniqueValues = new Set();
          tyreDegFilteredGroups.forEach((group, key) => {
            if (column === 'driver') {
              uniqueValues.add(group.lap_Driver);
            } else if (column === 'session_type') {
              uniqueValues.add(group.session_type);
            } else if (column === 'compound') {
              uniqueValues.add(group.compound);
            }
          });

          // Create dropdown
          const dropdown = document.createElement('div');
          dropdown.className = 'header-dropdown show';

          // Position relative to the header
          dropdown.style.left = `${headerRect.left - tableRect.left}px`;
          dropdown.style.top = `${headerRect.bottom - tableRect.top}px`;

          // Add options
          Array.from(uniqueValues).sort().forEach(value => {
            const option = document.createElement('div');
            option.className = 'dropdown-option';

            const label = document.createElement('span');
            label.className = 'dropdown-option-label';
            label.textContent = value;

            const buttons = document.createElement('div');
            buttons.className = 'dropdown-option-buttons';

            const selectBtn = document.createElement('button');
            selectBtn.className = 'dropdown-btn';
            selectBtn.textContent = 'Select';
            selectBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              selectTyreDegByValue(column, value, true);
            });

            const deselectBtn = document.createElement('button');
            deselectBtn.className = 'dropdown-btn';
            deselectBtn.textContent = 'Clear';
            deselectBtn.addEventListener('click', function(e) {
              e.stopPropagation();
              selectTyreDegByValue(column, value, false);
            });

            buttons.appendChild(selectBtn);
            buttons.appendChild(deselectBtn);

            option.appendChild(label);
            option.appendChild(buttons);
            dropdown.appendChild(option);
          });

          table.appendChild(dropdown);
          activeTyreDegDropdown = dropdown;
          activeTyreDegDropdownColumn = column;
        });
      });
    }

    function selectTyreDegByValue(column, value, select) {
      tyreDegFilteredGroups.forEach((group, key) => {
        let matches = false;

        if (column === 'driver' && group.lap_Driver === value) {
          matches = true;
        } else if (column === 'session_type' && group.session_type === value) {
          matches = true;
        } else if (column === 'compound' && group.compound === value) {
          matches = true;
        }

        if (matches) {
          if (select) {
            tyreDegSelectedStints.add(key);
          } else {
            tyreDegSelectedStints.delete(key);
          }
        }
      });

      // Close the dropdown
      if (activeTyreDegDropdown) {
        activeTyreDegDropdown.remove();
        activeTyreDegDropdown = null;
        activeTyreDegDropdownColumn = null;
      }

      // Refresh table and charts
      renderTyreDegStintsTable();
      renderTyreDegScatterChart();
      renderTyreDegLapTimeChart();
    }

    function renderTyreDegScatterChart() {
      if (!tyreDegScatterChartInstance) {
        tyreDegScatterChartInstance = echarts.init(tyreDegScatterChart);
      }

      if (tyreDegSelectedStints.size === 0) {
        tyreDegScatterChartInstance.clear();
        tyreDegEquationsSection.style.display = 'none';
        return;
      }

      const fuelEffect = parseFloat(document.getElementById('tyreDegFuelEffectSlider').value) || 0;

      // Prepare data grouped by compound - only for selected stints
      const datasets = new Map();
      const equations = new Map();

      tyreDegSelectedStints.forEach(key => {
        const group = tyreDegFilteredGroups.get(key);
        if (!group) return;

        const compound = group.compound;
        const stats = group.regressionStats;

        if (stats && stats.slope !== '-' && stats.intercept !== '-') {
          const deg = parseFloat(stats.slope);
          const pace = parseFloat(stats.intercept);

          // Apply fuel effect adjustments
          const minTyreLife = group.minTyreLife || 0;
          const lapsToGo = group.lapsToGo || 0;
          const degAdj = deg + fuelEffect;
          const paceAdj = pace - (minTyreLife + lapsToGo) * fuelEffect;

          if (!isNaN(paceAdj) && !isNaN(degAdj)) {
            if (!datasets.has(compound)) {
              datasets.set(compound, []);
            }

            datasets.get(compound).push({
              value: [paceAdj, degAdj],
              label: `${group.lap_Driver} - ${group.event}`,
              stintKey: key
            });
          }
        }
      });

      // Create series for scatter plot and build mapping
      const series = [];
      scatterStintToPoint.clear();
      let seriesIndex = 0;

      datasets.forEach((points, compound) => {
        const color = getF1TireColor(compound);

        // Store stint key to point mapping
        points.forEach((p, dataIndex) => {
          if (p.stintKey) {
            scatterStintToPoint.set(p.stintKey, { seriesIndex, dataIndex });
          }
        });

        series.push({
          name: compound,
          type: 'scatter',
          data: points,
          symbolSize: 8,
          itemStyle: {
            color: color,
            borderColor: color,
            borderWidth: 0
          },
          emphasis: {
            focus: 'self',
            blurScope: 'global',
            itemStyle: {
              borderWidth: 3,
              shadowBlur: 15,
              shadowColor: color
            },
            scale: 1.5
          },
          blur: {
            itemStyle: { opacity: 0.15 }
          }
        });

        seriesIndex++;

        // Calculate best fit line for this compound
        if (points.length >= 2) {
          const xVals = points.map(p => p.value[0]);
          const yVals = points.map(p => p.value[1]);

          const n = points.length;
          const sumX = xVals.reduce((a, b) => a + b, 0);
          const sumY = yVals.reduce((a, b) => a + b, 0);
          const sumXY = xVals.reduce((sum, x, i) => sum + x * yVals[i], 0);
          const sumX2 = xVals.reduce((sum, x) => sum + x * x, 0);

          const slope = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX * sumX);
          const intercept = (sumY - slope * sumX) / n;

          if (isFinite(slope) && isFinite(intercept)) {
            equations.set(compound, { slope, intercept, color });

            const minX = Math.min(...xVals);
            const maxX = Math.max(...xVals);
            const lineData = [
              [minX, slope * minX + intercept],
              [maxX, slope * maxX + intercept]
            ];

            series.push({
              type: 'line',
              data: lineData,
              lineStyle: {
                color: color,
                width: 2,
                type: 'dashed'
              },
              symbol: 'none',
              emphasis: { disabled: true },
              blur: { lineStyle: { opacity: 0.15 } },
              silent: true,
              animation: false,
              zlevel: -1
            });
          }
        }
      });

      const option = {
        backgroundColor: 'transparent',
        grid: { left: 60, right: 40, top: 40, bottom: 60 },
        legend: {
          show: true,
          top: 10,
          textStyle: { color: '#8b8b8b', fontSize: 10 }
        },
        tooltip: {
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          formatter: (p) => {
            if (p.data.label) {
              return `
                <strong>${p.seriesName}</strong><br/>
                ${p.data.label}<br/>
                Pace: ${p.data.value[0].toFixed(3)}s<br/>
                Deg: ${p.data.value[1].toFixed(4)}s/lap
              `;
            }
            return '';
          }
        },
        xAxis: {
          type: 'value',
          name: 'Pace (s)',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af', formatter: v => v.toFixed(1) },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true
        },
        yAxis: {
          type: 'value',
          name: 'Degradation (s/lap)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af', formatter: v => v.toFixed(3) },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } }
        },
        series: series
      };

      tyreDegScatterChartInstance.setOption(option, true);
      tyreDegScatterChartInstance.resize();

      // Remove old event listeners
      tyreDegScatterChartInstance.off('mouseover');
      tyreDegScatterChartInstance.off('mouseout');

      // Add cross-chart interaction for scatter -> lap time
      tyreDegScatterChartInstance.on('mouseover', { seriesType: 'scatter' }, (params) => {
        if (params.data && params.data.stintKey && tyreDegLapTimeChartInstance) {
          const stintKey = params.data.stintKey;
          const lapTimeSeriesIndex = lapTimeStintToSeriesIndex.get(stintKey);
          if (lapTimeSeriesIndex !== undefined) {
            tyreDegLapTimeChartInstance.dispatchAction({
              type: 'highlight',
              seriesIndex: lapTimeSeriesIndex
            });
          }
        }
      });

      tyreDegScatterChartInstance.on('mouseout', { seriesType: 'scatter' }, (params) => {
        if (tyreDegLapTimeChartInstance) {
          tyreDegLapTimeChartInstance.dispatchAction({ type: 'downplay' });
        }
      });

      // Display best fit equations
      renderTyreDegEquations(equations);
    }

    function renderTyreDegEquations(equations) {
      if (equations.size === 0) {
        tyreDegEquationsSection.style.display = 'none';
        return;
      }

      tyreDegEquationsGrid.innerHTML = '';
      equations.forEach(({ slope, intercept, color }, compound) => {
        const equation = document.createElement('div');
        equation.className = 'equation-item';
        equation.style.borderLeftColor = color;
        equation.textContent = `${compound}: Deg = ${slope.toFixed(4)} × Pace + ${intercept.toFixed(4)}`;
        tyreDegEquationsGrid.appendChild(equation);
      });

      tyreDegEquationsSection.style.display = 'block';
    }

    function renderTyreDegLapTimeChart() {
      if (!tyreDegLapTimeChartInstance) {
        tyreDegLapTimeChartInstance = echarts.init(tyreDegLapTimeChart);
      }

      if (tyreDegSelectedStints.size === 0) {
        tyreDegLapTimeChartInstance.clear();
        tyreDegSelectedStintCount.textContent = 'No stints selected';
        return;
      }

      const fuelAdjusted = tyreDegFuelAdjustToggle.classList.contains('active');
      const fuelEffect = parseFloat(document.getElementById('tyreDegFuelEffectSlider').value) || 0;

      const series = [];
      lapTimeStintToSeriesIndex.clear();
      let stintCount = 0;
      let seriesIndex = 0;

      tyreDegSelectedStints.forEach(key => {
        const group = tyreDegFilteredGroups.get(key);
        if (!group) return;

        const compound = group.rows[0]?.lap_Compound || 'UNKNOWN';
        const driver = group.lap_Driver;
        const color = getF1TireColor(compound);

        const data = group.rows.map(r => {
          const tyreLife = parseInt(r.lap_TyreLife);
          let lapTime = parseFloat(r.lap_LapTime);

          if (fuelAdjusted && !isNaN(r.sched_laps)) {
            const lapNum = parseInt(r.lap_LapNumber);
            const schedLaps = parseInt(r.sched_laps);
            lapTime -= (schedLaps - lapNum) * fuelEffect;
          }

          return {
            value: [tyreLife, lapTime],
            driver: driver,
            compound: compound
          };
        }).filter(p => !isNaN(p.value[0]) && !isNaN(p.value[1]));

        if (data.length > 0) {
          // Store mapping for this stint
          lapTimeStintToSeriesIndex.set(key, seriesIndex);

          series.push({
            name: `${driver} ${compound}`,
            type: 'line',
            data: data,
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: color, opacity: 0.95 },
            itemStyle: { color: color, borderWidth: 0 },
            emphasis: {
              focus: 'series',
              blurScope: 'global',
              lineStyle: { width: 3.2 },
              scale: true
            },
            blur: { lineStyle: { opacity: 0.1 } },
            animation: false,
            stintKey: key,  // Store stint key for reference
            triggerLineEvent: true  // Enable line hover events
          });
          stintCount++;
          seriesIndex++;
        }
      });

      tyreDegSelectedStintCount.textContent = `${stintCount} stint${stintCount !== 1 ? 's' : ''} selected`;

      const option = {
        backgroundColor: 'transparent',
        grid: { left: 60, right: 40, top: 20, bottom: 60 },
        legend: { show: false },
        tooltip: {
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          formatter: (p) => {
            const data = p.data;
            return `
              <strong>${data.driver}</strong><br/>
              Tyre Life: ${data.value[0]} laps<br/>
              Lap Time: ${data.value[1].toFixed(3)}s<br/>
              Compound: ${data.compound}
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Tyre Life (laps)',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          min: 0
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af', formatter: v => v.toFixed(1) },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true
        },
        series: series
      };

      tyreDegLapTimeChartInstance.setOption(option, true);
      tyreDegLapTimeChartInstance.resize();

      // Remove old event listeners
      tyreDegLapTimeChartInstance.off('mouseover');
      tyreDegLapTimeChartInstance.off('mouseout');
      tyreDegLapTimeChartInstance.off('highlight');
      tyreDegLapTimeChartInstance.off('downplay');

      // Listen to both mouseover (for line/point hover) and highlight (for programmatic emphasis)
      const handleLapTimeHover = (params) => {
        if (params.seriesIndex !== undefined && series[params.seriesIndex]) {
          const stintKey = series[params.seriesIndex].stintKey;
          if (stintKey && tyreDegScatterChartInstance) {
            const scatterPoint = scatterStintToPoint.get(stintKey);
            if (scatterPoint) {
              // Highlight single data point on scatter plot
              tyreDegScatterChartInstance.dispatchAction({
                type: 'highlight',
                seriesIndex: scatterPoint.seriesIndex,
                dataIndex: scatterPoint.dataIndex
              });
            }
          }
        }
      };

      tyreDegLapTimeChartInstance.on('mouseover', handleLapTimeHover);
      tyreDegLapTimeChartInstance.on('highlight', handleLapTimeHover);

      tyreDegLapTimeChartInstance.on('mouseout', (params) => {
        if (tyreDegScatterChartInstance) {
          tyreDegScatterChartInstance.dispatchAction({ type: 'downplay' });
        }
      });

      tyreDegLapTimeChartInstance.on('downplay', (params) => {
        if (tyreDegScatterChartInstance) {
          tyreDegScatterChartInstance.dispatchAction({ type: 'downplay' });
        }
      });
    }

    // Fuel Effect Panel
    // (Will be populated from fuel_effect.html)

    // ============================================================================
    // INITIALIZATION
    // ============================================================================

    init();
  </script>
</body>
</html>
