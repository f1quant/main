<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Strategy Optimizer</title>
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>
  <style>
    :root {
      --bg: #050608;
      --bg-elevated: #11151a;
      --border-subtle: #272b33;
      --accent: #4fd1c5;
      --accent-soft: rgba(79, 209, 197, 0.18);
      --text: #f5f5f5;
      --muted: #a0aec0;
      --error: #f56565;
      --radius: 10px;
      --shadow: 0 10px 30px rgba(0, 0, 0, 0.6);
      --transition-fast: 0.18s ease;
      --font: system-ui, -apple-system, BlinkMacSystemFont, -system-ui, sans-serif;
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      padding: 0;
      background: radial-gradient(circle at top, #111827 0, #050608 40%, #000 100%);
      color: var(--text);
      font-family: var(--font);
      line-height: 1.4;
      overflow: hidden; /* layout uses internal scrolls */
    }

    .top-nav {
      background: #0a0c14;
      border-bottom: 1px solid var(--border-subtle);
      padding: 0;
      display: flex;
      justify-content: flex-start;
      position: sticky;
      top: 0;
      z-index: 1000;
    }

    .top-nav a {
      color: var(--muted);
      text-decoration: none;
      padding: 12px 24px;
      font-size: 13px;
      font-weight: 500;
      transition: all var(--transition-fast);
      border-bottom: 2px solid transparent;
    }

    .top-nav a:hover {
      color: var(--text);
      background: rgba(79, 209, 197, 0.05);
    }

    .top-nav a.active {
      color: var(--accent);
      border-bottom-color: var(--accent);
    }

    .page-wrapper {
      padding: 10px 20px 16px;
    }

    h1, h2, h3 {
      margin: 0.35em 0 0.3em;
      font-weight: 500;
    }

    h1 {
      font-size: 1.9rem;
      letter-spacing: 0.03em;
    }

    h4 {
      margin: 0 0 6px;
      font-weight: 500;
      color: var(--muted);
      font-size: 0.95rem;
    }

    .subtitle {
      margin-bottom: 8px;
      color: var(--muted);
      font-size: 0.9rem;
    }

    .config-header {
      margin-bottom: 8px;
    }

    .config-select {
      background: var(--bg-elevated);
      color: var(--text);
      border: 1px solid var(--border-subtle);
      padding: 8px 14px;
      border-radius: 6px;
      font-size: 0.95rem;
      cursor: pointer;
      min-width: 200px;
    }

    .config-select:hover {
      border-color: var(--accent);
    }

    /* Layout: inputs left, outputs right */

    .layout {
      display: flex;
      gap: 16px;
      align-items: flex-start;
      height: calc(100vh - 40px); /* tighter under header */
    }

    .left-pane,
    .right-pane {
      background: transparent;
      min-width: 0;
    }

    .left-pane {
      flex: 0 0 42%;
      max-height: 100%;
      overflow-y: auto;
      padding-right: 2px;
    }

    .right-pane {
      flex: 1 1 58%;
      max-height: 100%;
      overflow-y: auto;
      padding-left: 2px;
    }

    @media (max-width: 1080px) {
      body {
        overflow-y: auto;
      }
      .layout {
        flex-direction: column;
        height: auto;
      }
      .left-pane,
      .right-pane {
        max-height: none;
        overflow: visible;
      }
    }

    .section {
      background: radial-gradient(circle at top left, rgba(79,209,197,0.03), transparent 65%) var(--bg-elevated);
      border: 1px solid var(--border-subtle);
      border-radius: var(--radius);
      padding: 10px 12px 12px;
      margin-bottom: 10px;
      box-shadow: var(--shadow);
    }

    .section-header {
      display: flex;
      align-items: baseline;
      gap: 10px;
      margin-bottom: 0;
    }

    .inputs-actions {
      display: flex;
      align-items: flex-end;
      justify-content: space-between;
      gap: 12px;
      margin-bottom: 6px;
    }

    .inputs-actions #runBtn {
      margin-top: 0;
    }

    .small-note {
      font-size: 0.8rem;
      color: var(--muted);
      margin-bottom: 4px;
    }

    .inputs-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 6px 10px;
      margin-bottom: 8px;
      margin-top: 4px;
    }

    .field-label {
      display: block;
      font-size: 0.78rem;
      letter-spacing: 0.09em;
      color: var(--muted);
      margin-bottom: 3px;
    }

    .field-input {
      width: 100%;
      padding: 6px 8px;
      border-radius: 7px;
      border: 1px solid #2d3748;
      background: rgba(7, 11, 17, 0.96);
      color: var(--text);
      font-size: 0.86rem;
      outline: none;
      transition: border-color var(--transition-fast), box-shadow var(--transition-fast), background var(--transition-fast), transform var(--transition-fast);
    }

    .field-input::placeholder {
      color: #4a5568;
    }

    .field-input:focus {
      border-color: var(--accent);
      box-shadow: 0 0 0 1px var(--accent-soft);
      background: #050b12;
      transform: translateY(-1px);
    }

    .field-input[type="number"] {
      -moz-appearance: textfield;
    }
    .field-input::-webkit-outer-spin-button,
    .field-input::-webkit-inner-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }

    table {
      border-collapse: collapse;
      margin-top: 4px;
      width: 100%;
      font-size: 0.78rem;
    }

    th, td {
      border: 1px solid #2d3748;
      padding: 4px 6px;
      text-align: center;
      color: var(--muted);
    }

    th {
      background: #111827;
      font-weight: 500;
      color: #cbd5f5;
    }

    td input.field-input {
      padding: 4px 6px;
      font-size: 0.75rem;
    }

    .compound-table {
      margin-top: 4px;
      margin-bottom: 6px;
    }

    .btn,
    .btn-small {
      border-radius: 999px;
      border: 1px solid var(--accent);
      background: linear-gradient(to right, #111827, #050b12);
      color: var(--accent);
      font-size: 0.78rem;
      padding: 4px 10px;
      cursor: pointer;
      display: inline-flex;
      align-items: center;
      gap: 5px;
      transition: all var(--transition-fast);
    }

    .btn-small {
      padding: 3px 8px;
      font-size: 0.7rem;
    }

    .btn:hover,
    .btn-small:hover {
      background: var(--accent);
      color: #050608;
      box-shadow: 0 0 12px var(--accent-soft);
      transform: translateY(-1px);
    }

    #runBtn {
      padding: 7px 18px;
      font-size: 0.9rem;
      background: linear-gradient(to right, var(--accent), #63b3ed);
      color: #050608;
      border: none;
      box-shadow: 0 8px 18px rgba(0, 0, 0, 0.7);
    }
    #runBtn:hover {
      transform: translateY(-1px);
      box-shadow: 0 11px 26px rgba(0, 0, 0, 0.85);
    }

    .chart {
      width: 100%;
      height: 340px;
      margin-top: 4px;
      border-radius: 10px;
      background: #05070a;
      border: 1px solid #202938;
    }

    .stints-list {
      margin-top: 6px;
      font-size: 0.8rem;
      color: var(--muted);
    }

    .stints-list h3 {
      font-size: 0.9rem;
      margin-bottom: 4px;
      color: #e2e8f0;
    }

    .stints-item {
      margin: 1px 0;
      padding: 2px 6px 3px;
      border-left: 2px solid var(--accent-soft);
      border-radius: 4px;
    }

    .stints-label {
      color: var(--accent);
      font-weight: 500;
      margin-right: 6px;
    }

    .error {
      color: var(--error);
      font-size: 0.8rem;
      margin-top: 5px;
      min-height: 1em;
    }

    /* Strategies + race params layout */

    .strategies-row {
      display: flex;
      gap: 14px;
      align-items: flex-start;
      margin-top: 4px;
      margin-bottom: 10px;
    }

    .strategies-col h3,
    .race-params-col h3 {
      margin: 0 0 4px;
      font-size: 0.9rem;
    }

    .strategy-inputs {
      display: flex;
      flex-direction: column;
      gap: 4px;
      max-width: 180px; /* keeps them narrow */
    }

    .strategy-inputs .field-input {
      width: 100%;
    }

    .race-params-col {
      flex: 1;
    }

    .race-params-list {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }

    .race-param-row {
      display: flex;
      align-items: center;
      gap: 8px;
    }

    .race-param-row .field-label {
      margin: 0;
      font-size: 0.75rem;
      flex: 0 0 120px; /* adjust as needed */
      text-align: left;
      letter-spacing: 0.06em;
    }

    .race-param-row .field-input {
      flex: 1;
    }

    @media (max-width: 720px) {
      .strategies-row {
        flex-direction: column;
      }
      .strategy-inputs {
        max-width: 100%;
      }
    }

  </style>
</head>
<body>
  <div class="page-wrapper">
  <div class="config-header">
    <select id="configSelect" class="config-select">
      <option value="">Load Config...</option>
    </select>
  </div>
  <div class="layout">
    <!-- LEFT: INPUTS -->
    <div class="left-pane">
      <div class="section">
        <div id="errorBox" class="error"></div>

        <div class="inputs-actions">
          <div class="section-header">
            <h2>Inputs</h2>
            <div class="small-note">Adjust parameters, then Run to recompute.</div>
          </div>
          <button id="runBtn" type="button">Run</button>
        </div>

        <div class="strategies-row">
          <div class="strategies-col">
            <h3>Strategies Of Interest</h3>
            <div id="strategyInputs" class="strategy-inputs">
              <input type="text" class="field-input strategyInput" />
              <input type="text" class="field-input strategyInput" />
              <input type="text" class="field-input strategyInput" />
              <input type="text" class="field-input strategyInput" />
              <input type="text" class="field-input strategyInput" />
            </div>
          </div>

          <div class="race-params-col">
            <h3>Race Parameters</h3>
            <div class="race-params-list">
              <div class="race-param-row">
                <span class="field-label">Num laps</span>
                <input type="number" id="numLaps" class="field-input" min="1" />
              </div>
              <div class="race-param-row">
                <span class="field-label">Pit loss (s)</span>
                <input type="number" id="pitLoss" class="field-input" step="0.1" />
              </div>
              <div class="race-param-row">
                <span class="field-label">SC length (laps)</span>
                <input type="number" id="scLength" class="field-input" min="1" />
              </div>
              <div class="race-param-row">
                <span class="field-label">Fuel Effect (s/lap)</span>
                <input type="number" id="fuelEffect" class="field-input" step="0.001" />
              </div>
            </div>
          </div>
        </div>

        <table class="compound-table">
          <thead>
            <tr>
              <th>Compound</th>
              <th>Pace (sec)</th>
              <th>Degradation (sec/lap)</th>
            </tr>
          </thead>
          <tbody>
            <tr>
              <td>Softs</td>
              <td><input type="number" id="paceS" class="field-input" step="0.001" /></td>
              <td><input type="number" id="degS" class="field-input" step="0.001" /></td>
            </tr>
            <tr>
              <td>Mediums</td>
              <td><input type="number" id="paceM" class="field-input" step="0.001" /></td>
              <td><input type="number" id="degM" class="field-input" step="0.001" /></td>
            </tr>
            <tr>
              <td>Hards</td>
              <td><input type="number" id="paceH" class="field-input" step="0.001" /></td>
              <td><input type="number" id="degH" class="field-input" step="0.001" /></td>
            </tr>
          </tbody>
        </table>

        <h3>Safety Car Probability</h3>
        <div class="small-note">
          Non-overlapping ranges. Final range must leave "To lap" blank (extends to end).
        </div>
        <table id="scProbTable">
          <thead>
            <tr>
              <th>From lap</th>
              <th>To lap (blank = ∞)</th>
              <th>Probability %</th>
              <th></th>
            </tr>
          </thead>
          <tbody></tbody>
        </table>
        <button type="button" id="addRangeBtn" class="btn-small">+ Add range</button>
      </div>
    </div>

    <!-- RIGHT: OUTPUTS -->
    <div class="right-pane">
      <div class="section">
        <div class="section-header">
          <h2>Strategy Comparison</h2>
          <div class="small-note">
            Bars show total race time Δ vs optimal strategy.
          </div>
        </div>

        <div id="strategyChart" class="chart"></div>
        <div id="strategyStints" class="stints-list"></div>
        <div class="small-note" style="margin-top:6px;">
          <h3>Lap times by strategy. Ignores pit stops and safety cars.</h3>
        </div>
        <div id="lapTimeChart" class="chart" style="height:260px; margin-top:4px;"></div>
      </div>
    </div>
  </div>

  <script>
    const INF = 1e18;

    /* Config loading */
    let configData = {};

    function loadConfigFile() {
      fetch(DataCache.getCSVUrl('strat_calc_config.json'))
        .then(response => response.json())
        .then(data => {
          configData = data;
          populateConfigDropdown();
        })
        .catch(error => {
          console.error('Error loading config file:', error);
        });
    }

    function populateConfigDropdown() {
      const configSelect = document.getElementById('configSelect');
      configSelect.innerHTML = '<option value="">Load Config...</option>';

      Object.keys(configData).forEach(configName => {
        const option = document.createElement('option');
        option.value = configName;
        option.textContent = configName;
        configSelect.appendChild(option);
      });
    }

    function loadConfig(configName) {
      if (!configName || !configData[configName]) return;

      const config = configData[configName];

      // Map config fields to input IDs
      document.getElementById('numLaps').value = config['Num Laps'] || '';
      document.getElementById('pitLoss').value = config['Pit Loss'] || '';
      document.getElementById('scLength').value = config['SC Length'] || '';
      document.getElementById('fuelEffect').value = config['Fuel Effect'] || '';

      // Load compound data
      if (config['Softs']) {
        document.getElementById('paceS').value = config['Softs']['Pace'] || '';
        document.getElementById('degS').value = config['Softs']['Deg'] || '';
      }
      if (config['Mediums']) {
        document.getElementById('paceM').value = config['Mediums']['Pace'] || '';
        document.getElementById('degM').value = config['Mediums']['Deg'] || '';
      }
      if (config['Hards']) {
        document.getElementById('paceH').value = config['Hards']['Pace'] || '';
        document.getElementById('degH').value = config['Hards']['Deg'] || '';
      }

      // Load strategies of interest
      if (config['Strategies Of Interest']) {
        const strategies = config['Strategies Of Interest'][0] || []; // Get first array element
        const strategyInputs = document.querySelectorAll('.strategyInput');

        // Clear all strategy inputs first
        strategyInputs.forEach(input => input.value = '');

        // Populate with strategies from config
        strategies.forEach((strategy, index) => {
          if (index < strategyInputs.length) {
            strategyInputs[index].value = strategy;
          }
        });
      }
    }

    // Initialize config dropdown on page load
    document.addEventListener('DOMContentLoaded', () => {
      loadConfigFile();

      // Handle config selection
      document.getElementById('configSelect').addEventListener('change', (e) => {
        loadConfig(e.target.value);
      });
    });

    /* Core helpers */

    function getScProb(lap, ranges) {
      for (const [mn, mx, p] of ranges) {
        if (mx === null && lap >= mn) return p;
        if (lap >= mn && lap <= mx) return p;
      }
      throw new Error("No SC probability defined for lap " + lap);
    }

    function lapTime(compIdx, age, lap, compounds, fuelEffect) {
      const base = compounds[compIdx].pace;
      const deg = compounds[compIdx].degradation;
      return base + deg * age - fuelEffect * (lap - 1);
    }

    function metaToKey(meta) {
      if (meta === null || meta === undefined) return "null";
      const t = typeof meta;
      if (t === "number" || t === "string" || t === "boolean") return String(meta);
      if (meta && typeof meta === "object" && "sc" in meta && "idx" in meta) {
        return (meta.sc ? "1" : "0") + ":" + meta.idx;
      }
      return JSON.stringify(meta);
    }

    function stateKey(lap, compIdx, age, scStatus, meta) {
      return lap + "|" + compIdx + "|" + age + "|" + scStatus + "|" + metaToKey(meta);
    }

    /* Rules */

    class TwoCompoundTyreRule {
      constructor(compoundIndices) {
        this.compoundIndices = compoundIndices;
      }
      allMetaNew() {
        const ans = [];
        ans.push({ meta: -1, compounds: Array.from(this.compoundIndices) });
        for (const c of this.compoundIndices) {
          ans.push({ meta: c, compounds: [c] });
        }
        return ans;
      }
      initMeta(startCompIdx) {
        return startCompIdx;
      }
      newCompoundsAllowed(meta) {
        return Array.from(this.compoundIndices);
      }
      nextMetaOnSc(meta) {
        return meta;
      }
      nextMetaOnPit(meta, newComp) {
        if (meta !== newComp) return -1;
        return meta;
      }
      terminalOk(meta) {
        return meta === -1;
      }
    }

    class PatternUnlessSCTyreRule {
      constructor(patternCompIndices, compoundIndices) {
        this.pattern = patternCompIndices;
        this.length = patternCompIndices.length;
        this.compoundIndices = compoundIndices;
      }
      allMetaNew() {
        const metas = [];
        for (let i = 1; i <= this.length; i++) {
          metas.push({
            meta: { sc: false, idx: i },
            compounds: [this.pattern[i - 1]]
          });
        }
        metas.push({
          meta: { sc: true, idx: -1 },
          compounds: Array.from(this.compoundIndices)
        });
        for (const c of this.compoundIndices) {
          metas.push({
            meta: { sc: true, idx: c },
            compounds: [c]
          });
        }
        return metas;
      }
      initMeta(startCompIdx) {
        if (startCompIdx !== this.pattern[0]) return null;
        return { sc: false, idx: 1 };
      }
      newCompoundsAllowed(meta) {
        if (meta.sc) {
          return Array.from(this.compoundIndices);
        } else {
          const idx = meta.idx;
          if (idx >= this.length) return [];
          return [this.pattern[idx]];
        }
      }
      nextMetaOnPit(meta, newComp) {
        if (meta.sc) {
          const idx = meta.idx;
          if (idx === -1) return { sc: true, idx: -1 };
          if (newComp === idx) return { sc: true, idx };
          return { sc: true, idx: -1 };
        } else {
          const idx = meta.idx;
          if (idx >= this.length || newComp !== this.pattern[idx]) return null;
          return { sc: false, idx: idx + 1 };
        }
      }
      nextMetaOnSc(meta) {
        if (meta.sc) return meta;
        const idx = meta.idx;
        const used = new Set(this.pattern.slice(0, idx));
        if (used.size >= 2) return { sc: true, idx: -1 };
        return { sc: true, idx: this.pattern[idx - 1] };
      }
      terminalOk(meta) {
        if (meta.sc) return meta.idx === -1;
        return meta.idx === this.length;
      }
    }

    /* DP core */

    function computePolicy(numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, rule) {
      const scProb = {};
      for (let lap = 1; lap <= numLaps; lap++) {
        scProb[lap] = getScProb(lap, scProbRanges);
      }

      const dpExp = new Map();
      const policy = new Map();

      for (let lap = numLaps + 1; lap >= 1; lap--) {
        const metaList = rule.allMetaNew();
        for (const entry of metaList) {
          const meta = entry.meta;
          const metaCompounds = entry.compounds;
          for (const compIdx of metaCompounds) {
            for (let scStatus = 0; scStatus <= 1; scStatus++) {
              for (let age = 0; age < lap; age++) {
                const key = stateKey(lap, compIdx, age, scStatus, meta);

                if (lap === numLaps + 1) {
                  dpExp.set(key, rule.terminalOk(meta) ? 0 : INF);
                  policy.set(key, null);
                  continue;
                }

                let bestExp = INF;
                let bestAction = null;

                if (scStatus === 1) {
                  const options = [
                    {
                      compIdxOpt: compIdx,
                      ageOpt: age,
                      action: ["stay"],
                      metaOpt: meta,
                      pitLossOpt: 0
                    }
                  ];

                  const allowed = rule.newCompoundsAllowed(meta) || [];
                  for (const newC of allowed) {
                    const newMeta = rule.nextMetaOnPit(meta, newC);
                    if (newMeta == null) continue;
                    options.push({
                      compIdxOpt: newC,
                      ageOpt: 0,
                      action: ["pit", newC],
                      metaOpt: newMeta,
                      pitLossOpt: 0
                    });
                  }

                  for (const opt of options) {
                    const nextLap = Math.min(lap + scLength - 1, numLaps + 1);
                    const nextMetaAfterSc = rule.nextMetaOnSc(opt.metaOpt);
                    const nextKey = stateKey(
                      nextLap,
                      opt.compIdxOpt,
                      opt.ageOpt,
                      0,
                      nextMetaAfterSc
                    );
                    const nextVal = dpExp.get(nextKey);
                    const exp = opt.pitLossOpt + (nextVal !== undefined ? nextVal : INF);
                    if (exp < bestExp) {
                      bestExp = exp;
                      bestAction = opt.action;
                    }
                  }
                } else {
                  const options = [
                    {
                      compIdxOpt: compIdx,
                      ageOpt: age,
                      action: ["stay"],
                      metaOpt: meta,
                      pitLossOpt: 0
                    }
                  ];

                  const allowed = rule.newCompoundsAllowed(meta) || [];
                  for (const newC of allowed) {
                    const newMeta = rule.nextMetaOnPit(meta, newC);
                    if (newMeta == null) continue;
                    options.push({
                      compIdxOpt: newC,
                      ageOpt: 0,
                      action: ["pit", newC],
                      metaOpt: newMeta,
                      pitLossOpt: pitLoss
                    });
                  }

                  for (const opt of options) {
                    const lt = lapTime(
                      opt.compIdxOpt,
                      opt.ageOpt,
                      lap,
                      compounds,
                      fuelEffect
                    );

                    const nextLap = lap + 1;
                    const metaAfterSc = rule.nextMetaOnSc(opt.metaOpt);

                    const scKey = stateKey(
                      nextLap,
                      opt.compIdxOpt,
                      opt.ageOpt + 1,
                      1,
                      metaAfterSc
                    );
                    const greenKey = stateKey(
                      nextLap,
                      opt.compIdxOpt,
                      opt.ageOpt + 1,
                      0,
                      opt.metaOpt
                    );

                    const valSc = dpExp.get(scKey);
                    const valGreen = dpExp.get(greenKey);

                    const exp =
                      opt.pitLossOpt +
                      scProb[lap] * (valSc !== undefined ? valSc : INF) +
                      (1 - scProb[lap]) *
                        ((valGreen !== undefined ? valGreen : INF) + lt);

                    if (exp < bestExp) {
                      bestExp = exp;
                      bestAction = opt.action;
                    }
                  }
                }

                dpExp.set(key, bestExp);
                policy.set(key, bestAction);
              }
            }
          }
        }
      }

      return { dpExp, policy };
    }

    function extractNoScStrategy(rule, startCompIdx, numLaps, policy) {
      let meta = rule.initMeta(startCompIdx);
      if (meta == null) return [];

      const stints = [];
      let compIdx = startCompIdx;
      let age = 0;
      let currentStintStart = 1;

      for (let lap = 1; lap <= numLaps; lap++) {
        const key = stateKey(lap, compIdx, age, 0, meta);
        const action = policy.get(key);
        if (!action) break;

        if (action[0] === "pit") {
          const newComp = action[1];
          if (lap - 1 >= currentStintStart) {
            stints.push([compIdx, currentStintStart, lap - 1]);
          }
          const newMeta = rule.nextMetaOnPit(meta, newComp);
          compIdx = newComp;
          meta = newMeta;
          currentStintStart = lap;
          age = 1;
        } else {
          age += 1;
        }
      }

      if (currentStintStart <= numLaps) {
        stints.push([compIdx, currentStintStart, numLaps]);
      }
      return stints;
    }

    function calcRaceTime(stints, compounds, fuelEffect, pitLoss) {
      let total = pitLoss * (stints.length - 1);
      for (const [ci, sLap, eLap] of stints) {
        for (let lap = sLap; lap <= eLap; lap++) {
          const age = lap - sLap;
          total += lapTime(ci, age, lap, compounds, fuelEffect);
        }
      }
      return total;
    }

    function summarizeResults(numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, rule) {
      const { dpExp, policy } = computePolicy(
        numLaps,
        compounds,
        fuelEffect,
        scProbRanges,
        scLength,
        pitLoss,
        rule
      );
      const results = {};
      for (let startIdx = 0; startIdx < compounds.length; startIdx++) {
        const meta0 = rule.initMeta(startIdx);
        if (meta0 == null) continue;
        const stints = extractNoScStrategy(rule, startIdx, numLaps, policy);
        const key0 = stateKey(1, startIdx, 0, 0, meta0);
        const expectedTime = dpExp.get(key0);
        results[compounds[startIdx].type] = {
          expected_time: expectedTime,
          no_sc_stints: stints,
          no_sc_time: calcRaceTime(stints, compounds, fuelEffect, pitLoss)
        };
      }
      return { results };
    }

    function computeFreePatterns(numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss) {
      const compoundIndices = compounds.map((_, i) => i);
      const rule = new TwoCompoundTyreRule(compoundIndices);
      const { dpExp, policy } = computePolicy(
        numLaps,
        compounds,
        fuelEffect,
        scProbRanges,
        scLength,
        pitLoss,
        rule
      );

      const seen = new Set();
      const patterns = [];

      for (let startIdx = 0; startIdx < compounds.length; startIdx++) {
        const meta0 = rule.initMeta(startIdx);
        if (meta0 == null) continue;

        const stints = extractNoScStrategy(rule, startIdx, numLaps, policy);
        if (!stints || !stints.length) continue;

        const seq = [];
        for (const [ci] of stints) {
          const t = compounds[ci].type;
          seq.push(t);
        }

        if (seq.length >= 2 && seq.length <= 4) {
          const key = seq.join(",");
          if (!seen.has(key)) {
            seen.add(key);
            patterns.push(seq);
          }
        }
      }

      return patterns;
    }

    /* SC ranges + patterns input helpers */

    function addScProbRow(from = "", to = "", prob = "") {
      const tbody = document.querySelector("#scProbTable tbody");
      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><input class="field-input fromLap" type="number" min="1" value="${from}"></td>
        <td><input class="field-input toLap" type="number" min="1" value="${to}"></td>
        <td><input class="field-input prob" type="number" step="0.1" min="0" max="100" value="${prob}"></td>
        <td><button type="button" class="btn-small deleteRangeBtn">✕</button></td>
      `;
      tbody.appendChild(tr);
    }

    function readScProbRanges() {
      const rows = document.querySelectorAll("#scProbTable tbody tr");
      const ranges = [];
      rows.forEach((row) => {
        const fromVal = row.querySelector(".fromLap").value.trim();
        const toVal = row.querySelector(".toLap").value.trim();
        const pVal = row.querySelector(".prob").value.trim();
        if (!fromVal || !pVal) return;
        const fromLap = parseInt(fromVal, 10);
        let toLap = null;
        if (toVal !== "") {
          toLap = parseInt(toVal, 10);
        }
        const prob = parseFloat(pVal);
        ranges.push([fromLap, isNaN(toLap) ? null : toLap, prob / 100]);
      });

      if (ranges.length === 0) {
        throw new Error("Define at least one SC probability range.");
      }
      const last = ranges[ranges.length - 1];
      if (last[1] !== null) {
        throw new Error('Last SC probability range must leave "To lap" blank (open-ended).');
      }
      return ranges;
    }

    function getStrategyPatterns() {
      const inputs = document.querySelectorAll(".strategyInput");
      const strategies = [];
      inputs.forEach((input) => {
        const raw = input.value.trim();
        if (!raw) return;
        const tokens = raw
          .split(/[,\s>\-]+/)
          .map((t) => t.trim().toUpperCase())
          .filter((t) => t);
        if (tokens.length < 2 || tokens.length > 4) return;
        if (!tokens.every((t) => t === "S" || t === "M" || t === "H")) return;
        strategies.push(tokens);
      });
      return strategies.slice(0, 5);
    }

    /* Chart + stints */

    let strategyChart = null;
    let lapTimeChart = null;

    function updateCombinedChartAndStints(combinedResults, compounds, baselineFree) {
      const chartDom = document.getElementById("strategyChart");
      const stintsDom = document.getElementById("strategyStints");

      if (!strategyChart) {
        strategyChart = echarts.init(chartDom);
      }

      if (!combinedResults || combinedResults.length === 0 || !Number.isFinite(baselineFree)) {
        strategyChart.clear();
        strategyChart.setOption({
          backgroundColor: "transparent",
          title: {
            text: "No valid fixed strategies (check inputs or strategies).",
            textStyle: { color: "#f56565", fontSize: 14 }
          }
        });
        stintsDom.innerHTML =
          '<h3>No-SC optimal stints</h3><div>No valid strategies to display.</div>';
        return;
      }

      const categories = combinedResults.map((r) => r.label);
      const deltas = combinedResults.map((r) =>
        +(r.expected_time - baselineFree).toFixed(3)
      );

      const option = {
        backgroundColor: "transparent",
        textStyle: { color: "#e2e8f0" },
        tooltip: {
          trigger: "axis",
          axisPointer: { type: "shadow" },
          formatter: (params) => {
            const p = params[0];
            const label = categories[p.dataIndex];
            const val = deltas[p.dataIndex];
            return `${label}<br/>Δt: ${val.toFixed(3)} s`;
          }
        },
        grid: { left: 80, right: 20, top: 40, bottom: 70 },
        xAxis: {
          type: "category",
          data: categories,
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: {
            color: "#cbd5f5",
            fontSize: 10,
            rotate: 20
          },
          axisTick: { show: false }
        },
        yAxis: {
          type: "value",
          name: "Δt (s)",
          nameTextStyle: { color: "#a0aec0", fontSize: 10, padding: [0, 0, 4, 0] },
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: { color: "#cbd5f5", fontSize: 10 },
          splitLine: { lineStyle: { color: "#1a202c" } }
        },
        series: [
          {
            type: "bar",
            data: deltas,
            barWidth: "55%",
            itemStyle: {
              borderRadius: [4, 4, 0, 0]
            }
          }
        ]
      };

      strategyChart.setOption(option, true);

      let html = '<h3>Predicted pit stops</h3>';
      combinedResults.forEach((r, idx) => {
        const delta = deltas[idx];
        const label = r.isBaseline ? `${r.label} (optimal)` : r.label;
        const stintText = r.stints
          .slice(0, -1)
          .map(([ci, s, e]) => `${e}`)
          .join(", ");
        html += `
          <div class="stints-item">
            <span class="stints-label">${label}</span>
            <span> lap(s): ${stintText || "—"}</span>
          </div>`;
      });
      stintsDom.innerHTML = html;
    }

    function updateLapTimeChart(combinedResults, compounds, numLaps, fuelEffect) {
      const dom = document.getElementById("lapTimeChart");
      if (!dom) return;

      if (!lapTimeChart) {
        lapTimeChart = echarts.init(dom);
      }

      if (!combinedResults || combinedResults.length === 0 || !Number.isFinite(numLaps)) {
        lapTimeChart.clear();
        lapTimeChart.setOption({
          backgroundColor: "transparent",
          title: {
            text: "No-SC lap time profiles",
            left: 10,
            top: 8,
            textStyle: { color: "#718096", fontSize: 12, fontWeight: 400 }
          }
        });
        return;
      }

      const series = [];

      combinedResults.forEach((r) => {
        const data = [];
        r.stints.forEach(([ci, sLap, eLap]) => {
          for (let lap = sLap; lap <= eLap; lap++) {
            const age = lap - sLap;
            const lt = lapTime(ci, age, lap, compounds, fuelEffect);
            data.push({
              value: [lap, lt],
              compIdx: ci
            });
          }
        });
        data.sort((a, b) => a[0] - b[0]);

        const isBaseline = r.isBaseline;
        series.push({
          name: isBaseline ? `${r.label} (optimal)` : r.label,
          type: "line",
          data,
          showSymbol: false,
          symbol: "circle",
          symbolSize: isBaseline ? 3 : 2,
          lineStyle: {
            width: isBaseline ? 2.2 : 1.7,
            type: isBaseline ? "solid" : "dashed"
          },
          emphasis: { focus: "series" }
        });
      });

      const option = {
        backgroundColor: "transparent",
        textStyle: { color: "#e2e8f0" },
        tooltip: {
          trigger: "axis",
          axisPointer: { type: "line" },
          formatter: (params) => {
            if (!params || !params.length) return "";
            const lap = params[0].value[0];
            let s = `Lap ${lap}<br/>`;
            params.forEach(p => {
              const t = p.value[1];
              const ci = p.data.compIdx;
              const comp = compounds[ci].type || ["S","M","H"][ci] || "";
              s += `${p.marker}${p.seriesName}: ${t.toFixed(3)} s (${comp})<br/>`;
            });
            return s;
          }
        },
        legend: {
          top: 22,
          right: 10,
          textStyle: { color: "#cbd5f5", fontSize: 8 }
        },
        grid: { left: 55, right: 18, top: 42, bottom: 40 },
        xAxis: {
          type: "value",
          name: "Lap",
          min: 1,
          max: numLaps,
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: { color: "#cbd5f5", fontSize: 9 },
          splitLine: { show: false }
        },
        yAxis: {
          type: "value",
          name: "Lap time (s)",
          scale: true,
          nameTextStyle: { color: "#a0aec0", fontSize: 10, padding: [0, 0, 4, 0] },
          axisLine: { lineStyle: { color: "#4a5568" } },
          axisLabel: { color: "#cbd5f5", fontSize: 9 },
          splitLine: { lineStyle: { color: "#1a202c" } }
        },
        series
      };

      lapTimeChart.setOption(option, true);
    }

    /* Run + seeding */

    function runSimulation() {
      const errorBox = document.getElementById("errorBox");
      errorBox.textContent = "";

      try {
        const numLaps = parseInt(document.getElementById("numLaps").value, 10);
        const fuelEffect = parseFloat(document.getElementById("fuelEffect").value);
        const scLength = parseInt(document.getElementById("scLength").value, 10);
        const pitLoss = parseFloat(document.getElementById("pitLoss").value);

        const compounds = [
          { type: "S", pace: parseFloat(document.getElementById("paceS").value), degradation: parseFloat(document.getElementById("degS").value) },
          { type: "M", pace: parseFloat(document.getElementById("paceM").value), degradation: parseFloat(document.getElementById("degM").value) },
          { type: "H", pace: parseFloat(document.getElementById("paceH").value), degradation: parseFloat(document.getElementById("degH").value) }
        ];

        if (!Number.isFinite(numLaps) || numLaps <= 0) throw new Error("Num laps must be a positive integer.");
        if (!Number.isFinite(fuelEffect)) throw new Error("Fuel effect must be a number.");
        if (!Number.isFinite(scLength) || scLength <= 0) throw new Error("SC length must be a positive integer.");
        if (!Number.isFinite(pitLoss) || pitLoss < 0) throw new Error("Pit loss must be a non-negative number.");
        for (const c of compounds) {
          if (!Number.isFinite(c.pace) || !Number.isFinite(c.degradation)) {
            throw new Error("All compound pace and degradation values must be numbers.");
          }
        }

        const scProbRanges = readScProbRanges();

        const compoundIndices = compounds.map((_, i) => i);
        const typeToIdx = {};
        compounds.forEach((c, i) => { typeToIdx[c.type.toUpperCase()] = i; });

        // Baseline free rule (not plotted)
        const freeRule = new TwoCompoundTyreRule(compoundIndices);
        const freeSummary = summarizeResults(
          numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, freeRule
        );

        const freeEntries = Object.entries(freeSummary.results)
          .filter(([, info]) => Number.isFinite(info.expected_time));

        if (freeEntries.length === 0) {
          throw new Error("No valid free strategies; check inputs.");
        }

        // Find globally optimal two-compound strategy
        let optimalEntry = null;
        let baselineFree = INF;

        for (const [startType, info] of freeEntries) {
          if (info.expected_time < baselineFree) {
            baselineFree = info.expected_time;
            optimalEntry = { startType, info };
          }
        }

        if (!optimalEntry || !optimalEntry.info.no_sc_stints || !optimalEntry.info.no_sc_stints.length) {
          throw new Error("Unable to compute an optimal two-compound strategy.");
        }

        // Tyre sequence of the optimal strategy under no SC
        const optimalStints = optimalEntry.info.no_sc_stints;
        const optimalTyreSeq = optimalStints
          .map(([ci]) => compounds[ci].type)
          .join("→");

        // Always include optimal two-compound strategy first
        const combinedResults = [];
        const seenLabels = new Set();

        combinedResults.push({
          label: optimalTyreSeq,
          expected_time: baselineFree,
          stints: optimalStints,
          isBaseline: true
        });
        seenLabels.add(optimalTyreSeq);

        // Fixed patterns from user input
        const patterns = getStrategyPatterns();

        for (const pattern of patterns) {
          const patternIndices = [];
          let valid = true;
          for (const t of pattern) {
            const idx = typeToIdx[t];
            if (idx === undefined) { valid = false; break; }
            patternIndices.push(idx);
          }
          if (!valid) continue;

          const rule = new PatternUnlessSCTyreRule(patternIndices, compoundIndices);
          const summary = summarizeResults(
            numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss, rule
          );
          const entries = Object.entries(summary.results);
          if (entries.length === 0) continue;

          const [startType, info] = entries[0];
          if (!Number.isFinite(info.expected_time)) continue;

          const label = pattern.join("→");
          if (seenLabels.has(label)) continue; // don't duplicate optimal

          combinedResults.push({
            label,
            expected_time: info.expected_time,
            stints: info.no_sc_stints
          });
          seenLabels.add(label);
        }

        if (combinedResults.length === 0) {
          throw new Error("No valid fixed strategies from the current patterns.");
        }

        updateCombinedChartAndStints(combinedResults, compounds, baselineFree);
        updateLapTimeChart(combinedResults, compounds, numLaps, fuelEffect);
      } catch (e) {
        errorBox.textContent = e.message;
        updateCombinedChartAndStints([], [], NaN);
        updateLapTimeChart([], [], NaN, NaN);
      }
    }

    function seedPatternsFromFree() {
      try {
        const numLaps = parseInt(document.getElementById("numLaps").value, 10);
        const fuelEffect = parseFloat(document.getElementById("fuelEffect").value);
        const scLength = parseInt(document.getElementById("scLength").value, 10);
        const pitLoss = parseFloat(document.getElementById("pitLoss").value);

        const compounds = [
          { type: "S", pace: parseFloat(document.getElementById("paceS").value), degradation: parseFloat(document.getElementById("degS").value) },
          { type: "M", pace: parseFloat(document.getElementById("paceM").value), degradation: parseFloat(document.getElementById("degM").value) },
          { type: "H", pace: parseFloat(document.getElementById("paceH").value), degradation: parseFloat(document.getElementById("degH").value) }
        ];

        if (!Number.isFinite(numLaps) || !Number.isFinite(fuelEffect) ||
            !Number.isFinite(scLength) || !Number.isFinite(pitLoss) ||
            compounds.some(c => !Number.isFinite(c.pace) || !Number.isFinite(c.degradation))) {
          return;
        }

        const scProbRanges = readScProbRanges();
        const patterns = computeFreePatterns(
          numLaps, compounds, fuelEffect, scProbRanges, scLength, pitLoss
        ).slice(0, 3);

        const inputs = document.querySelectorAll(".strategyInput");
        for (let i = 0; i < patterns.length && i < inputs.length; i++) {
          inputs[i].value = patterns[i].join(",");
        }
      } catch (_) {
        // Leave as-is if seeding fails.
      }
    }

    /* Init */

    (function init() {
      document.getElementById("numLaps").value = 71;
      document.getElementById("fuelEffect").value = 0.018;
      document.getElementById("scLength").value = 5;
      document.getElementById("pitLoss").value = 21.8;
      document.getElementById("paceS").value = 75.0;
      document.getElementById("degS").value = 0.08;
      document.getElementById("paceM").value = 75.5;
      document.getElementById("degM").value = 0.06;
      document.getElementById("paceH").value = 76.5;
      document.getElementById("degH").value = 0.02;

      const tbody = document.querySelector("#scProbTable tbody");
      tbody.innerHTML = "";
      addScProbRow(1, 1, 26.1);
      addScProbRow(2, 2, 4.9);
      addScProbRow(3, 3, 3.3);
      addScProbRow(4, "", 1.6);

      document.getElementById("addRangeBtn")
        .addEventListener("click", () => addScProbRow());

      document.addEventListener("click", (e) => {
        if (e.target.classList.contains("deleteRangeBtn")) {
          const tr = e.target.closest("tr");
          if (tr && tr.parentNode) tr.parentNode.removeChild(tr);
        }
      });

      document.getElementById("runBtn").addEventListener("click", runSimulation);

      seedPatternsFromFree();
      runSimulation();
    })();
  </script>
  </div>
</body>
</html>
