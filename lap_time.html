<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Lap Grouping Analysis</title>
  <link rel="stylesheet" href="common.css">
  <style>
    /* Page-specific styles */
    .page-content {
      display: flex;
      justify-content: center;
      align-items: flex-start;
      padding: 8px 16px 16px;
    }

    .container {
      max-width: 1400px;
    }

    .header {
      display: flex;
      justify-content: flex-start;
      align-items: center;
      gap: 12px;
      margin-bottom: 8px;
      padding: 0;
      flex-wrap: wrap;
    }

    .small {
      color: var(--muted-color);
      font-size: 12px;
    }

    select {
      min-width: 160px;
      width: auto;
    }

    #sessionSel {
      min-width: 120px;
    }

    .chart-and-drivers {
      display: flex;
      gap: 16px;
      margin-bottom: 16px;
    }

    .drivers-panel {
      width: 200px;
      padding: 12px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
      max-height: 550px;
      overflow-y: auto;
    }

    .chart-wrapper {
      flex: 1;
    }

    .filters-section {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 16px;
      margin-bottom: 16px;
    }

    .drivers-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 8px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .driver-item {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      margin-bottom: 2px;
      border-radius: 4px;
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
      transition: background 0.2s;
    }

    .driver-item:hover {
      background: rgba(0, 224, 255, 0.1);
    }

    .driver-item input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 13px;
      height: 13px;
      cursor: pointer;
    }

    .driver-item label {
      cursor: pointer;
      flex: 1;
    }

    .toggle-button {
      padding: 4px 12px;
      font-size: 10px;
      border-radius: 6px;
      border: 1px solid var(--border-color);
      background: rgba(0, 0, 0, 0.3);
      color: var(--text-color);
      cursor: pointer;
      transition: all var(--transition-fast);
    }

    .toggle-button.active {
      background: var(--accent-color);
      color: #000;
      border-color: var(--accent-color);
    }

    .toggle-button:hover {
      border-color: var(--accent-color);
    }

    .chart-controls {
      display: flex;
      gap: 8px;
      margin-bottom: 8px;
      align-items: center;
    }

    .filter-panel {
      padding: 16px;
      background: rgba(0, 224, 255, 0.03);
      border-radius: var(--radius-lg);
      border: 1px solid var(--border-color);
    }

    .filters-title {
      font-size: 11px;
      font-weight: 600;
      color: var(--accent-color);
      margin-bottom: 12px;
      text-transform: uppercase;
      letter-spacing: 0.05em;
    }

    .filters-grid {
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .filter-item {
      display: flex;
      flex-direction: row;
      justify-content: space-between;
      align-items: center;
      gap: 8px;
    }

    .filter-item.vertical {
      flex-direction: column;
      align-items: stretch;
      gap: 4px;
    }

    .filter-label {
      font-size: 10px;
      color: var(--muted-color);
      text-transform: uppercase;
      letter-spacing: 0.08em;
      white-space: nowrap;
    }

    input[type="number"] {
      width: 100px;
    }

    .checkbox-group {
      display: flex;
      align-items: center;
      gap: 6px;
      padding: 4px 0;
    }

    .checkbox-group input[type="checkbox"] {
      accent-color: var(--accent-color);
      width: 14px;
      height: 14px;
      cursor: pointer;
    }

    .checkbox-group label {
      font-size: 11px;
      color: var(--text-color);
      cursor: pointer;
    }

    .exclude-checkboxes {
      display: flex;
      flex-direction: column;
      gap: 8px;
    }

    .groups-table {
      margin-top: 20px;
      width: 100%;
      border-collapse: collapse;
      font-size: 11px;
    }

    .groups-table th {
      background: rgba(0, 224, 255, 0.1);
      color: var(--accent-color);
      padding: 8px 10px;
      text-align: left;
      font-weight: 600;
      text-transform: uppercase;
      letter-spacing: 0.05em;
      font-size: 10px;
      border: 1px solid var(--border-color);
    }

    .groups-table td {
      padding: 8px 10px;
      border: 1px solid var(--border-color);
      color: var(--text-color);
    }

    .groups-table tr:hover {
      background: rgba(0, 224, 255, 0.05);
    }

    .groups-table td:last-child {
      max-width: 600px;
      word-wrap: break-word;
      white-space: normal;
    }


    @media (max-width: 640px) {
      .container {
        padding: 18px 14px 14px;
      }
      .controls {
        grid-template-columns: 1fr;
      }
      .title {
        font-size: 18px;
      }
      .subtitle {
        font-size: 11px;
      }
    }
  </style>
</head>
<body>
  <div class="page-content">
  <div class="container">
    <div class="header">
      <label class="small" for="seasonSel">Season</label>
      <select id="seasonSel" title="Season">
        <option value=""></option>
      </select>
      <label class="small" for="gpSel">GP</label>
      <select id="gpSel" title="Grand Prix" disabled>
        <option value=""></option>
      </select>
      <label class="small" for="sessionSel">Session</label>
      <select id="sessionSel" title="Session type" disabled>
        <option value=""></option>
      </select>
      <span class="status-message" id="statusMessage">Loading...</span>
    </div>

    <div class="chart-and-drivers">
      <div class="drivers-panel" id="driversPanel" style="display: none;">
        <div class="drivers-title">Drivers</div>
        <div id="driversList"></div>
      </div>
      <div class="chart-wrapper">
        <div class="chart-controls" id="chartControls" style="display: none;">
          <button id="fuelAdjustToggle" class="toggle-button">Fuel Adjusted</button>
          <button id="tyreLifeAdjustToggle" class="toggle-button">Tyre Life Adjusted</button>
        </div>
        <div id="chartContainer" style="width: 100%; height: 550px; display: none;"></div>
        <div id="coefficientsContainer" style="display: none; padding: 12px 16px; background: rgba(0, 224, 255, 0.03); border-radius: 8px; border: 1px solid var(--border-color); margin-top: 8px;">
          <div style="font-size: 11px; font-weight: 600; color: var(--accent-color); margin-bottom: 8px; text-transform: uppercase; letter-spacing: 0.05em;">Linear Fit Coefficients (y = mx)</div>
          <div id="coefficientsGrid" style="display: grid; grid-template-columns: repeat(auto-fit, minmax(200px, 1fr)); gap: 8px;"></div>
        </div>
      </div>
    </div>

    <div class="filters-section">
      <div class="filter-panel">
        <div class="filters-title">Adjustments</div>
        <div class="filters-grid">
          <div class="filter-item">
            <div class="filter-label">Hard Deg (sec/lap)</div>
            <input type="number" id="degHard" value="0.05" min="0" step="0.01">
          </div>
          <div class="filter-item">
            <div class="filter-label">Medium Deg (sec/lap)</div>
            <input type="number" id="degMedium" value="0.08" min="0" step="0.01">
          </div>
          <div class="filter-item">
            <div class="filter-label">Soft Deg (sec/lap)</div>
            <input type="number" id="degSoft" value="0.12" min="0" step="0.01">
          </div>
          <div class="filter-item">
            <div class="filter-label">Fuel Effect (sec/lap)</div>
            <input type="number" id="fuelEffect" value="0.03" min="0" step="0.01">
          </div>
        </div>
      </div>

      <div class="filter-panel">
        <div class="filters-title">Lap Filters</div>
        <div class="filters-grid">
          <div class="filter-item">
            <div class="filter-label">Laps to Discard at Start</div>
            <input type="number" id="filterMinLap" value="2" min="0">
          </div>
          <div class="filter-item">
            <div class="filter-label">Laps to Discard at End</div>
            <input type="number" id="filterEndLaps" value="0" min="0">
          </div>
          <div class="filter-item">
            <div class="filter-label">Min Distance to Car Ahead</div>
            <input type="number" id="filterMinDist" value="0" min="0" step="0.1">
          </div>
        </div>
      </div>

      <div class="filter-panel">
        <div class="filters-title">Include</div>
        <div class="exclude-checkboxes">
          <div class="checkbox-group">
            <input type="checkbox" id="filterIncludeLapped" checked>
            <label for="filterIncludeLapped">Lapped</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterIncludeRetired" checked>
            <label for="filterIncludeRetired">Retired</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterRainfall" checked>
            <label for="filterRainfall">Rainfall</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterSafetyCar">
            <label for="filterSafetyCar">Safety Car</label>
          </div>
          <div class="checkbox-group">
            <input type="checkbox" id="filterPitLaps">
            <label for="filterPitLaps">Pit Laps</label>
          </div>
        </div>
      </div>
    </div>
  </div>
  </div>

  <!-- Papa Parse from CDN -->
  <script src="https://unpkg.com/papaparse@5.4.1/papaparse.min.js"></script>

  <!-- ECharts for charts -->
  <script src="https://cdn.jsdelivr.net/npm/echarts@5/dist/echarts.min.js"></script>
  <script src="common.js"></script>

  <script>
    const seasonSel = document.getElementById("seasonSel");
    const gpSel = document.getElementById("gpSel");
    const sessionSel = document.getElementById("sessionSel");
    const statusMessage = document.getElementById("statusMessage");
    const chartContainer = document.getElementById("chartContainer");
    const chartControls = document.getElementById("chartControls");
    const coefficientsContainer = document.getElementById("coefficientsContainer");
    const coefficientsGrid = document.getElementById("coefficientsGrid");
    const driversPanel = document.getElementById("driversPanel");
    const driversList = document.getElementById("driversList");
    const fuelAdjustToggle = document.getElementById("fuelAdjustToggle");
    const tyreLifeAdjustToggle = document.getElementById("tyreLifeAdjustToggle");

    let allRows = [];
    let currentSessionRows = []; // Store current session rows for rainfall/safety car/red flag detection
    let sessionsByKey = new Map(); // key -> {year, round_no, meeting_name, session_type}
    let tyreChoices = new Map(); // key (year||round_no) -> {hard, medium, soft}
    let circuitConfig = {}; // Circuit config from strat_calc_config.json
    let chart = null; // ECharts instance
    let selectedDrivers = new Set(); // Selected drivers for filtering
    let currentGroups = []; // Store current groups for filtering
    let driverColors = new Map(); // Driver colors for current event
    let currentEventInfo = null; // Store current year, round, session type
    let currentCircuitName = null; // Store current circuit name for config lookup
    let scheduledLaps = null; // Store scheduled laps for the current session

    init();

    // Handle window resize for chart
    window.addEventListener('resize', () => {
      if (chart) {
        chart.resize();
      }
    });

    function init() {
      // Load circuit config first
      fetch('strat_calc_config.json')
        .then(response => response.json())
        .then(data => {
          circuitConfig = data;
          // Then load driver info
          DriverInfo.load(() => {
            // Then load tyre_choices.csv
            loadTyreChoices();
          });
        })
        .catch(err => {
          console.error("Error loading strat_calc_config.json:", err);
          // Continue even if config fails to load
          DriverInfo.load(() => {
            loadTyreChoices();
          });
        });
    }

    function loadTyreChoices() {
      Papa.parse(DataCache.getCSVUrl("tyre_choices.csv"), {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.data) {
            results.data.forEach(row => {
              const year = String(row.year || "").trim();
              const round = String(row.round_no || "").trim();
              if (year && round) {
                const key = `${year}||${round}`;
                tyreChoices.set(key, {
                  hard: String(row.hard || "").trim(),
                  medium: String(row.medium || "").trim(),
                  soft: String(row.soft || "").trim()
                });
              }
            });
          }
          // Now load all_df.csv
          loadMainCSV();
        },
        error: function (err) {
          console.error("Error loading tyre_choices.csv:", err);
          loadMainCSV();
        }
      });
    }

    function loadMainCSV() {
      ParsedDataCache.loadCSV("all_df.csv", {
        download: true,
        header: true,
        skipEmptyLines: true,
        dynamicTyping: false,
        complete: function (results) {
          if (results.errors && results.errors.length) {
            console.warn("Papa Parse errors:", results.errors);
          }

          allRows = (results.data || []).filter(row =>
            row.year !== undefined &&
            row.round_no !== undefined &&
            row.meeting_name !== undefined &&
            row.session_type !== undefined &&
            String(row.year || "").trim() !== "2018"
          );

          if (!allRows.length) {
            statusMessage.textContent = "No usable rows found";
            return;
          }

          indexSessions(allRows);
          buildSeasonDropdown();
          setupFilterListeners();
          statusMessage.textContent = `${allRows.length} laps loaded`;
        },
        error: function (err) {
          console.error("Papa Parse error:", err);
          statusMessage.textContent = "Error loading CSV";
        }
      });

      seasonSel.addEventListener("change", onSeasonChange);
      gpSel.addEventListener("change", onGPChange);
      sessionSel.addEventListener("change", onSessionChange);
    }

    function indexSessions(rows) {
      sessionsByKey.clear();

      rows.forEach(r => {
        const year = String(r.year || "").trim();
        const round = String(r.round_no || "").trim();
        const meeting = String(r.meeting_name || "").trim();
        const session = String(r.session_type || "").trim();

        if (!year || !round || !meeting || !session) return;

        const key = `${year}||${round}||${meeting}||${session}`;
        if (!sessionsByKey.has(key)) {
          sessionsByKey.set(key, {
            year,
            round_no: round,
            meeting_name: meeting,
            session_type: session
          });
        }
      });
    }

    function buildSeasonDropdown() {
      UIHelpers.populateSeasons(seasonSel, sessionsByKey, {
        onChange: onSeasonChange
      });
    }

    function onSeasonChange() {
      const selectedSeason = seasonSel.value;
      sessionSel.innerHTML = '';
      sessionSel.disabled = true;

      // Clear chart and drivers
      chartContainer.style.display = 'none';
      chartControls.style.display = 'none';
      coefficientsContainer.style.display = 'none';
      driversPanel.style.display = 'none';
      selectedDrivers.clear();

      UIHelpers.populateGPs(gpSel, sessionsByKey, selectedSeason, {
        onChange: onGPChange
      });
    }

    function onGPChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;

      // Clear chart and drivers
      chartContainer.style.display = 'none';
      chartControls.style.display = 'none';
      coefficientsContainer.style.display = 'none';
      driversPanel.style.display = 'none';
      selectedDrivers.clear();

      UIHelpers.populateSessions(sessionSel, sessionsByKey, selectedSeason, selectedGP, {
        onChange: onSessionChange
      });
    }

    function setupFilterListeners() {
      document.getElementById("filterMinLap").addEventListener("input", onFilterChange);
      document.getElementById("filterEndLaps").addEventListener("input", onFilterChange);
      document.getElementById("filterMinDist").addEventListener("input", onFilterChange);
      document.getElementById("filterRainfall").addEventListener("change", onFilterChange);
      document.getElementById("filterSafetyCar").addEventListener("change", onFilterChange);
      document.getElementById("filterPitLaps").addEventListener("change", onFilterChange);
      document.getElementById('filterIncludeLapped').addEventListener('change', onFilterChange);
      document.getElementById('filterIncludeRetired').addEventListener('change', onFilterChange);
      document.getElementById('degHard').addEventListener('input', onAdjustmentChange);
      document.getElementById('degMedium').addEventListener('input', onAdjustmentChange);
      document.getElementById('degSoft').addEventListener('input', onAdjustmentChange);
      document.getElementById('fuelEffect').addEventListener('input', onAdjustmentChange);

      // Toggle buttons for adjustments
      fuelAdjustToggle.addEventListener('click', function() {
        this.classList.toggle('active');
        renderLapTimeChart(currentGroups);
      });

      tyreLifeAdjustToggle.addEventListener('click', function() {
        this.classList.toggle('active');
        renderLapTimeChart(currentGroups);
      });
    }

    function onFilterChange() {
      // Re-process data without resetting adjustment values
      if (!currentEventInfo) return;

      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) return;

      const [round, meeting] = selectedGP.split('||');

      const matchingRows = allRows.filter(r => {
        return String(r.year || "").trim() === selectedSeason &&
               String(r.round_no || "").trim() === round &&
               String(r.meeting_name || "").trim() === meeting &&
               String(r.session_type || "").trim() === selectedSession;
      });

      if (matchingRows.length === 0) return;

      const filteredRows = applyFilters(matchingRows);
      processData(filteredRows);
    }

    function onAdjustmentChange() {
      // Re-render chart with new adjustment values
      if (currentGroups && currentGroups.size > 0) {
        renderLapTimeChart(currentGroups);
      }
    }

    function applyFilters(rows) {
      const lapsToDiscard = parseInt(document.getElementById("filterMinLap").value) || 0;
      const minLap = lapsToDiscard + 1;
      const endLaps = parseInt(document.getElementById("filterEndLaps").value) || 0;
      const minDist = parseFloat(document.getElementById("filterMinDist").value) || 0;
      const includeRainfall = document.getElementById("filterRainfall").checked;
      const includeSafetyCar = document.getElementById("filterSafetyCar").checked;
      const includePitLaps = document.getElementById("filterPitLaps").checked;
      const includeLapped = document.getElementById('filterIncludeLapped').checked;
      const includeRetired = document.getElementById('filterIncludeRetired').checked;

      return rows.filter(r => {
        // Min lap number
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap) return false;

        // Max lap number (sched_laps - endLaps)
        const schedLaps = parseInt(r.sched_laps);
        if (!isNaN(schedLaps)) {
          const maxLap = schedLaps - endLaps;
          if (lapNum > maxLap) return false;
        }

        // Finish status filters
        const status = String(r.finish_status ?? "").trim();
        const plusLapsMatch = status.match(/^\+(\d+)\sLaps$/);
        const lapsBehind = plusLapsMatch ? Number(plusLapsMatch[1]) : 0;
        if (lapsBehind > 1) return false; // Always exclude "+2 Laps", "+3 Laps", etc.

        const isLapped = status === "Lapped" || status === "+1 Lap";
        if (!includeLapped && isLapped) return false;

        const isFinished = status === "Finished" || isLapped;
        const isRetired = !isFinished;
        if (!includeRetired && isRetired) return false;

        // Rainfall filter
        if (!includeRainfall) {
          const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
          if (rainfall === "true" || rainfall === "1") return false;
        }

        // Safety car filter
        if (!includeSafetyCar) {
          const trackStatus = String(r.lap_TrackStatus || "").trim();
          if (trackStatus.includes("4") || trackStatus.includes("5") ||
              trackStatus.includes("6") || trackStatus.includes("7")) {
            return false;
          }
        }

        // Pit laps filter
        if (!includePitLaps) {
          const pitIn = String(r.lap_PitInTime || "").trim();
          const pitOut = String(r.lap_PitOutTime || "").trim();
          if ((pitIn && pitIn.toLowerCase() !== "na" && pitIn !== "") ||
              (pitOut && pitOut.toLowerCase() !== "na" && pitOut !== "")) {
            return false;
          }
        }

        // Min distance filter
        const dist = parseFloat(r.min_dist);
        if (!isNaN(dist) && dist < minDist) return false;

        return true;
      });
    }

    function onSessionChange() {
      const selectedSeason = seasonSel.value;
      const selectedGP = gpSel.value;
      const selectedSession = sessionSel.value;

      if (!selectedSeason || !selectedGP || !selectedSession) {
        chartContainer.style.display = 'none';
        chartControls.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        driversPanel.style.display = 'none';
        return;
      }

      const [round, meeting] = selectedGP.split('||');

      // Filter rows for this session
      const matchingRows = allRows.filter(r => {
        return String(r.year || "").trim() === selectedSeason &&
               String(r.round_no || "").trim() === round &&
               String(r.meeting_name || "").trim() === meeting &&
               String(r.session_type || "").trim() === selectedSession;
      });

      if (matchingRows.length === 0) {
        chartContainer.style.display = 'none';
        chartControls.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        driversPanel.style.display = 'none';
        return;
      }

      // Store session rows globally for rainfall/safety car/red flag detection
      currentSessionRows = matchingRows;

      // Get circuit name and scheduled laps from first row
      if (matchingRows.length > 0) {
        currentCircuitName = String(matchingRows[0].circuit_name || "").trim();
        scheduledLaps = parseInt(matchingRows[0].sched_laps);
        if (isNaN(scheduledLaps)) {
          scheduledLaps = null;
        }

        // Update adjustment inputs from circuit config
        if (currentCircuitName && circuitConfig[currentCircuitName]) {
          const config = circuitConfig[currentCircuitName];

          if (config["Hard Deg"] !== undefined) {
            document.getElementById('degHard').value = config["Hard Deg"];
          }
          if (config["Medium Deg"] !== undefined) {
            document.getElementById('degMedium').value = config["Medium Deg"];
          }
          if (config["Soft Deg"] !== undefined) {
            document.getElementById('degSoft').value = config["Soft Deg"];
          }
          if (config["Fuel Effect"] !== undefined) {
            document.getElementById('fuelEffect').value = config["Fuel Effect"];
          }
        }
      }

      const filteredRows = applyFilters(matchingRows);

      // Store current event info for driver colors
      currentEventInfo = {
        year: selectedSeason,
        round: round,
        sessionType: selectedSession
      };

      // Get driver colors for this event
      driverColors = DriverInfo.getDriverColors(
        currentEventInfo.year,
        currentEventInfo.round,
        currentEventInfo.sessionType
      );

      // Clear selected drivers when changing session
      selectedDrivers.clear();

      processData(filteredRows);
    }

    function getF1TireColor(compound) {
      const compoundLower = String(compound || "").trim().toLowerCase();

      // F1 tire colors
      const colorMap = {
        'soft': '#FF0000',      // Red
        'medium': '#FFF200',    // Yellow
        'hard': '#FFFFFF',      // White
        'intermediate': '#00FF00', // Green
        'wet': '#0000FF'        // Blue
      };

      return colorMap[compoundLower] || '#999999'; // Default gray for unknown
    }

    function detectRainfallLaps(minLap, maxLap) {
      // Returns an array of lap ranges with rainfall: [{start: lap, end: lap}, ...]
      if (currentSessionRows.length === 0) return [];

      // Group by lap number and count drivers with rainfall
      const lapRainfall = new Map(); // lap# -> {total: count, rainfall: count}

      currentSessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRainfall.has(lapNum)) {
          lapRainfall.set(lapNum, { total: 0, rainfall: 0 });
        }

        const lapData = lapRainfall.get(lapNum);
        lapData.total++;

        // Check if this row has rainfall
        const rainfall = String(r.weather_Rainfall || "").trim().toLowerCase();
        if (rainfall === 'true' || rainfall === '1') {
          lapData.rainfall++;
        }
      });

      // Find laps where >= 50% of drivers have rainfall
      const rainfallLaps = [];
      lapRainfall.forEach((data, lapNum) => {
        const rainfallPercent = data.rainfall / data.total;
        if (rainfallPercent >= 0.5) {
          rainfallLaps.push(lapNum);
        }
      });

      // Merge consecutive laps into ranges
      if (rainfallLaps.length === 0) return [];

      rainfallLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = rainfallLaps[0];
      let end = rainfallLaps[0];

      for (let i = 1; i < rainfallLaps.length; i++) {
        if (rainfallLaps[i] === end + 1) {
          // Consecutive lap
          end = rainfallLaps[i];
        } else {
          // Gap found, save current range and start new one
          ranges.push({ start, end });
          start = rainfallLaps[i];
          end = rainfallLaps[i];
        }
      }
      // Don't forget the last range
      ranges.push({ start, end });

      return ranges;
    }

    function detectSafetyCarLaps(minLap, maxLap) {
      // Returns an array of lap ranges with safety car: [{start: lap, end: lap}, ...]
      if (currentSessionRows.length === 0) return [];

      // Group by lap number and count drivers with safety car
      const lapSafetyCar = new Map(); // lap# -> {total: count, safetyCar: count}

      currentSessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapSafetyCar.has(lapNum)) {
          lapSafetyCar.set(lapNum, { total: 0, safetyCar: 0 });
        }

        const lapData = lapSafetyCar.get(lapNum);
        lapData.total++;

        // Check if this row has safety car (TrackStatus 4, 6, or 7, but NOT 5)
        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('4') || trackStatus.includes('6') || trackStatus.includes('7')) {
          // Make sure it's not "5" - check if it's exactly 4, 6, or 7
          if (!trackStatus.includes('5')) {
            lapData.safetyCar++;
          }
        }
      });

      // Find laps where >= 50% of drivers have safety car
      const safetyCarLaps = [];
      lapSafetyCar.forEach((data, lapNum) => {
        const safetyCarPercent = data.safetyCar / data.total;
        if (safetyCarPercent >= 0.5) {
          safetyCarLaps.push(lapNum);
        }
      });

      // Merge consecutive laps into ranges
      if (safetyCarLaps.length === 0) return [];

      safetyCarLaps.sort((a, b) => a - b);
      const ranges = [];
      let start = safetyCarLaps[0];
      let end = safetyCarLaps[0];

      for (let i = 1; i < safetyCarLaps.length; i++) {
        if (safetyCarLaps[i] === end + 1) {
          // Consecutive lap
          end = safetyCarLaps[i];
        } else {
          // Gap found, save current range and start new one
          ranges.push({ start, end });
          start = safetyCarLaps[i];
          end = safetyCarLaps[i];
        }
      }
      // Don't forget the last range
      ranges.push({ start, end });

      return ranges;
    }

    function detectRedFlagLaps(minLap, maxLap) {
      // Returns an array of laps with red flags (TrackStatus contains "5")
      if (currentSessionRows.length === 0) return [];

      // Group by lap number and count drivers with red flag
      const lapRedFlag = new Map(); // lap# -> {total: count, redFlag: count}

      currentSessionRows.forEach(r => {
        const lapNum = parseInt(r.lap_LapNumber);
        if (isNaN(lapNum) || lapNum < minLap || lapNum > maxLap) return;

        if (!lapRedFlag.has(lapNum)) {
          lapRedFlag.set(lapNum, { total: 0, redFlag: 0 });
        }

        const lapData = lapRedFlag.get(lapNum);
        lapData.total++;

        // Check if this row has red flag (TrackStatus contains "5")
        const trackStatus = String(r.lap_TrackStatus || "").trim();
        if (trackStatus.includes('5')) {
          lapData.redFlag++;
        }
      });

      // Find laps where >= 50% of drivers have red flag
      const redFlagLaps = [];
      lapRedFlag.forEach((data, lapNum) => {
        const redFlagPercent = data.redFlag / data.total;
        if (redFlagPercent >= 0.5) {
          redFlagLaps.push(lapNum);
        }
      });

      return redFlagLaps.sort((a, b) => a - b);
    }

    function renderLapTimeChart(driverData) {
      if (driverData.size === 0) {
        chartContainer.style.display = 'none';
        chartControls.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        if (chart) {
          chart.dispose();
          chart = null;
        }
        return;
      }

      // Show chart container and controls
      chartContainer.style.display = 'block';
      chartControls.style.display = 'flex';
      coefficientsContainer.style.display = 'none'; // Hide coefficients for now

      // Initialize chart if needed
      if (!chart) {
        chart = echarts.init(chartContainer);
      }

      // Get adjustment settings
      const fuelAdjusted = fuelAdjustToggle.classList.contains('active');
      const tyreLifeAdjusted = tyreLifeAdjustToggle.classList.contains('active');
      const fuelEffect = parseFloat(document.getElementById('fuelEffect').value) || 0;
      const degHard = parseFloat(document.getElementById('degHard').value) || 0;
      const degMedium = parseFloat(document.getElementById('degMedium').value) || 0;
      const degSoft = parseFloat(document.getElementById('degSoft').value) || 0;

      const degradationMap = {
        'HARD': degHard,
        'MEDIUM': degMedium,
        'SOFT': degSoft
      };

      // Create series - one per stint for selected drivers
      const series = [];
      const seriesIndexByDriver = new Map(); // Map driver to array of series indices

      let seriesIdx = 0;
      driverData.forEach((stints, driver) => {
        // Only plot drivers that are checked
        if (!selectedDrivers.has(driver)) {
          return;
        }

        // Convert stints to array and sort by stint number
        const stintArray = Array.from(stints.entries()).sort((a, b) => {
          return parseInt(a[0]) - parseInt(b[0]);
        });

        const lastStintIndex = stintArray.length - 1;

        stintArray.forEach(([stintNumber, stintData], stintIndex) => {
          const isLastStint = stintIndex === lastStintIndex;

          // Sort laps by lap number
          const sortedLaps = stintData.laps.slice().sort((a, b) => a.lapNumber - b.lapNumber);

          const data = sortedLaps.map(lap => {
            let adjustedLapTime = lap.lapTime;

            // Apply fuel adjustment if enabled
            if (fuelAdjusted && !isNaN(lap.schedLaps)) {
              adjustedLapTime -= (lap.schedLaps - lap.lapNumber) * fuelEffect;
            }

            // Apply tyre life adjustment if enabled
            if (tyreLifeAdjusted && !isNaN(lap.tyreLife)) {
              const tyreDeg = degradationMap[lap.compound.toUpperCase()] || 0;
              adjustedLapTime -= lap.tyreLife * tyreDeg;
            }

            return {
              value: [lap.lapNumber, adjustedLapTime],
              driver: driver,
              compound: lap.compound,
              stint: stintNumber,
              originalLapTime: lap.lapTime
            };
          });

          const compound = stintData.compound;
          const compoundColor = getF1TireColor(compound);
          const driverColor = driverColors.get(driver) || '#888888';

          // Track series index for this driver
          if (!seriesIndexByDriver.has(driver)) {
            seriesIndexByDriver.set(driver, []);
          }
          seriesIndexByDriver.get(driver).push(seriesIdx);

          // Create a series for this stint
          series.push({
            name: `${driver} - Stint ${stintNumber}`,
            type: 'line',
            data: data,
            showSymbol: true,
            symbol: 'circle',
            symbolSize: 4,
            lineStyle: { width: 2, color: compoundColor },
            triggerLineEvent: true, // Enable line hover events
            itemStyle: {
              color: driverColor,  // Use driver color for markers
              borderColor: driverColor,
              borderWidth: 2
            },
            emphasis: {
              focus: 'none', // Don't use built-in focus
              lineStyle: { width: 3 },
              scale: true
            },
            blur: {
              lineStyle: { opacity: 0.05 },
              itemStyle: { opacity: 0.05 }
            },
            endLabel: {
              show: isLastStint,
              formatter: driver,
              position: 'right',
              offset: [6, 0],
              color: driverColor,
              fontSize: 11
            },
            animation: false,
            driver: driver // Store driver name for custom hover logic
          });

          seriesIdx++;
        });
      });

      // Store the number of driver series before adding visual indicators
      const driverSeriesCount = series.length;

      // Determine min and max lap numbers from all series data for visual indicators
      let minLap = Infinity;
      let maxLap = -Infinity;
      series.forEach(s => {
        if (s.data && s.data.length > 0) {
          s.data.forEach(point => {
            const lapNum = point.value[0];
            if (lapNum < minLap) minLap = lapNum;
            if (lapNum > maxLap) maxLap = lapNum;
          });
        }
      });

      // Detect rainfall, safety car, and red flag laps (before filters are applied)
      if (minLap !== Infinity && maxLap !== -Infinity) {
        const rainfallRanges = detectRainfallLaps(minLap, maxLap);
        const safetyCarRanges = detectSafetyCarLaps(minLap, maxLap);
        const redFlagLaps = detectRedFlagLaps(minLap, maxLap);

        // Add rainfall shading as a markArea series
        if (rainfallRanges.length > 0) {
          const markAreaData = rainfallRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Rainfall (Lap ${range.start})`
                : `Rainfall (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Rainfall',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: {
                color: 'rgba(30, 144, 255, 0.1)' // Blue with transparency
              },
              data: markAreaData,
              label: {
                show: false
              },
              tooltip: {
                formatter: (params) => {
                  return params.name;
                }
              }
            },
            animation: false
          });
        }

        // Add safety car shading as a markArea series
        if (safetyCarRanges.length > 0) {
          const markAreaData = safetyCarRanges.map(range => [
            {
              xAxis: range.start - 0.5,
              name: range.start === range.end
                ? `Safety Car (Lap ${range.start})`
                : `Safety Car (Laps ${range.start}-${range.end})`
            },
            { xAxis: range.end + 0.5 }
          ]);

          series.push({
            name: 'Safety Car',
            type: 'line',
            data: [],
            markArea: {
              silent: false,
              itemStyle: {
                color: 'rgba(150, 150, 7, 0.15)'
              },
              data: markAreaData,
              label: {
                show: false
              },
              tooltip: {
                formatter: (params) => {
                  return params.name;
                }
              }
            },
            animation: false
          });
        }

        // Add red flag vertical lines as a markLine series
        if (redFlagLaps.length > 0) {
          const markLineData = redFlagLaps.map(lap => ({
            xAxis: lap,
            name: `Red Flag (Lap ${lap})`,
            label: {
              show: false
            }
          }));

          series.push({
            name: 'Red Flag',
            type: 'line',
            data: [],
            markLine: {
              silent: false,
              symbol: 'none',
              lineStyle: {
                color: 'rgba(255, 0, 0, 0.5)',
                width: 2,
                type: 'dotted'
              },
              data: markLineData,
              label: {
                show: false
              },
              tooltip: {
                formatter: (params) => {
                  return params.name;
                }
              }
            },
            animation: false
          });
        }
      }

      // If no drivers selected, clear the chart
      if (series.length === 0) {
        chart.clear();
        return;
      }

      chart.setOption({
        backgroundColor: 'transparent',
        grid: { left: 60, right: 100, top: 20, bottom: 60 },
        legend: {
          show: false  // Hide legend, using endLabel instead
        },
        tooltip: {
          show: true,
          trigger: 'item',
          confine: true,
          borderColor: '#2a2f3a',
          backgroundColor: 'rgba(26,29,36,0.96)',
          textStyle: { color: '#e8e8e8' },
          extraCssText: 'padding:10px 12px;border-radius:10px',
          formatter: (p) => {
            const data = p.data;
            const lapNumber = data.value[0];
            const lapTime = data.value[1];
            return `
              <strong>${data.driver}</strong><br/>
              Lap: ${lapNumber}<br/>
              Time: ${lapTime.toFixed(3)}s<br/>
              Compound: ${data.compound}<br/>
              Stint: ${data.stint}
            `;
          }
        },
        xAxis: {
          type: 'value',
          name: 'Lap Number',
          nameLocation: 'middle',
          nameGap: 30,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          min: 1,
          max: scheduledLaps || 'dataMax'
        },
        yAxis: {
          type: 'value',
          name: 'Lap Time (s)',
          nameLocation: 'middle',
          nameGap: 45,
          nameTextStyle: { color: '#00e0ff', fontSize: 12, fontWeight: 600 },
          axisLine: { lineStyle: { color: '#9ca3af' } },
          axisLabel: { color: '#9ca3af' },
          splitLine: { lineStyle: { color: 'rgba(148, 163, 253, 0.1)' } },
          scale: true  // Auto-adjust y-axis limits
        },
        series: series
      }, true);

      // Resize chart
      chart.resize();

      // Custom hover behavior to highlight all series for a driver
      chart.off('mouseover');
      chart.off('mouseout');

      let currentHoveredDriver = null;

      chart.on('mouseover', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          const hoveredDriver = params.seriesName.split(' - ')[0]; // Extract driver name

          if (currentHoveredDriver === hoveredDriver) return; // Already hovering this driver
          currentHoveredDriver = hoveredDriver;

          const driverSeriesIndices = seriesIndexByDriver.get(hoveredDriver) || [];

          // Update chart option to emphasize/blur (only driver series)
          const updatedSeries = series.map((s, idx) => {
            // Skip visual indicator series (rainfall, safety car, red flag)
            if (idx >= driverSeriesCount) {
              return {}; // No changes to visual indicators
            }

            if (driverSeriesIndices.includes(idx)) {
              // Emphasize this driver's series
              return {
                lineStyle: { width: 3, color: s.lineStyle.color, opacity: 1 },
                itemStyle: { ...s.itemStyle, opacity: 1 },
                endLabel: { ...s.endLabel, opacity: 1 }
              };
            } else {
              // Blur other drivers' series
              return {
                lineStyle: { width: 2, color: s.lineStyle.color, opacity: 0.15 },
                itemStyle: { ...s.itemStyle, opacity: 0.05 },
                endLabel: { ...s.endLabel, opacity: 0.15 }
              };
            }
          });

          chart.setOption({
            series: updatedSeries
          });
        }
      });

      chart.on('mouseout', (params) => {
        if (params.componentType === 'series' && params.seriesType === 'line') {
          currentHoveredDriver = null;

          // Reset driver series to normal (skip visual indicators)
          const resetSeries = series.map((s, idx) => {
            // Skip visual indicator series
            if (idx >= driverSeriesCount) {
              return {}; // No changes to visual indicators
            }
            return {
              lineStyle: { width: 2, color: s.lineStyle.color, opacity: 1 },
              itemStyle: { ...s.itemStyle, opacity: 1 },
              endLabel: { ...s.endLabel, opacity: 1 }
            };
          });

          chart.setOption({
            series: resetSeries
          });
        }
      });
    }

    function processData(rows) {
      if (!rows.length) {
        chartContainer.style.display = 'none';
        chartControls.style.display = 'none';
        coefficientsContainer.style.display = 'none';
        driversPanel.style.display = 'none';
        if (chart) {
          chart.dispose();
          chart = null;
        }
        return;
      }

      // Group by driver and stint, tracking finishing info
      const driverData = new Map();

      rows.forEach(r => {
        const driver = String(r.lap_Driver || "").trim();
        const lapNumber = parseInt(r.lap_LapNumber);
        const lapTime = parseFloat(r.lap_LapTime);
        const compound = String(r.lap_Compound || "").trim();
        const stint = String(r.lap_Stint || "").trim();
        const position = parseInt(r.lap_Position);
        const tyreLife = parseInt(r.lap_TyreLife);
        const schedLaps = parseInt(r.sched_laps);

        if (!driver || isNaN(lapNumber) || isNaN(lapTime) || !stint) {
          return; // Skip invalid rows
        }

        if (!driverData.has(driver)) {
          driverData.set(driver, {
            driver: driver,
            stints: new Map(),
            maxLapNum: 0,
            lastPosition: null
          });
        }

        const data = driverData.get(driver);
        const driverStints = data.stints;

        if (!driverStints.has(stint)) {
          driverStints.set(stint, {
            compound: compound,
            laps: []
          });
        }

        driverStints.get(stint).laps.push({
          lapNumber: lapNumber,
          lapTime: lapTime,
          compound: compound,
          tyreLife: tyreLife,
          schedLaps: schedLaps
        });

        // Track max lap number and position on that lap
        if (lapNumber > data.maxLapNum) {
          data.maxLapNum = lapNumber;
          data.lastPosition = position;
        }
      });

      // Sort drivers by finishing position using shared utility
      const sortedDrivers = sortDriversByFinishingOrder(Array.from(driverData.values()));

      // Store current data (convert back to Map for rendering)
      const sortedDriverData = new Map();
      sortedDrivers.forEach(d => {
        sortedDriverData.set(d.driver, d.stints);
      });
      currentGroups = sortedDriverData;

      // Build driver list (in finishing order)
      const drivers = sortedDrivers.map(d => d.driver);

      // Auto-select top 5 drivers if no drivers are currently selected
      if (selectedDrivers.size === 0 && drivers.length > 0) {
        const top5 = drivers.slice(0, Math.min(5, drivers.length));
        top5.forEach(driver => selectedDrivers.add(driver));
      }

      buildDriversList(drivers);

      // Render lap time chart
      renderLapTimeChart(sortedDriverData);
    }

    function buildDriversList(drivers) {
      driversList.innerHTML = '';

      if (drivers.length === 0) {
        driversPanel.style.display = 'none';
        return;
      }

      driversPanel.style.display = 'block';

      drivers.forEach(driver => {
        const wrapper = document.createElement('label');
        wrapper.className = 'driver-item';

        const checkbox = document.createElement('input');
        checkbox.type = 'checkbox';
        checkbox.value = driver;
        checkbox.checked = selectedDrivers.has(driver);

        // Set checkbox color to driver color
        const driverColor = driverColors.get(driver) || 'var(--accent-color)';
        checkbox.style.accentColor = driverColor;

        checkbox.addEventListener('change', (e) => {
          if (e.target.checked) {
            selectedDrivers.add(driver);
          } else {
            selectedDrivers.delete(driver);
          }

          // Re-render chart with filtered data
          renderLapTimeChart(currentGroups);
        });

        const label = document.createElement('label');
        label.textContent = driver;
        label.style.cursor = 'pointer';
        label.style.color = driverColor;

        wrapper.appendChild(checkbox);
        wrapper.appendChild(label);
        driversList.appendChild(wrapper);
      });
    }
  </script>
</body>
</html>
